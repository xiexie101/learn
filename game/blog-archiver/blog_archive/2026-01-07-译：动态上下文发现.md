---
title: "译：动态上下文发现"
date: 2026-01-07
url: https://sorrycc.com/dynamic-context-discovery
---

发布于 2026年1月7日

# 译：动态上下文发现

> 原文：[https://cursor.com/blog/dynamic-context-discovery](https://cursor.com/blog/dynamic-context-discovery)  
> 作者：Jediah Katz  
> 译者：Claude Opus 4.5

Jan 6, 2026 by Jediah Katz in [research](https://cursor.com/blog/topic/research)

编程智能体正在快速改变软件的构建方式。它们的快速进步既来自于改进的智能体模型，也来自于更好的上下文工程来引导它们。

Cursor 的智能体框架——我们提供给模型的指令和工具——针对我们支持的每个新前沿模型都进行了单独优化。然而，我们可以进行一些适用于框架内所有模型的上下文工程改进，例如如何收集上下文以及在长轨迹中优化 token 使用。

随着模型作为智能体变得越来越好，我们发现通过预先提供更少的细节来取得成功，这使得智能体更容易自己拉取相关上下文。我们将这种模式称为**动态上下文发现**，与始终包含的_静态上下文_形成对比。

## 用于动态上下文发现的文件

动态上下文发现在 token 效率上要高得多，因为只有必要的数据才会被拉入上下文窗口。它还可以通过减少上下文窗口中可能令人困惑或矛盾的信息量来提高智能体的响应质量。

以下是我们在 Cursor 中使用动态上下文发现的方式：

1.  将长工具响应转换为文件
2.  在摘要过程中引用聊天历史
3.  支持 Agent Skills 开放标准
4.  高效加载仅需要的 MCP 工具
5.  将所有集成终端会话视为文件

## 1\. 将长工具响应转换为文件

工具调用可能会通过返回大型 JSON 响应来大幅增加上下文窗口。

对于 Cursor 中的第一方工具，如编辑文件和搜索代码库，我们可以通过智能工具定义和最小响应格式来防止上下文膨胀，但第三方工具（即 shell 命令或 MCP 调用）原生并没有得到同样的处理。

编程智能体采取的常见方法是截断长 shell 命令或 MCP 结果。这可能导致数据丢失，其中可能包含你想要在上下文中保留的重要信息。在 Cursor 中，我们改为将输出写入文件，并赋予智能体读取它的能力。智能体调用 `tail` 检查末尾，然后在需要时读取更多内容。

这减少了在达到上下文限制时不必要的摘要操作。

## 2\. 在摘要过程中引用聊天历史

当模型的上下文窗口填满时，Cursor 会触发一个摘要步骤，为智能体提供一个新的上下文窗口，其中包含其迄今为止工作的摘要。

但是智能体的知识在摘要后可能会退化，因为这是对上下文的有损压缩。智能体可能已经忘记了关于其任务的关键细节。在 Cursor 中，我们使用聊天历史作为文件来提高摘要的质量。

![](https://cursor.com/marketing-static/_next/image?url=https%3A%2F%2Fptht05hbb1ssoooe.public.blob.vercel-storage.com%2Fassets%2Fblog%2Fpast-chats-light.png&w=1920&q=70)

在达到上下文窗口限制后，或者用户决定手动进行摘要时，我们会给智能体一个历史文件的引用。如果智能体知道它需要摘要中缺失的更多细节，它可以搜索历史记录来恢复它们。

## 3\. 支持 Agent Skills 开放标准

Cursor 支持 [Agent Skills](https://cursor.com/docs/context/skills#agent-skills)，这是一个用于扩展编程智能体专业能力的开放标准。与其他类型的 [Rules](https://cursor.com/docs/context/rules) 类似，Skills 由文件定义，告诉智能体如何执行特定领域的任务。

Skills 还包括名称和描述，可以作为"静态上下文"包含在系统提示中。然后智能体可以进行动态上下文发现来拉取相关的 skills，使用 grep 和 Cursor 的[语义搜索](https://cursor.com/blog/semsearch)等工具。

Skills 还可以捆绑与任务相关的可执行文件或脚本。由于它们只是文件，智能体可以轻松找到与特定 skill 相关的内容。

## 4\. 高效加载仅需要的 MCP 工具

MCP 有助于访问 OAuth 保护的安全资源。这可能包括生产日志、外部设计文件，或企业的内部上下文和文档。

一些 MCP 服务器包含许多工具，通常带有冗长的描述，这会显著膨胀上下文窗口。大多数这些工具即使始终包含在提示中也从未被使用。如果你使用多个 MCP 服务器，这个问题会更加严重。

期望每个 MCP 服务器都为此进行优化是不现实的。我们认为减少上下文使用是编程智能体的责任。在 Cursor 中，我们通过将工具描述同步到文件夹来支持 MCP 的动态上下文发现。

智能体现在只接收少量静态上下文，包括工具名称，提示它在任务需要时查找工具。在 A/B 测试中，我们发现在调用 MCP 工具的运行中，这一策略**将智能体总 token 减少了 46.9%**（统计显著，根据安装的 MCP 数量有较高方差）。

![](https://cursor.com/marketing-static/_next/image?url=https%3A%2F%2Fptht05hbb1ssoooe.public.blob.vercel-storage.com%2Fassets%2Fblog%2Fmcp-tools-light-3.png&w=1920&q=70)

这种文件方法还解锁了向智能体传达 MCP 工具状态的能力。例如，以前如果 MCP 服务器需要重新认证，智能体会完全忘记那些工具，让用户感到困惑。现在，它实际上可以主动让用户知道需要重新认证。

## 5\. 将所有集成终端会话视为文件

用户不再需要将终端会话的输出复制/粘贴到智能体输入中，Cursor 现在将集成终端输出同步到本地文件系统。

这使得询问"为什么我的命令失败了？"变得很容易，并允许智能体理解你所引用的内容。由于终端历史可能很长，智能体可以 grep 只获取相关输出，这对于像服务器这样的长时间运行进程的日志很有用。

这反映了基于 CLI 的编程智能体所看到的内容，上下文中包含先前的 shell 输出，但是动态发现而非静态注入。

## 简单的抽象

目前尚不清楚文件是否会成为基于 LLM 的工具的最终接口。

但随着编程智能体的快速进步，文件一直是一个简单而强大的原语，比起又一个无法完全预见未来的抽象层，它是一个更安全的选择。敬请期待我们在这个领域分享更多令人兴奋的工作。

这些改进将在未来几周内对所有用户上线。本博客文章中描述的技术是许多 Cursor 员工的工作成果，包括 Lukas Moller、Yash Gaitonde、Wilson Lin、Jason Ma、Devang Jhabakh 和 Jediah Katz。如果你对使用 AI 解决最困难、最雄心勃勃的编程任务感兴趣，我们很乐意听取你的意见。请通过 [hiring@cursor.com](mailto:hiring@cursor.com) 联系我们。

Author: Jediah Katz
