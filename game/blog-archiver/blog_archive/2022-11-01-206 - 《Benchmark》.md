---
title: "206 - 《Benchmark》"
date: 2022-11-01
url: https://sorrycc.com/benchmark
---

发布于 2022年11月1日

# 206 - 《Benchmark》

> 这几天 turbopack 和 vite 因为 benchmark 的事「吵」地火热，翻了下相关的文章和库。

Benchmark 本身是客观的，但 Benchmark 啥和怎么 Benchmark 是主观的。

## Benchmark 啥？

梳理了下，有不少维度。

1、dev 的冷启动、热启动（带缓存）、HMR  
2、build 的冷执行和热执行（带缓存）  
3、HMR 还可细分是 leaf 更新还是 root 更新

## 怎么 Benchmark？

我之前做 Benchmark 都是在 node 侧用 console.time 打点，或者用 time 命令，这其实已经满足大部分场景，因为通常编译时间就能体现速度了，但 Vite 除外。因为 Vite 的编译是懒执行的，在浏览器执行后还会有额外的请求和编译任务，所以必须等到渲染结束后才算成功。

[https://github.com/yyx990803/vite-vs-next-turbo-hmr](https://github.com/yyx990803/vite-vs-next-turbo-hmr) 这种 Benchmark 的方式第一次看到。他计算的 HMR 时间是通过「页面组件渲染时间 - 文件修改时间」来实现的。相对比较手动，优点是准确。

## Turbopack 的 Benchmark 有问题吗？

个人观点。

1、一开始说「是 Vite 的 10x」这个营销方式有问题，实际上是只有 6 倍（15ms vs. 87ms），10x 是把 15ms 舍到 10ms 把 87ms 入到 90ms 的结果

2、用 vite + 默认的 babel 对比 turbopack 默认的 swc 有问题吗？我觉得没问题，因为 99.99% 的 vite + react 用户都用的这个搭配，后面改的 benchmark 用了 vite-plugin-swc-react-refresh，其目前的周下载只有 348（之前可能更少），根本就不是一个生产可用的方案

参考：  
[https://github.com/yyx990803/vite-vs-next-turbo-hmr/discussions/8](https://github.com/yyx990803/vite-vs-next-turbo-hmr/discussions/8)  
[https://github.com/yyx990803/vite-vs-next-turbo-hmr](https://github.com/yyx990803/vite-vs-next-turbo-hmr)  
[https://turbo.build/blog/turbopack-benchmarks](https://turbo.build/blog/turbopack-benchmarks)  
[https://vercel.com/blog/turbopack](https://vercel.com/blog/turbopack)  
[https://github.com/vercel/turbo/tree/main/crates/next-dev](https://github.com/vercel/turbo/tree/main/crates/next-dev)
