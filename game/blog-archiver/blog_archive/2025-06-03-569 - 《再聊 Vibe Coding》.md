---
title: "569 - 《再聊 Vibe Coding》"
date: 2025-06-03
url: https://sorrycc.com/vibe-coding-2
---

发布于 2025年6月3日

# 569 - 《再聊 Vibe Coding》

![](https://cdn.jsdelivr.net/gh/sorrycc-bot/image-2025-04@main/uPic/vibe%20coding%202.png)

上周 Vibe Coding 了三个项目。这三个项目中，有些比较顺利，有些则比较坎坷，记录一下心得，含模型、工具、流程、Tips 和感受。

1、**模型。** 我的想法是，1）用最好的模型，2）不同场景用最合适的模型。**个人推荐的三个模型是 o3、Gemini 2.5 Pro 和 Claude 4。** o3 负责创意类型的，比如说需求文档的确定；Gemini 2.5 Pro 的特点是大而强，用来对仓库做整体分析以及产出详细的执行计划；Claude 4 用于编码。当然，你用 DeepSeek 也能完成所有的任务，但是效果会打个大折扣。

2、**工具。** 我主要用 Cursor、各模型提供商的 Web 版、API 。编码主要是用Cursor，由于它独特的设计，它相比于 Cline 等其他工具更快也更省钱。我会在 ChatGPT Web 上和 o3 聊需求和设计方案，以及 Gemini Web，他们有 Canvas 或类似功能，可以持续更新输出的文档。API + 三方客户端用于轻量级和零散的聊天。

3、**流程。**

1）新项目从 0 到 1 。**我的方法是先依次产出三篇文档，需求文档、设计文档、任务拆解文档，过程中需要人为补充大量上下文，然后让 AI Step by Step 实施。** 我在 [upgear 的 context/init](https://github.com/sorrycc/upgear/tree/master/context/init) 目录下保留了这部分文档，供参考。其中需求文档和设计文档由 o3 产出，任务拆解由 Gemini 2.5 Pro 产出（Gemini 产出的比较详细又恰到好处，我试过 o3 和 Claude，效果都不太理想）。

2）老项目迭代。简单场景可以直接问。**针对复杂点的场景，我的方法是 repomix + Gemini 出任务拆解文档 + Claude 4 执行。** 先用 repomix 打包项目为单文件，然后把这个文件和修改要求一起提给 Gemini 2.5 Pro，要求他产出任务拆解文档，最后在 Cursor 里用 Claude 4 step by step 执行代码修改。

4、**一些 Tips** 。

1）25 Tool Calls Limit。Vibe Coding 过程中最烦的是这个，Cursor 做了限制，触发时需要手动点一下，见下图。这意味着不能让 Cursor 全执行地执行完所有任务。解法是，1）社区上有看到 [thelastbackspace/cursor-auto-resume](https://github.com/thelastbackspace/cursor-auto-resume)，可以自动点，但我还没试过，2）把声音打开，触发限制时会有提示音，然后点一下。

![](https://cdn.jsdelivr.net/gh/sorrycc-bot/image-2025-04@main/uPic/ZPuGgq.png)

2）Connection Failed。有时候触发 25 tool calls 时会触发下面这个错误，同时不管怎么 try again 都不行。解法是「⌘+R」退出当前 task 后重新进，要求「继续」即可。

![](https://cdn.jsdelivr.net/gh/sorrycc-bot/image-2025-04@main/uPic/np5Z5d.png)

3）要不要测试驱动。产出任务执行文档时，可以要求做测试驱动。此时，每个任务结束时都会确认所有的用例通过测试。这是一种比较稳妥的做法，但缺点是耗时比较长，可能是不做测试驱动的 2-3 倍。因为有些测试出错时，AI 需要不停地调整代码和测试用例，这就需要很长的时间。因此，是否采用测试驱动将是一个权衡，你可以多试试，然后视项目而定。

4）AI 会出错。比如我在写一个 Chrome 插件的时候，AI 会误把本应在 background 里执行的代码写到前台，然后报错。比如 chrome.tabs.query 。同时，你告知它修复了之后，它下次还是会再犯，屡教不改。所以得做好手工确认。我的做法是每一步之后都会做一下手工确认，看看 AI 改了哪些代码，并且按它提示的方法手动验证一下。这样不至于到最后发现整个流程都跑不通。

5）选择流行的技术和框架。流行的技术通常会有更好的文档、生态、示例代码等，对于AI来说，就更有可能产生出好的结果。如果构建 Web 应用，用 Next.js + Supabase + TailwindCSS + Next Auth + Shadcn/ui，别用 Svelte、Vue；如果构建 Chrome 插件，用 plasmo 或 wxt；如果构建游戏，用 Unity 或 Unreal，别用 JavaScript + Three.js 。

6）选择相对熟悉的技术栈。因为 AI 不能自己完成所有事，他也可能会做错，当他出错时，就需要你协助他理清逻辑。如果你对技术栈熟悉，流程会更通顺一些。

7）常用 Git 提交代码。虽然 Cursor 有 CheckPoint 的功能，但实际用下来发现有时并不是那么靠谱，尤其是你有多个工作流相互交错的时候。同时，Bash 命令的执行是不能通过 CheckPoint 撤销的。因此，使用 Git 提交代码始终是最保险的，方便往前做单步或多步的回滚。

8）提供示例代码。指望 AI 基于文档就能够完全地处理三方库或 API，可能没有那么靠谱。因此，在构建完整功能之前，先让 AI 写一个小功能，你辅助着一起调试。一旦它能工作，保存下来。在 AI 执行完整任务的时候，把示例代码交给 AI ，让它参考着来，这样会更好。

9）如果卡主。不同的问题解法不同。我尝试过的包括，a）把错误信息和相关文件交给 AI 修复，b）用 repomix 打包完整的项目，加上出错信息、做过的常识、日志等一起交给 AI，让他告诉我可能的问题，c）打包整个项目，让他告诉我某个流程的执行逻辑，d）让他写辅助脚本，方便我对问题进行调试，等等。

10）域名和网站名称的建议可以问 o3。我有对比 o3 和其他模型的产出，o3 的结果明显更强一些。同时，它会对域名做一些可注册性的校验，所以它出的结果基本上就直接可用。

5、**一些感受。**

1）Vibe Coding 对我来说还是感觉挺爽的。爽的点在于你能完成一个自己之前不那么熟悉的技术栈的产品上线，比如 Chrome 插件。另外就是速度，我周末 Vibe Coding 了两个项目，一个 Chrome 插件，一个网站，加起来总共花了七八个小时的时间，大部分时间花在想法和问题调试阶段。

2）感觉 Vibe Coding 时角色有一些变化。你要做的不再是写代码，更多是产品经理的角色。这也可能也是现在很多产品经理容易转行做 Vibe Coding 的原因。你要做的就是把想法想清楚，然后和 AI 交流，创造相关的文档，最后让 AI 去实施。

3）之前我觉得编码是发挥创意的阶段，Vibe Coding 时反而觉得在整个流程中，梳理想法以及和 AI 交流需求时更有意思。后面的实施变得有点机械化，你要做的就是不断地告诉告诉 AI 去「执行下一个任务」。

4）未来应该，大部分代码不再需要人力手工去编写。因为 Vibe Coding 可以完成大部分代码，同时 AI 产出的代码质量以及对整个系统的规划和布局都比很多程序员写的要更好和更加合理，而且更快。

5）当大家都能快速 Vibe Coding 项目并上线的时候，未来是否还需要那么多的程序员？我觉得要看需求的增长是否能赶得上 Vibe Coding 的速度增长。AI 有可能能让大家变得更有创意和需求。同时产品经理也会用 AI，他们产出需求的速度也会更快。未来淘汰的应该只是不会用 AI 的程序员（感觉我在制造焦虑。。）。

6）Vibe Coding 的一个缺点是，生成代码的不熟悉感。但我觉得也要辩证地看待。如果项目是一次性的，且对可维护性要求本就不高；如果你自己写的项目，不怎么维护，过段时间看同样会有不熟悉感，以及你写的代码对于团队其他同学来说同样会有不熟悉感。因此，这个问题还是得自己去做权衡。

7）由于 Vibe Coding 在编码的阶段相对比较机械，需要花比较多的时间等待 AI 完成工作，所以可以开启多线程编码。

参考：  
[563 - 《Vibe Coding》](https://sorrycc.com/vibe-coding)  
[530 - 《我怎么用 AI 辅助编程》](https://sorrycc.com/how-to-use-ai-to-assist-programming)
