---
title: "340 - 《Tree Shaking 原理》"
date: 2023-09-06
url: https://sorrycc.com/tree-shaking-principle
---

发布于 2023年9月6日

# 340 - 《Tree Shaking 原理》

> 下午听团队同学讲的分享，怕忘，记录下。其实上次听另一个同学讲过一遍，但是忘了。

以一个最简示例为例。比如，我们有 entry.ts 和 a.ts 两个文件，entry.ts 依赖 a.ts。

```ts
// entry.ts
import a from './a';
a();

// a.ts
let a = 1;
let b = 2;
export default function() {
  a;
}
export function c() {
  b;
}
```

tree shaking 完成后应该如下。

```ts
// entry.ts
import a from './a'
a();

// a.ts
let a = 1;
export default function() {
  a;
}
```

这是怎么做到的？下面说下我的理解。

1、先对包含所有依赖的 Module Graph 做 Topo Sort 排序，让 dependent 始终在 dependency 之前，即「被依赖的始终在后」。因为一个文件（module）需要先知道自己有哪些被使用的地方，才知道怎么对自己做 Tree Shaking。

2、可能会有环（循环依赖）。比如 a 依赖 b 依赖 c 依赖 a，形成循环依赖后就无法很好地分析出当前模块的被使用情况，所以通常简单起见，会把整个环内的模块都当成有副作用，而不做 Tree Shaking 处理。

3、回到前面的例子。先分析 entry.ts，发现 entry 模块有使用 a 模块的 default export，就对 a 模块做下标记，表示有「人」在用他的 default export 。等依赖 a 模块的模块全部分析完一遍，我们就知道 a 模块有没有被使用，以及有哪些 export 被使用，这样等到分析 a 模块时，就可以根据这个信息决定模块内部哪些语句要，哪些语句不要。

4、再分析 a 模块。a 模块有 4 个 top level 的语句，两个 let declaration 语句和两个 export 语句。需要建立一个 statement graph，包含 statement 之间的依赖关系，比如 export default function() { a; } 依赖 let a = 1;，比如 export function c() { b; } 依赖 let b = 2; 。有了这个图之后，基于前面的信息，export 里只有 default 有被用到，所以 export function c 没有被用到，是可以被删除的。然后把这个语句删了之后，statement graph 里，let b=2; 这个语句就没有到他的边了，所以 let b=2 也可以删除。

5、以上是最简单的场景，而在真实业务中，Tree Shaking 是很复杂的。同时做地好的 Tree Shaking 可能比不好的 Tree Shaking 在尺寸上少几倍，比如 import { Button } from ‘antd’ 的例子，之前测试时，webpack 265K、rspack 289K、farm 321K。复杂场景的处理比如对于 Side Effects 的处理，CJS 通常是被判定为有 Side Effects 不走 Tree Shaking 的，但有些工具比如 Webpack 还可以做 CJS 的局部优化；比如自执行的语句（e.g. try catch）通常会被判定为有 side effect；比如对于 export \* from xxx 的处理，等等。

参考：  
[279 - 《调研 Tree Shaking 实现》](https://sorrycc.com/tree-shaking)  
[63 - 《ESBuild 和 Webpack 的 Tree Shaking 差异及其用途》](https://sorrycc.com/esbuild-webpack-tree-shaking)
