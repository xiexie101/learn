---
title: "187 - 《蚂蚁中后台数据流的新选型》"
date: 2022-09-16
url: https://sorrycc.com/antfin-data-flow
---

发布于 2022年9月16日

# 187 - 《蚂蚁中后台数据流的新选型》

我们的数据流方案要做一次迭代，以下是做了些调研后的整理，暂未包含和 Umi 框架结合的部分。

背景知识：[数据流 2022](https://yuque.antfin.com/yunqian/write/tw6wlb)

先说结论：目前个人的倾向是，基于 Valtio 浅封一个数据流方案集成到 Umi 中。

## 为啥是 valtio？

valtio 的特点是外部多 Store + 基于 Proxy。1）个人用不惯 jotai 和 recoil 这种 react 内部原子化的数据流方案，感觉和被 redux 培养起来的心智模型有冲突，所以会更倾向于外部 Store 一些，2）由于场景是中后台，对于兼容性的容忍度比较高，比如不用兼容 IE11，所以完全可以用基于 Proxy 的数据流方案，这类数据流方案在更新数据和读取数据时都更简单。

## 为啥不是 zustand？

zustand 和 valtio 是同一个作者写的，功能覆盖上其实比较类似，最大的区别是 valtio 基于 proxy 而 zustand 不是。个人有几个方面的考虑，1）更新数据，2）读取数据，3）类型提示。

更新数据的方式更符合人性，比如可以直接 `state.todos['321'].completed = true`，而不用 `setState(todos => ({ …todos, 321: { …todos['321'], completed: true } }))`。当然，这一点非 proxy 方案可基于 immer 实现和 proxy 方案类似的操作。

读取数据默认高性能，无需 selector。非 proxy 方案比如 react-redux 和 zustand 为了性能优化，避免不必要的 re-render，通常会通过 selector 选择 store 的一部分，这会带来不必要的心智负担。基于 Proxy 的方案是响应式的，无需 selector，默认高性能。

类型提示的差异主要在扩展上。valtio 用的是组合式，zustand 用的是 middleware。没具体试过 zustand 的 middleware，但个人理解，理论上 middleware 的类型提示没有 valtio 友好。比如 valtio 的 proxyWithHistory 会把数据结构改成 `{ value, history, redo, undo, … }` 这种，在类型提示上可以完美衔接。

## 为啥要封一层而不直接用？

有几个考虑。

1、valtio 未来肯定会迭代，加一层封装能抹平大版本更新导致的可能的 break change，方便做应用治理

2、调整实现。比如包括，1）约束接口；2）封装更多符合蚂蚁需求的扩展，比如 persistant storage 扩展、log 扩展、auto loading state 扩展等；3）支持全局生效的扩展。

3、便于和框架结合，在使用、性能等方面都有更优表现，没具体展开想过，目前想到的比如基于路由的按需、store 微生成器、配置式的扩展、和请求方案的结合等

## valtio 的功能如何？

> **数据流方案应该关注啥？** 整理之后发现还是有不少的。比如心智模型、读取数据、写入数据、数据推导、异步 Action、渲染性能优化、Suspense 并发模式支持、SSR 支持、React 之外访问、组件封装、瞬时更新、插件中间件扩展、Redux DevTools 支持、兼容性、多实例和单实例、数据序列化能力、同步/异步更新、内存管理、测试、包尺寸等。（还有啥？）大部分数据流方案都考虑了这些点，区别是实现方式和使用体验上的差异。

### 基本用法

极其简单。

```ts
// 1、定义数据
const state = proxy({ count: 0 });
// 2、使用数据
const snap = useSnapshot(state);
snap.count;
// 3、更新数据
state.count += 1;
```

### React 外访问

天然支持。

```ts
const state = proxy({ count: 0 });
state.count;
state.count += 1;
```

### 数据推导

```ts
const state = proxyWithComputed({
  count: 0,
}, {
  double: snap => snap * 2,
});
```

### Action 和异步 Action

两种用法，可以和 state 放一起，也可以分开。

```ts
// 方法一：放一起
const state = proxy({
  count: 0,
  actions: {
	  add() {
	    // 注意这里别用 this.count，基于 snap 调用时会报错
	    state.count += 1;
	  },
  }
});
// 方法二：分开放
const state = proxy({ count: 0 });
const actions = {
  add() {
    state.count += 1;
  },
  // 异步 action
  async addAsync() {
    state.count += await fetch('/api/add');
  },
};
```

### 数据结构的拆分与组合

```ts
// 比如如下定义
// state.foo 和 state.bar 都是 proxy，可拆分使用
const state = proxy({
  foo: { a: 1 },
  bar: { b: 1 },
});

// 组合
const foo = proxy({ a: 1 });
const bar = proxy({ b: 1 });
const state = proxy({ foo, bar });
```

### 组件封装

如果 props 内容和 state 无关，可以不处理；如果有关，按以下方式用 context 包一下，同时做 props 到 state 的数据同步即可。

```ts
// 1、createContext
const MyContext = createContext();
// 2、Provider
const value = useRef(proxy({ count: 0 })).current;
<MyContext.Provider value={value} />
// 3、useContext
useContext(MyContext);
```

### Redux DevTools 支持

```ts
const state = proxy({ count: 0 });
devtools(state, { name: 'count', enable: true });
```

### Redo & Undo 支持

```ts
const state = proxyWithHistory({
  count: 0,
});
state.value.count;
state.value.count += 1;
state.undo();
state.redo();
state.history;
```

### 持久化缓存

```ts
const state = proxyWithPersistant({
  count: 0,
}, {
  type: 'localStorage',
  key: 'count',
});
```

### 扩展

valtio 是基于组装式的扩展方式，相比 middleware 的方式在类型提示上会更好一些。比如我要实现前面的 proxyWithPersistant，简单点的方案只要这样，

```ts
export function proxyWithPersist<V>(val: V, opts: {  
  key: string;  
}) {  
  const local = localStorage.getItem(opts.key);  
  const state = proxy(local ? JSON.parse(local) : val);  
  subscribe(state, () => {  
    localStorage.setItem(opts.key, JSON.stringify(snapshot(state)));  
  });
  return state;  
}
```

### 兼容性

1）需要 React 16.8 或以上，2）不支持 IE 11，3）map 和 set 不能直接用，需改用 valtio 提供的 proxyMap 和 proxySet。

```ts
const state = proxy({
  todos: proxyMap<number, Todo>([[1, {id:1,text:'Learn Umi'}]]),
  filter: 'all',
});
```

### 测试

可以直接测 store，也可以测基于 store 的 React 组件。正常写用例即可，后者推荐用 @testing-library/react。

### 瞬时更新

TODO。

### Suspense 并发模式支持

TODO。

### SSR 支持

TODO。

### 包尺寸

极小 2.72KB；utils 全加上会大一点，10KB 左右吧。

## 如何与 Umi/Bigfish 框架结合？

### 配置开启

```ts
export default {
  proxyStore: {},
}
```

配置不使用具体的方案名 valtio 是为了后续可能的方案变更，但文档里会提。

### import from umi

```ts
import {
  proxy,
  proxyWithComputed,
  proxyWithHistory,
  proxyWithPersistant,
  proxyWithDevtool,
  proxyMap,
  proxySet,
	useSnapshot
} from 'umi';
```

### umi g

```bash
$ umi g store foo
Create stores/foo.ts.

$ umi g store foo --page
Create pages/foo/store.ts.

...
```

### 目录结构推荐/约束

```ts
// 全局 store
+ stores
+ pages
	+ foo
		// 页面级 store
		- store.ts
		- foo.tsx
	+ bar
		// 页面级 store
		+ stores
		- bar.tsx
```

### runtime lint error

把 [GitHub - pmndrs/eslint-plugin-valtio: An eslint plugin for better valtio experience](https://github.com/pmndrs/eslint-plugin-valtio) 里的方案通过 babel 插件实现。

### proxyWithAdapter

```ts
const state = proxyWithAdapter();
state.adapter.addOne();
state.adapter.setOne();
state.adapter.updateOne();
state.adapter.removeOne();
...
```

[169 - 《RTK 里的 createEntityAdapter》](https://sorrycc.com/rtk-create-entity-adapter)

### proxyWithLoading

```ts
const state = proxyWithLoading({
  actions: {
    async foo() {}
  }
});

state.action.foo();
state.loading.global;
state.loading.actions.foo;
```

### proxyWithLogger

。

### builtinStore

可以获取到 umi 框架内部信息，包括路由、配置等。

### 迁移方案：从 useModel 到 proxyStore

TODO

### 和 initialState、layout、qiankun 的联动

TODO

### store action 里能调用其他 hooks 吗？

不能！
