---
title: "31 - 《MFSU 原理》"
date: 2022-01-07
url: https://sorrycc.com/mfsu-how
---

发布于 2022年1月7日

# 31 - 《MFSU 原理》

> 解答一位同学的提问。

MFSU 在 Umi 4 中做了重构，解了之前版本里的大部分问题，还有很多新改进，可以直接看 umi 4 的源码，详见 [https://github.com/umijs/umi-next/tree/master/packages/mfsu](https://github.com/umijs/umi-next/tree/master/packages/mfsu) 。并且有提取单独的包，所以对所有 webpack 5 项目都适用，不仅是 umi。

建议直接用 `@umijs/mfsu` 这个库，而不需要自己重新搭一遍，这里有个[例子](https://github.com/sorrycc/example-webpack-mfsu)。

再说下实现方法。

![](https://img.alicdn.com/imgextra/i4/O1CN01Forqtf26SKmgaNJ3S_!!6000000007660-2-tps-1200-606.png)

1、项目源码会走到 babel 插件，插件会做两件事，1、修改源码，从 remote 获取资源，2、收集依赖到依赖图谱。

2、从 remote 获取比如之前 import a from ‘a’，会修改为 import a from ‘remote/a’，这里涉及到匹配问题，通常是依赖走 remote，相对路径不修改，有个细节点是得处理 alias 和 externals 这些可能改变资源引用的情况。

3、收集依赖到依赖图谱是为了精准更新。

4、等 webpack 编译完（hooks.done）之后，从依赖图谱里拉取信息，可能需要完整信息，也可能是 diff 信息，然后通知 dep builder 做依赖预编译。

5、dep builder 有两个选择，webpack 或 esbuild，选 esbuild 是为了提速，让首次编译依赖也变快，不管选啥，产物都是 module federation 格式。

6、有了预编译好的依赖和前面修改后的源码 remote/a，最后一件事就是把他们串起来，办法是用 webpack 的 Module Federation Plugin。

然后还有个关键点在图里没说明的是，由于 `import from 'a'` 改成了 `import from 'remote/a'`，整个链路就变成异步的，所以要把整体都改成异步，最简单的做法是在入口外加一层入口，内容为 `await import('path/to/your/origin/entry')` 。
