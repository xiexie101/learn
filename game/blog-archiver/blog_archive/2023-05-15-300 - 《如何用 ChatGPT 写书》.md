---
title: "300 - 《如何用 ChatGPT 写书》"
date: 2023-05-15
url: https://sorrycc.com/chatgpt-write-book
---

发布于 2023年5月15日

# 300 - 《如何用 ChatGPT 写书》

上周用 ChatGPT 写了本书，内容我放 [github](https://github.com/sorrycc/frontend-interview-book-by-chatgpt) 了。1300+ 提问次数，跑了几小时，24W 字，1.6M。由于用的 GPT 3，感觉质量并不太好，我手动对比了 GPT-3 和 GPT-4 针对一些问题的答案，后者明显更好。所以，找机会我会用 GPT-4 的 API 再跑一边。

由于是关于前端面试题的书，所以内容结构非常简单，「大纲」+「问题」就好了。所以，生成这本书只要三步。

1、生成大纲（章节信息）  
2、为每一节生成题目列表  
3、为每个题目生成答案

生成大纲我用的 prompt 是这个。

```ts
我想写一本关于前端面试题大全的书，请帮我列一个大纲。不需要描述和介绍，只返回 JSON 数据，JSON 数据最多两级。JSON 格式比如这样。

[
  {level:1,title:'123'},
  {level:2,title:'345'},
]
```

生成题目列表我用的 prompt 是这个。

```ts
我需要 20 个关于「JavaScript > 高级概念与性能优化」的面试题，请以 JSON 格式输出给我，不需要额外介绍。比如这样。

["问题1", "问题2"]
```

生成答案我用的 prompt 是这个。

```ts
请回答这道前端面试题「闭包是什么？它有哪些应用场景？」，尽量详细，如果有示例代码则更好。
```

代码。

```ts
import axios from 'axios';
import path from 'path';
import fs from 'fs';
import { Cache } from './cache';
import { getEnv } from './env';

const cache = new Cache({
  filePath: path.join(__dirname, '../.cache/cache.json'),
});

type Outline = { title: string; level: number }[];

export async function main() {
  // 生成大纲
  const defaultOutline = require('../data/outline.json');
  const outline: Outline = (cache.get('outline') || defaultOutline) as Outline;

  // 生成题目
  let level1 = '';
  let level2 = '';
  let level3 = '';
  let count = 0;
  const total = outline.length;
  for (const item of outline) {
    count += 1;
    console.log(`正在生成 ${count}/${total}`);
    const { title, level } = item;
    if (level === 1) level1 = title;
    if (level === 2) level2 = title;
    if (level === 3) level3 = title;
    if (level < 3) continue;

    // if (count >= 1) break;

    const totalTitle = `${level1} > ${level2} > ${level3}`;
    const prompt = `我需要 20 个关于「${totalTitle}」的面试题，请以 JSON 格式输出给我，不需要额外介绍，不需要给答案。比如这样 ["问题1", "问题2"]。`;
    console.log('> ', prompt);
    const result = await getPromptAnswer(prompt);
    console.log(result);
    const key = `questions-${totalTitle}`;
    cache.set(key, JSON.parse(result));
    // const content = await generateContent(title, level);
    // cache.set(title, content);
  }

  // 生成答案
  const keys = cache.getKeys().filter((key) => key.startsWith('questions-'));
  const questions = [];
  for (const key of keys) {
    questions.push(...(cache.get(key) as string[]));
  }
  const totalQuestions = questions.length;
  let questionCount = 0;
  for (const question of questions) {
    questionCount += 1;
    console.log(`正在生成答案 ${questionCount}/${totalQuestions}`);
    const prompt = `请回答这道前端面试题「${question}」，尽量详细，如果有示例代码则更好。`;
    console.log('> ', prompt);
    const result = await getPromptAnswer(prompt);
    console.log('answer', result);
    const key = `answers-${question}`;
    cache.set(key, result);
  }

  // 生成 Markdown
  const content = [];
  let _level1 = '';
  let _level2 = '';
  let _level3 = '';
  for (const item of outline) {
    const { title, level } = item;
    if (level === 1) {
      _level1 = title;
      content.push(`# ${title}`);
      continue;
    }
    if (level === 2) {
      _level2 = title;
      content.push(`## ${title}`);
      continue;
    }
    if (level === 3) {
      _level3 = title;
      content.push(`### ${title}`);
    }
    const totalTitle = `${_level1} > ${_level2} > ${_level3}`;
    const key = `questions-${totalTitle}`;
    for (const question of (cache.get(key) as string[])) {
      const answerKey = `answers-${question}`;
      const answer = cache.get(answerKey);
      content.push(`#### ${question}`);
      content.push(`${answer}`);
    }
  }
  fs.writeFileSync(path.join(__dirname, '../data/BOOK.md'), content.join('\n'));
}

async function delay(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function getPromptAnswer(prompt: string) {
  let retryCount = 0;
  while (retryCount < 10) {
    try {
      if (cache.get(prompt)) return cache.get(prompt);
      const server = getEnv().OPENAI_API_SERVER as string;
      const { data } = await axios.post(server, {
        message: prompt,
      });
      const answer = data.text.trim();
      cache.set(prompt, answer);
      return answer;
    } catch (error) {
      retryCount++;
      console.log(`Error occurred while fetching prompt answer. Retrying... (${retryCount}/5)`);
      await delay(3000 * retryCount);
    }
  }
  throw new Error(`Failed to fetch prompt answer after ${retryCount} attempts.`);
}

```

一些注意点，

1、各个步骤之间的数据可以用 json 串起来  
2、token 访问有次数限制，这种几千个的请求数，很容易会失败，可以加个 3s x 次数的重试，次数设到 10 基本上就再遇到报错了  
3、数据得随时存到物理文件里，由于时间耗时较长，随时可能会失败的

后续 TODO，

1、加下并发，搞个 100 个 token，应该就可以 10 分钟一本书了  
2、换 GPT-4 再跑一遍，24W 字差不多得有 48W Token 消耗，按 $0.03/1K 的价格算，需要 $14.4  
3、Prompt 需要再打磨下，比如加个身份标识，让他以技术作者的身份写，效果可能会更好
