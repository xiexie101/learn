---
title: "286 - 《手撕源码 31：magicast》"
date: 2023-04-14
url: https://sorrycc.com/source-31-magicast
---

发布于 2023年4月14日

# 286 - 《手撕源码 31：magicast》

1、[magicast](https://github.com/unjs/magicast) 是最近比较火的库，感觉 Umi 里也会有地方需要用到，于是翻了翻。作者是「pi0」和「antfu」。从[初始 commit](https://github.com/unjs/magicast/commit/c132d1f0e7a3dd6b410683ba4d0a90a1b9caf8fc) 来看，想法源于「pi0」，同时一开始是叫「paneer」，基于 recast 做 ast 操作，然后被「antfu」发扬光大了。

2、盲猜这个库是给 nuxt devtools 用的，通过 ast 的方式修改用户配置。几年前做 umi ui 也做过一版，即 umi config 命令，umi 4 也有，但还不够完善。当前，很明显 magicast 基于 proxy 的方式写起来会更优雅。除了 umi config，另外想到可以应用的场景是 codemod 脚本，但不知道用深了之后坑多不多，因为 ast 操作边界场景实在是比较多，用户指不定会怎么写代码。

3、通过 README 文档，发现 API 层有 loadFile、writeFile、parseModule、generateCode、builders，属性层有 `.$ast`、`.$type` 和 `.$args`，同时还有些 helpers 方法在 magicast/helpers 下。

4、简单上手是这样。

a）新建 config.js，内容是 `export default {foo: ['a']}` 。  
b）新建 test.mjs，内容如下。

```ts
import { loadFile, writeFile } from "magicast";
const mod = await loadFile("config.js");
mod.exports.default.foo.push("b");
await writeFile(mod);
```

c）pnpm i magicast -D  
d）node test.mjs  
e）此时会生成 output.js，内容是 `export default {foo:["a","b"]` 。

但是好像不支持 scope bindings。比如用户用了赋值的方式写，`const foo = ["a"]; export default { foo };`，简单试了下，发现并不支持。如果不支持的话，会有很多边界场景的坑。感觉可以完善下，增加一个配置项，可以在遇到遇到 identifier，顺着 scope 往上找 bindings。

5、源码方面依赖了 @babel/parser、@babel/types 和 recast。你可能会有疑问，为啥 @babel/parser 和 recast 会同时出现？翻下源码会发现，其实是用的 recast 的 transform、generate、sourcemap 等能力，然后 parser 部分用了 @babel/parser。为啥不用 recast 自己的 parser？因为他不支持 TypeScript。那为啥用 recast 而不是 babel 全家桶？我猜可能因为 recast 是专门的 transform 工具，API 看似更友好一些。recast 的自我介绍是「JavaScript syntax tree transformer, nondestructive pretty-printer, and automatic source map generator」。

6、源码部分的逻辑如下。

```ts
- loadFile
	- parseModule
		- proxifyModule
			- createProxy
			- createExportsProxy
				- proxify
			- createImportsProxy
				- creatImportProxy
				- createProxy
```

而如果只想知道核心思路，可以翻下第一个 commit，核心代码如下。

```ts
export function proxifyNode (node: any) {
  return new Proxy(node, {
    get (_, key: string) {
      // .exports
      if (key === 'exports') {
        const nodeExports: ProxifiedNode['exports'] = {}
        for (const n of node.program.body) {
          if (n.type === 'ExportNamedDeclaration') {
            nodeExports[n.declaration.declarations[0].id] = proxifyNode(n.declaration)
          } else if (n.type === 'ExportDefaultDeclaration') {
            nodeExports.default = proxifyNode(n.declaration)
          }
        }
        return nodeExports
      }

      // .props
      if (key === 'props') {
        return Object.fromEntries(node.properties.map(prop => [prop.key.name, proxifyNode(prop)]))
      }

      // .push
      if (key === 'push') {
        return value => ast.push(node, value)
      }

      // Fallback to node
      return node[key]
    }
  })
}
```

基于 Proxy 实现，通过 `.x` 访问属性时做一些实时的操作，这里对 exports、props 和 push 做了特殊处理，里层的 ast 会套新的 proxifyNode。

7、工程化部分没啥特别的。1）dev 命令是 vitest，所以这个库的日常开发是测试驱动的，2）build 后没有生成 sourcemap 文件，所以不能直接里 WebStorm 开调试模式调源码（？）

参考：  
[https://github.com/unjs/magicast](https://github.com/unjs/magicast)
