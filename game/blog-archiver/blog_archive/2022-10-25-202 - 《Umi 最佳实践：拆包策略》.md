---
title: "202 - 《Umi 最佳实践：拆包策略》"
date: 2022-10-25
url: https://sorrycc.com/umi-best-practise-code-splitting
---

发布于 2022年10月25日

# 202 - 《Umi 最佳实践：拆包策略》

> 计划近期每周更新 1 篇 Bigfish 2022 版的最佳实践，这是第 4 篇。

## 现有方案

Umi 3 默认禁用了拆包，把所有文件合并到一起，产物只有一个 umi.js 和一个 umi.css。好处包括，1）部署容易，不需要考虑 publicPath，2）通过 proxy 代理到本地调试时容易，规则简单好写，等等。坏处也很明显，性能差，需要把所有页面的 JS 和 CSS 加载完成后，才开始解析、执行和渲染页面。Umi 3 同时还提供了 dynamicImport 配置，用于开启基于路由的拆包（code splitting）。

![](https://img.alicdn.com/imgextra/i1/O1CN012wxwtu1FbnHlUFFTz_!!6000000000506-2-tps-2084-646.png)

那么，拆和不拆，到底哪个是最佳实践？我觉得不拆是提升了 DX（开发体验） 却损害了 UX（用户体验），所以我觉得拆更好一些。所以，Umi 4 反着来，默认做基于路由的拆包，同时通过 FAQ 让开发者可以通过安装和配置额外的 babel 插件手动切换到不拆的模式。

Umi 4 默认支持基于路由的拆包，同时开发者可以通过 `import()` 手动拆包，前者也是基于 `import()` 语法。这种拆包的方式在 webpack 里叫 async chunk。此外，webpack 还支持通过 `optimization.splitChunks` 和 `optimization.runtimeChunk` 配置公共 chunk 的提取和组织，而这两个配置 Umi 都没有提供默认值，用的是 Webpack 的默认策略。

## 问题

Umi 3 + Webpack 4 默认的 cacheGroups 配置如下。

```ts
cacheGroups: {
  vendors: {
    test: /[\\/]node_modules[\\/]/,
    priority: -10
  },
  default: {
    minChunks: 2,
    priority: -20,
    reuseExistingChunk: true
  },
},
```

这个配置有较为明显的缺陷，即 vendors 里没有配置 `reuseExistingChunk:true`。这会导致重复依赖的出现，比如 antd 组件可能同时出现在多个不同路由的 async chunk 产物里，所以 Umi 3 文档里有一篇是[关于如何解这个重复问题的](https://v3.umijs.org/zh-CN/guide/boost-compile-speed#%E8%B0%83%E6%95%B4-splitchunks-%E7%AD%96%E7%95%A5%EF%BC%8C%E5%87%8F%E5%B0%91%E6%95%B4%E4%BD%93%E5%B0%BA%E5%AF%B8)。（注：webpack 5 的默认配置里已加 reuseExistingChunk，所以不会再有这个问题。）重复依赖危害较大，包括：1）产物尺寸大幅增加，2）打包慢，3）潜在的加载问题，比如前一篇最佳实践文件中提到的「覆盖样式切换路由后被默认样式再次覆盖」的问题。

那么，是否解了这个问题后，使用 webpack 5 默认的 cacheGroups 配置就是最佳的方式了？我理解并不是，默认的 cacheGroups 还存在几个问题。1）拆包不合理，比如默认 chunk 是 async 而不是 all，没有包含 initial chunk，在 Umi 框架里会导致 umi.js 过大，从而影响初始页面的加载，2）没有合理利用缓存，每次发布构建时都会产出新的 chunk hash，从而导致缓存失效，但有些依赖其实非常稳定，比如 react、lodash 等，他们并不需要每次发布后都更新缓存。

## 新方案

社区和我们在项目的实践过程中，发现有一些大家在用的拆包策略。

### 一、大 vendors 策略

```ts
{
  vendors: {
    test: /[\\/]node_modules[\\/]/,
    priority: 10,
    name: 'vendors',
  }
}
```

把所有依赖合到一起，绝对不会有重复。同时缺点是，1）单文件的尺寸过大，2）毫无缓存效率可言。

```bash
info  - File sizes after gzip:

  215.74 kB         dist/vendors.js
  17.67 kB (+17 B)  dist/umi.js
  581 B (-573 B)    dist/p__foo.async.js
  579 B (-574 B)    dist/p__index.async.js
  282 B             dist/p__index.chunk.css
  282 B             dist/p__foo.chunk.css
```

### 二、一个依赖一个包策略

```ts
{
  vendors: {
    test: /[\\/]node_modules[\\/]/,
    priority: 10,
    name(module) {
      // 这里是简单示例，实际上还要针对 npm client 产物格式进行处理，比如 pnpm 和 cnpm 的命名方式就不同
      const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1];
      return `npm.${packageName.replace('@', '')}`;
    },
  }
}
```

和策略 1 类似，不同的是把依赖按 package name + version 进行拆分，算是解了策略 1 的尺寸和缓存效率问题。但同时带来的潜在问题是，可能导致请求较多。我的理解是，对于非大型项目来说其实还好，因为，1）单个页面的请求不会包含非常多的依赖，2）基于 HTTP/2，几十个请求不算问题。但是，对于大型项目或巨型项目来说，需要考虑更合适的方案。

```bash
info  - File sizes after gzip:

  144.91 kB           dist/npm.core-js3.22.4.js
  42.91 kB            dist/npm.react-dom18.1.0_react@18.1.0.js
  22.07 kB (+4.4 kB)  dist/umi.js
  8.11 kB             dist/npm.react-router6.3.0_react@18.1.0.js
  7.26 kB             dist/npm.regenerator-runtime0.13.9.js
  6.87 kB             dist/npm.babel+runtime@7.18.9.js
  4.51 kB             dist/npm.history5.3.0.js
  1.15 kB (+573 B)    dist/p__foo.async.js
  1.15 kB (+574 B)    dist/p__index.async.js
  282 B               dist/p__index.chunk.css
  282 B               dist/p__foo.chunk.css
```

### 三、最接近最佳实践的策略

在 2 的基础上，做一些更细致的拆分，目前已被应用到 next.js、gatsby 等大型框架里。他包含一些规则如下，

*   每个 page（路由）一个 chunk
*   新增 framework chunk 包含 react、react-dom、react-router 等不常变更的库
*   新增 lib chunk 包含 node\_modules 下尺寸大于 160kb 的依赖
*   新增 common chunk 包含所有 page（路由）都有用到的 chunk
*   新增 shared chunk 包含被 2 个或以上页面用到的 chunk

这个策略在前面两个策略之间取了一些中间值，同时又能在缓存效率上有更好的利用。以下是示例代码，方便大家更好地理解这个策略。

```ts
{
  default: false,
  vendors: false,
  framework: {
    name: 'framework',
    test: new RegExp(
      `(?<!node_modules.*)[\\\\/]node_modules[\\\\/](${FRAMEWORK_BUNDLES.join(
        `|`,
      )})[\\\\/]`,
    ),
    priority: 40,
    enforce: true,
  },
  commons: {
    name: 'commons',
    minChunks: TOTAL_PAGE_LENGTH,
    priority: 20,
  },
  lib: {
    test(module) {
      return (
        module.size() > 160000 &&
        /node_modules[/\\]/.test(module.identifier())
      );
    },
    name(module) {
      const rawRequest =
        module.rawRequest &&
        module.rawRequest.replace(/^@(\w+)[/\\]/, '$1-');
      if (rawRequest) return `${rawRequest}-lib`;

      const identifier = module.identifier();
      const trimmedIdentifier = /(?:^|[/\\])node_modules[/\\](.*)/.exec(
        identifier,
      );
      const processedIdentifier =
        trimmedIdentifier &&
        trimmedIdentifier[1].replace(/^@(\w+)[/\\]/, '$1-');

      return `${processedIdentifier || identifier}-lib`;
    },
    priority: 30,
    minChunks: 1,
    reuseExistingChunk: true,
  },
  shared: {
    name(module, chunks) {
      const cryptoName = crypto
        .createHash('sha1')
        .update(
          chunks.reduce((acc, chunk) => {
            return acc + chunk.name;
          }, ''),
        )
        .digest('base64')
        .replace(/\//g, '');
      return `shared-${cryptoName}`;
    },
    priority: 10,
    minChunks: 2,
    reuseExistingChunk: true,
  },
},
```

## 最佳实践

Umi/Bigfish 层通过配置 `codeSplitting: {}` 支持不同的策略，包含以上三种。

```ts
export default {
  codeSplitting: {
    jsStrategy: 'bigVendors' | 'depPerChunk' | 'granularChunks',
    jsStrategyOptions: {},
    cssStrategy: 'mergeAll',
    cssStrategyOptions: {},
  },
}
```

推荐无脑选择 `granularChunks`（即策略三），其他策略可以遇到场景时按需配置。

参考：  
[https://yuque.antfin.com/tingzhao.ytz/share/rszvo0](https://yuque.antfin.com/tingzhao.ytz/share/rszvo0)  
[https://yuque.antfin.com/shifeng.gl/bb/et9k8g](https://yuque.antfin.com/shifeng.gl/bb/et9k8g)  
[https://github.com/xn-sakina/xn/blob/08c0fd1278908e8da93e0a0c3f1f6e6de8148598/packages/meta/src/utils/spiltChunk.ts#L6](https://github.com/xn-sakina/xn/blob/08c0fd1278908e8da93e0a0c3f1f6e6de8148598/packages/meta/src/utils/spiltChunk.ts#L6)  
[https://v3.umijs.org/zh-CN/guide/boost-compile-speed](https://v3.umijs.org/zh-CN/guide/boost-compile-speed)  
[https://github.com/vercel/next.js/issues/7631](https://github.com/vercel/next.js/issues/7631)  
[https://github.com/vercel/next.js/blob/2ac7e4c8400a1e73376bddbc194a5df205b4cdd4/packages/next/build/webpack-config.ts#L1398-L1496](https://github.com/vercel/next.js/blob/2ac7e4c8400a1e73376bddbc194a5df205b4cdd4/packages/next/build/webpack-config.ts#L1398-L1496)  
[https://reactjs.org/docs/code-splitting.html](https://reactjs.org/docs/code-splitting.html)  
[https://medium.com/hackernoon/the-100-correct-way-to-split-your-chunks-with-webpack-f8a9df5b7758](https://medium.com/hackernoon/the-100-correct-way-to-split-your-chunks-with-webpack-f8a9df5b7758)  
[https://github.com/bbc/simorgh/pull/7957/files?diff=split&w=0](https://github.com/bbc/simorgh/pull/7957/files?diff=split&w=0)  
[https://github.com/gatsbyjs/gatsby/pull/22253](https://github.com/gatsbyjs/gatsby/pull/22253)  
[https://webpack.js.org/plugins/split-chunks-plugin/#optimizationsplitchunks](https://webpack.js.org/plugins/split-chunks-plugin/#optimizationsplitchunks)
