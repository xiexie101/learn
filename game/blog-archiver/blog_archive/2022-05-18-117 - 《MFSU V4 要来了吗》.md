---
title: "117 - 《MFSU V4 要来了吗》"
date: 2022-05-18
url: https://sorrycc.com/mfsu-v4
---

发布于 2022年5月18日

# 117 - 《MFSU V4 要来了吗》

关于什么是 MFSU，见 [40 - 《比 Vite 还快的 MFSU》](https://sorrycc.com/mfsu-and-vite) 。

MFSU V3 有什么问题？其实从 MFSU 从 V1 到 V3，都是先做项目构建，构建过程中通过 babel 插件分析出有哪些依赖需要走 MF 预编译，然后再做依赖的预编译。这么做的好处是能找到 100% 的所有依赖，覆盖率很高。缺点也很明显，就是串行，尤其是项目源码本身文件多编译慢的场景下，带来的问题会更显著。

项目代码构建 -> 拿到依赖数据 -> 依赖预编译

这个问题会在 MFSU V4 去解，解法是提前做「源码分析」，拿到依赖数据，然后根据此数据并行地去做「项目代码构建」和「依赖预编译」。项目代码构建时根据依赖数据决定哪些要走 MF 的 Remote 加载；依赖预编译直接拿依赖数据去做全量编译，产物供项目代码去加载使用。

源码分析 -> 项目代码构建  
         -> 依赖预编译

实现方式比较简单，用 fast-glob 找到所有 js 类文件，拼成一个大文件，然后用 esbuild + es-module-lexer 去分析 import 信息即可。当然也会通过 watch 去做增量的更新和分析。unocss 也有相似实现， [https://github.com/unocss/unocss/blob/a6a378a/packages/cli/src/index.ts#L57-L62](https://github.com/unocss/unocss/blob/a6a378a/packages/cli/src/index.ts#L57-L62) 。

这个方案中有个纠结了很久的点是，「源码分析」出于性能考虑我们不会做 babel 编译，所以拿到的结果会和真实构建后的结构不同。这时有两个选择，1）项目构建之后做依赖数据的补充，但这会让整个方案变得复杂，需要加入 module graph，同时考虑 babel、mfsu 和 webpack 的物理缓存导致的问题，2）项目构建之后不做依赖数据的补充，框架层减少对 babel 插件的使用，同时尽量把遇到的 babel 插件导致的依赖遗漏提前考虑进去，然后再有漏网之鱼就走项目编译，会慢一点点，但整体方案非常简单。

我们的选择是后者。现在越来越倾向选择简单的方案，如果一个方案做着做着变复杂了，会停下来仔细想，因为方案复杂通常是因为自己没有彻底理清楚，然后到处打补丁导致的。多出「本质解」而不是「现象解」。

期待 MFSU V4，尤其对于源码量级大的项目效果更明显。同时，我觉得「有迭代的技术才有生命力」，MFSU 从 V1 做到 V4，一致能找到新的技术点作为补充，同时未来还有更多想法，这个技术点又能解实际的问题，就非常有生命力，一点都不担心他会做死掉。
