---
title: "413 - 《读书笔记：A Philosophy of Software Design》"
date: 2024-02-18
url: https://sorrycc.com/book-a-philosophy-of-software-design
---

发布于 2024年2月18日

# 413 - 《读书笔记：A Philosophy of Software Design》

![](https://img.alicdn.com/imgextra/i4/O1CN01bsq0vu1J53UDxrvx3_!!6000000000976-2-tps-830-1049.png)

推荐一本 2018 年的书[《A Philosophy of Software Design》](https://book.douban.com/subject/30218046/)，豆瓣评分 9.2，告诉你如何做更好的设计，写更好的代码。年前翻完的，收获挺大，推荐精读。我用 ChatGPT 4 Turbo 翻译了一版中英对照的，也可以看社区同学两年前翻译的版本，[https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh](https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh) 。

以下是笔记。

1、编写软件时，随着时间的推移，复杂性逐渐累积，程序员在修改系统时越来越难以将所有相关因素保持在脑海中。这减慢了开发速度，导致了错误，这些错误进一步减慢了开发速度并增加了成本。（开发 Umi 时其实还好，在开发 Mako 时就深有体会了，因为构建工具涉及的面太广，很难凭记忆把事情全记到脑子里，我们的做法是写详细的 RFC，忘记了就回头去看 RFC 回顾下）。这本书讨论的就是如何应对复杂性，通常有两种方法，1）简化代码使之更明了，2）封装代码让我们不一次性暴露所有复杂性。（对于前端来说，npm 包、组件库等都属于后者）

2、项目开发方式典型的有几种，1）瀑布模型，2）敏捷模型。瀑布模型在每个阶段完成后才开始下一个阶段，整个系统在设计阶段一次性设计完成；敏捷模型初始设计专注于整体功能的一小部分，这一部分被设计、实现，然后进行评估，然后每次迭代都会暴露出现有设计的问题，在设计下一批功能之前进行修复。（显然，后者是更适合大型软件开发的，项目大了之后根本不可能一次性设计清楚。）

3、复杂性是什么？复杂性是指与软件系统的结构相关的任何事物，这些事物使得理解和修改系统变得困难。复杂性有多种形式，比如，1）很难理解一段代码的工作原理，2）实现一个小改进可能需要大量努力，或者可能不清楚需要修改系统的哪些部分才能做出改进，3）修复一个错误而不引入另一个错误是困难的。所以，如果一个软件系统难以理解和修改，那么它就是复杂的，反之就是简单的。此外，复杂度还分人，自己能轻松工作还不够，得让其他人也能轻松工作。

4、怎么识别复杂性？复杂性有三种表现，1）变更放大，一个看似简单的变更需要在许多不同的地方修改代码，（比如每年需要更新的 copyright 年份，你的项目是改 N 份、1 份还是自动更新？），2）认知负荷，指的是开发者为了完成一个任务需要知道多少信息（代码行数多少不能代表复杂性，有时候更多的代码反而更容易理解，比如 eslint 有个规则是 [no-nested-ternary](https://eslint.org/docs/latest/rules/no-nested-ternary)，嵌套的三元表达式通常代码少但难以理解），3）未知的未知数，开发者不清楚需要修改哪些代码片段才能完成任务，或者不清楚需要掌握哪些信息才能完成任务，（这是最麻烦的，你不清楚你不知道什么，直到变更之后，bug 出现了，你才会发现他）。

5、为啥会有复杂性？两个原因，1）依赖性，当给定的代码片段不能被孤立地理解和修改时，就存在依赖性，2）晦涩性，到当重要信息不明显时，就会导致晦涩，比如太通用变量名 time、同一个变量两个含义的不一致性、文档不充分等。依赖性导致变更放大和高认知负荷。晦涩性造成未知的未知，并且也增加了认知负荷。

6、复杂性是递增的。复杂性之所以产生，是因为成百上千的小依赖和不明确性随着时间的推移而积累起来。最终，这些小问题如此之多，以至于系统的每一个可能的变更都会受到其中几个问题的影响。你很容易说服自己，当前变更引入的一点点复杂性没什么大不了的。然而，如果每个开发者都对每次变更采取这种态度，复杂性就会迅速积累。一旦复杂性积累起来，就很难消除，因为单独修复一个依赖关系或不明确性本身不会产生太大的影响。为了减缓复杂性的增长，你必须采纳“零容忍”哲学。

7、编程心态有两种，战术编程和战略编程。1）战术编程是能用就行，其目标是让东西跑起来，其缺点是会导致复杂性迅速累积，特别是当每个人都在进行战术性编程时。团队中通常都会有一些「战术龙卷风队员」，他们的代码输出速度远超他人，能快速实现一个功能，一些组织会视他们为英雄，然而，龙卷风过后是一片破坏的结果。2）战略编程是意识到仅有可工作的代码是不够的，为了更快完成当前任务而引入不必要的复杂性是不可接受的，其目标是产出好的设计，而这个设计恰好也能工作。（用哪种心态编程应该也需要 by scene，脚本类的、营销类的、生命周期短的、创业类的，用战术编程可能更合适。）

![](https://img.alicdn.com/imgextra/i4/O1CN01RcNaBr1qTDhWD7i3z_!!6000000005496-2-tps-1292-776.png)

🚩 注意「战术编程」。

8、模块化设计和深度模块。模块化设计让开发者在任何给定时间只需要面对整体复杂性的一小部分。一些注意点，1）模块分为两部分：接口和实现，开发者不应该需要理解他或她正在工作的模块之外的其他模块的实现，2）最好的模块是那些接口比实现简单得多的模块，3）抽象是对实体的简化视图，省略了不重要的细节，他让我们更容易思考和操作复杂的事物，抽象过程中，「不重要」是关键，从抽象中省略的不重要细节越多越好（现实生活中也有很多抽象的例子，比如微波炉、汽车等都是简单的抽象），4）最好的模块是那些提供强大功能但又拥有简单接口的深度模块，模块的成本是其接口，接口越小且越简单，引入的复杂性就越少。

![](https://img.alicdn.com/imgextra/i2/O1CN01rO8Xzh1Z8I8NKluT3_!!6000000003149-2-tps-251-159.png)

🚩 注意「浅层模块」。拆大量的类和「任何超过 N 行的方法都应该被分解成多个方法」这种思路会导致大量的浅层类和方法，增加了整个系统的复杂性。

9、信息隐藏。实现深层模块的最重要技术是信息隐藏。在设计一个新模块时，你应该仔细考虑哪些信息可以隐藏在该模块中。如果你能隐藏更多信息，你也应该能够简化模块的接口，这会使得模块更加深入。

🚩 注意「信息泄露」。如果新类通过其接口暴露了大部分知识，那么它不会提供太多价值。

🚩 注意「时间分解」。时间分解中，系统的结构对应于操作发生的时间顺序。考虑一个应用程序，它读取特定格式的文件，修改文件内容，然后再次写出文件。采用时间分解，这个应用程序可能会被分解成三个类：一个用来读取文件，另一个用来执行修改，第三个用来写出新版本。结果是，时间分解往往导致信息泄露。在设计模块时，关注执行每个任务所需的知识，而不是任务发生的顺序。

🚩 注意「过度曝光」。如果一个常用功能的 API 强迫用户去了解那些很少使用的其他功能，这会增加那些不需要这些很少用功能的用户的认知负担。（比如默认值设置不当会导致这个问题，比如发 http 请求时每次都要设置协议版本，或者比如配置 webpack 时每次都要配置拆包策略）。

10、通用模块往往更深入。在设计新模块时，通常会面临一个选择，是用通用方式实现，还是用特殊方式实现。在作者的经验里，最佳实践是以某种通用方式实现新模块。「某种通用」的意思是模块的功能应该反映你当前的需求，但其接口应足够通用，以支持多种用途。接口应该易于满足今天的需求，而不是特定地与它们绑定。（比如设计一个编辑器时，实现 changePosition + insert + delete 会比实现特定的 backspace、deleteSelection 要更通用）。

一些可以让你的模块更通用的问题，1）能满足我目前的所有需求的最简接口是什么？如果你减少了 API 中的方法数量，而没有减少它的整体功能，那么你可能正在创建更通用的方法。（注：如果你为了减少方法数量而不得不引入许多额外的参数，那么你可能并没有真正简化事情。）2）这个方法会在多少种情况下使用？如果方法是为某个特定用途设计的，比如 backspace 方法，那它可能太特殊化了，看看是否能用通用方法来代替，3）这个 API 对我当前的需求来说使用起来容易吗？这个问题可以帮助你确定何时你在使 API 简单化和通用化方面做得过头了。

11、透传方法和透传变量。软件系统由多层组成，高层使用低层提供的设施。1）透传方法。当相邻层具有相似的抽象时，问题通常以穿透方法的形式表现出来，透传方法是指除了调用另一个方法外几乎不做任何事情的方法，这个方法的签名与调用方法的签名相似或完全相同。解法是重构类，比如把底层类暴露给高层并从高层里删除此功能，比如重新分配功能，比如合并他们。2）透传变量增加了复杂性，因为它们迫使所有中间方法都必须知道它们的存在，即使这些方法对变量没有用处，此外，如果有新变量出现，你可能需要修改大量的接口和方法，以便通过所有相关路径传递该变量。作者的常用解法是引入上下文对象，上下文存储应用的所有全局状态。

![](https://img.alicdn.com/imgextra/i1/O1CN01KQgEYN1qFTozTvJ94_!!6000000005466-2-tps-330-193.png)

🚩 注意「透传方法」。

12、在开发模块时，寻找机会在自己身上多承担一点苦楚，以减轻用户的苦楚。开发模块时，如果遇到不可避免的复杂性，这时有两个选择，1）交给模块的用户处理，2）在模块内部处理。前者短期会让你的生活更轻松，但他会增加复杂性，导致许多人不得不处理这个问题，而不是一个人。例如，如果一个类抛出一个异常，那么这个类的每个调用者都必须处理它。如果一个类导出配置参数，那么每个安装中的每个系统管理员都必须学习如何设置它们。所以，通常后者是正确的。

配置参数应尽可能避免。在导出配置参数之前，问问自己：“用户（或更高级别的模块）能否确定比我们在这里能确定的更好的值？”当你确实需要创建配置参数时，看看是否可以自动计算出合理的默认值，这样用户只在特殊情况下才需要提供值。理想情况下，每个模块都应完全解决一个问题；配置参数会导致不完整的解决方案，增加了系统的复杂性。

13、在一起还是分开？一个最基本的问题是：给定两个功能，它们应该在同一个地方实现，还是应该分开？这个问题适用于系统的所有层次，如函数、方法、类和服务。一些原则，1）如果信息是共享的，合在一起，2）如果可以简化接口，合在一起，3）如果可以减少重复，合在一起，4）通用代码和专用代码应分开。

方法的拆分和合并不能单纯以长度为理由。1）长方法并不总是不好的，2）设计方法时，最重要的目标是提供清晰简单的抽象，每个方法应该只做一件事，并且做到完整，3）方法应该有清晰简单的接口，并且应该是深入的。

![](https://img.alicdn.com/imgextra/i4/O1CN01fdoblK1kNpLTIdbWX_!!6000000004672-2-tps-508-146.png)

🚩 注意「重复」。消除重复有两个方法，1）将重复的代码提取到一个单独的方法中，并用对该方法的调用来替换重复的代码片段，2）重构代码，使得相关代码片段只需在一个地方执行。

🚩 注意「通用特殊混合」。当通用代码里包含了特定用途的专用代码时，会变得复杂，并造成信息泄露，未来对用例的修改很可能也需要对底层机制进行更改。

🚩 注意「连体方法」。如果你发现拆分方法后，需要在父方法和子方法之间来回翻阅才能理解它们是如何协同工作的，那就是连体方法，这么做没啥好处，反而会增加复杂性。

14、异常处理。当异常发生时，有两种处理方式，1）继续前进，尽管有异常也要完成工作（比如网络失败了重新发送，比如数据损坏了从副本里恢复），2）中止操作，并向上报告异常，中止可能很复杂，因为异常可能发生在状态不一致的地方（比如数据结构初始化了一部分），就需要恢复一致性，比如回滚异常发生前所做的变更。

异常处理是复杂的。1）异常处理代码会创造更多异常的机会，2）有些异常在测试环境中不容易产生，因为有些逻辑走不到，「未执行的代码不会工作」，3）有些程序员会定义不必要的异常，异常检测并不是越多越好，过度防御也会增加系统复杂性。

抛出异常很简单；处理它们却很困难。消除异常有几种方法，1）最佳方式是定义你的 API，使其没有异常需要处理：定义错误直至不存在，参考下面 Unix 设计文件删除的例子，2）异常掩盖，低层会检测并处理异常，这样高层就不需要知道这个情况，这在分布式系统中尤其常见，3）异常聚合，用一段代码处理多个异常，异常在堆栈中向上传播几个级别后再被处理时效果最佳（感觉这在前端里是最常见的），4）让应用崩溃，有些不值得尝试去处理，他们通常难以或无法处理，并且不经常发生（比如内存耗尽错误 OOM）。

示例：Unix 操作系统更优雅地定义了文件删除。在 Unix 中，如果文件在删除时处于打开状态，Unix 不会立即删除该文件。相反，它会将文件标记为删除，然后删除操作成功返回。文件名已从其目录中移除，因此没有其他进程可以打开旧文件，可以创建同名的新文件，但现有文件数据仍然存在。已经打开该文件的进程可以继续正常读写。一旦所有访问进程都关闭了该文件，其数据就会被释放。

15、设计两次。设计软件是困难的，因此你对如何构建模块或系统的首次想法不太可能产生最佳设计。如果你对每个重要设计决策考虑多个选项，最终得到的结果会好得多。尝试选择彼此截然不同的方法；这样你会学到更多。在你为各种方案草拟出设计后，列出每个方案的优缺点。一旦你比较了不同的设计方案，你就能更好地确定最佳设计。最好的选择可能是这些方案中的一个，或者你可能发现可以将多个方案的特点结合起来，创造出一个比任何原始选择都要好的新设计。

16、注释。1）注释应描述代码中不明显的点，「不明显」是从第一次阅读你代码的人的角度来看的（不是你自己），2）注释不要复述代码，3）low-level 注释可以提升精确性，比如变量的单位是什么、这里允许空值意味着什么、边界条件是包含性还是排他性的等，4）high-level 注释可以提升视野，他们省略了细节，帮助读者理解代码的总体意图和结构，通常用于方法内部注释和接口注释。

🚩 注意「复述代码的注释」。如果注释中的信息从旁边的代码已经很明显了，那么这个注释就没有帮助。

17、命名。1）培养命名技能是一种投资，当你决定不再满足平庸的名称时，前期可能会沮丧又耗时，后期则会变得容易，2）好的命名是精确的，比如 blinkaStatus: boolean 是模糊的，而 cursorVisible 是精确的，布尔值通常是谓语（React 最近把 OffScreen 改成 Activity 就是为了精确性，因为 OffScreen 代表的「不可见」不能反应某些场景下的含义），3）好的命名是一致的，4）变量声明与其使用之间的距离越远，变量的名称就应该越长，见 [What’s in a name?](https://go.dev/talks/2014/names.slide#1)。

🚩 注意「模糊的命名」。如果一个变量或方法名称足够宽泛，以至于可以指代许多不同的事物，那么它向开发者传达的信息就不多，而且底层实体更容易被误用。

🚩 注意「难以挑选名称」。如果很难为一个变量或方法找到一个简单的名称来清晰地描述底层对象，那可能暗示着底层对象的设计可能不够清晰。

18、注释优先。编写注释的最佳时机是在编码开始的时候，先写注释会让文档成为设计过程的一部分，不仅会有更好的文档，也会有更好的设计。

19、修改现有代码。1）保持战略性，修改代码的典型心态是「能满足我的需求的最小改动是什么？」，他们由于对代码不够熟悉，担心较大的改动会引入新错误，从而导致了战术编程，2）维护注释，修改代码时忘记更新注释是很容易的，3）注释应写在代码里，而不是提交日志里（也可以写在 RFC 里）。

20、代码应是直观的。1）直观的代码需要更少注释，2）通过代码 Review 可以确定直观性，直观性对相对于读者而言的，不是自己看是否直观，3）好的名称、一致性、谨慎使用空白和空行、注释读可以增加代码的直观性，4）事件驱动编程会使控制流的跟踪变得困难，从而导致不直观（插件驱动也是），5）泛型容器会导致不直观。

🚩 注意「不直观的代码」。如果代码的含义和行为不能通过快速阅读就能理解，这是一个警示。这通常意味着有重要信息对阅读代码的人来说不是立刻就能清楚的。

21、性能。1）简单性可以在不牺牲清晰设计的情况下实现高性能，既要设计，又要性能，清晰的设计和高性能设计兼容的，复杂的代码则往往运行缓慢，因为他们做了额外或重复的工作，2）很多所谓的优化实际上并不会提升性能，所以不要试图优化每一条语句，这会减慢开发速度并创造不必要的复杂性，3）通常相对昂贵的操作有网络通信、二级存储的 I/O、动态内存分配、缓存未命中等，4）了解哪些操作开销大的最佳方式是运行微基准测试（[webpack 的 benchmark](https://github.com/webpack/benchmark) 就很细），5）如果提效的唯一方法是增加复杂性，尽量将其隐藏起来，并不要影响任何接口，6）修改之前要做 benchmark，同时 benchmark 不止要做顶级的，还要做细节的，除了确保修改的有效性，还能识别出性能痛点，7）定位出问题代码之后，可以做根本性的改变，方法是先确定最小代码量，再寻找一个理想的新设计。

参考：  
[A Philosophy of Software Design | John Ousterhout | Talks at Google - YouTube](https://www.youtube.com/watch?v=bmSAYlu0NcY)  
[A Philosophy of Software Design (豆瓣)](https://book.douban.com/subject/30218046/)  
[What’s in a name?](https://go.dev/talks/2014/names.slide#1)
