---
title: "112 - 《手撕源码 07：unplugin》"
date: 2022-05-11
url: https://sorrycc.com/source-07-unplugin
---

发布于 2022年5月11日

# 112 - 《手撕源码 07：unplugin》

为什么看 unplugin？umi 内置了 vite 和 webpack 两种构建方式，未来还可能支持纯 esbuild 和 esmi 等方案。要实现构建相关的能力，就需要针对多种方式分别实现，开发和维护成本都较高。当然如果是编译类的需求，也可以用 babel 插件实现一次开发，但是 1）未来 Umi 会考虑需要去 babel 化，2）部分需求不是编译类的。

unplugin 是 antfu 开发维护的，用于为不同构建工具提供统一的插件编写方式，目前支持 rollup、vite、webpack 和 esbuild。Star 1.2K，周下载 129K，Nuxt 3 和 ICE 3 都对此有依赖。

工程化部分。用 [version-bump-prompt](https://github.com/JS-DevTools/version-bump-prompt)（bump）发版，用 [tsup](https://github.com/egoist/tsup) 做源码编译，产物是 mjs + js 格式。

基本实现思路。unplugin 提供 createUnplugin 方法，传入 rollup 的插件写法，unplugin 内部会返回不同构建工具的 transform 方法，转换成适应各自构建工具的插件。其中 rollup 和 vite（vite 基于 rollup）基本不用怎么转，转换代码主要是处理 esbuild 和 webpack 的。

以 webpack 为例。

```ts
// 定义插件
const plugin = createUnplugin((opts, meta) => {
  return { name, transform, transformInclude };
});
// 使用插件
webpackConfig.plugins.push(plugin.webpack());
// 内部实现
function createUnplugin(fn) {
  return {
    get webpack() { return getWebpackPlugin(fn) },
    ...
  }
}
// webpack 插件的 transform 实现
function getWebpackPlugin(fn) {
  return (userOpts) => {
    return {
      apply() {
        const rawPlugin = factory(userOpts, meta);
      }
    };
  };
}
```

webpack 如何转换 transform 和 transformInclude 配置？

1、插件中通过 `compiler.options.moudle.loader` 可访问到 loader 配置  
2、通过 `compiler.$unpluginContext` 把插件内容传到 loader 中，然后 loader 中可通过 `this._compiler?.$unpluginContext` 访问到  
3、通过 `transformInclude` 过滤文件，然后 loader 中通过 `this._compiler?.$unpluginContext[name].transform` 做代码编译

webpack 如何转换 resolveId 配置？背后是实现了一个 resolver 插件，在 compiler.options.resolve.plugins 里添加。而如果 resolve 的文件不存在，会被当成虚拟文件处理。但有一点文档里没提的是，webpack 的 resolveId 只有 source 一个参数，而 rollup 是 source、importer 和 options 三个参数的。

参考：  
[https://github.com/unjs/unplugin](https://github.com/unjs/unplugin)
