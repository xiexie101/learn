---
title: "231 - 《React Query 笔记：下》"
date: 2022-12-17
url: https://sorrycc.com/react-query-note-02
---

发布于 2022年12月17日

# 231 - 《React Query 笔记：下》

总算看完了 [https://tkdodo.eu/blog/practical-react-query](https://tkdodo.eu/blog/practical-react-query) 系列剩下的第 9 到 18 篇，花的时间比预计的长。对 RQ 路转粉，学习到不少关于请求的细节处理思路，推荐大家都好好读一读。

1、RQ 预填充缓存数据有两种方法：placeholderData 和 initialData。相同的是，1）都会直接跳过 loading 状态进入 success 状态，2）都支持值或者返回值的函数两种类型。不同的是，1）initialData 在缓存层处理，直接放入缓存，尊重 staleTime，一个 query key 只能由一个 initialData，refetch 错误时数据还在，2）placeholderData 在观察者层处理，不放入缓存，用于临时占位，可以为相同的 query key 创建多个不同的 placeholderData，refetch 错误时数据消失。

2、RQ 是啥？他不是请求库，因为不内置 axios、fetch 之类的；他是异步的状态管理器，或者是服务端状态的同步工具。在 RN 之前，通常有两种数据获取的方法，1）一次获取、全局分发、很少更新，2）每次获取（比如每次 modal 打开时都请求一遍数据）。这两种都不太好，前者更新太少，后者更新太多。RN 通过 Stale While Revalidate 和机制的 refetch 机制来解这个问题。refetch 触发时机包括 refetchOnMount、refetchOnWindowFocus、refetchOnReconnect，以及手动的 queryClient.invalidateQueries。同时可针对不同场景设置不同的 staleTime 来控制 refetch 频率。

3、RQ 处理错误有 3 种方法。1）useQuery 返回值的 isError 或 status === ‘error’ 判断，2）onError 回调，可以是 query 级，也可以是全局用 queryCache 配，query 级的要当心避免多次触发，3）基于 Error Boundary，配置 useErrorBoundary:true 即可。三种方法可以搭配使用，作者建议针对 refetch 错误用全局 onError + toast 显示，其他的用 1 或 3 的方法处理。另外，如果有 fetch，要在 queryFn 里处理 4xx 和 5xx 请求，他不像 axios 一样会 reject。

4、RQ 通过 useMutation 实现突变（更新数据）。和 useQuery 相同的是都会提供 loading、error、status 数据，也支持 onSuccess、onError 和 onSettled 回调。和 useQuery 不同的是，useQuery 是声明式，而 useMutation 是命令式，同时 useMutation 也不会共享状态。突变后要更新数据有三种思路，1）invalidate query 让他 refetch，注意只有活跃的 query 会 refetch，2）通过 queryClient.setQueryData 直接更新，适用于知道全部数据的场景，但可能不安全，比如遇到排序、新增后新 id 数据时会变得很复杂，3）乐观更新，适用于小交互。一些常见问题，1）onSuccess 回调支持 Promise，适用于比如你需要在 invalidate 操作完成前保持 useMutation 的 loading 状态时，2）useMutation 有 mutate 和 mutateAsync 两个方法，通常更推荐 mutate，因为 mutateAsync 要自行 try…catch 处理异常场景，mutateAsync 的场景是有多个并行或串行依赖性突变时，3）useMutation fn 只支持一个参数，可以用 Object，4）useMutation 和 mutation 都有回调，前者肯定会执行，适用于逻辑，后者组件销毁后不执行，适用于 UI。

5、关于离线。1）有一个 networkMode 设置，可以选择三种模式，online（默认模式，假设有网络时才能用，没网络会进入暂停状态）、always（不关心网络状态，永远会启用查询，适用于数据获取以外的事）、offlineFirst（总是会发出第一个请求，失败时进入暂停状态），2）useQuery() 会返回 fetchStatus，包括 fetching、paused、idle 三种状态，可以和 status 结合使用，两者不互斥。

6、关于表单。1）作者推荐了 [react-hook-form](https://react-hook-form.com/) 和 RN 搭配使用，2）最简方案是 useQuery 请求数据作为默认值然后 useMutation 突变更新，但存在两个问题，data 可能为空和没有后台更新，data 可能为空壳通过提取组件的方式解，没有后台更新可通过受控组件+优先用受控组件的值的方式解，3）防止重复提交可基于 useMutation() 返回的 isLoading，给提交按钮加 disabled={isLoading} 来解，4）如果提交后没有跳转到其他页面，通常需要在 mutate 之后 invalidate query（更新数据）并 reset 表单。

7、FAQ。1）如何给 refetch 传递参数？不能传递。2）如何做同一个 useQuery 但 key 变更时的过渡？用 placeholderData 或者配置 keepPreviousData: true 保留之前的数据，3）为啥没有更新？query key 不匹配（比如 1 和 ‘1’ 是不一致的），或者 query client 引用不稳定（比如在 App 里创建的由于 re-render 或路由变更会导致引用不一致），4）为啥要用 useQueryClient 而不是 import+export 的方式引用 queryClient？因为更准确（比如多 query client 的场景），5）为啥请求失败而没有收到错误信息？因为 queryFn 没有返回 reject 的 Promise（比如用 fetch 时需在 res.ok 不 ok 时主动抛个错）。

8、RQ 和 React Router（简称 RR）6.4 的关系。1）[RR 没有做 cache](https://twitter.com/ryanflorence/status/1561731634419773447) 而 RQ 有，RR 是关于 when（时机）而 RQ 是关于 what（具体请求方案），2）只有 RR 可以做到提前获取，但问题是由于没有缓存从而会到请求过于频繁，3）RQ 和 RR 可结合使用，在 loader 里通过 queryClient.fetchQuery 发起请求，组件里用 useQuery 正常拿数据即可，出于 ts 类型考虑默认值可以填 useLoaderData 的数据，4）如果用 RR 的 action 做突变，redirect 之前记得 invalidate 相关的 query，同时 invalidate 可以根据场景选择是否 await。

9、关于请求瀑布流。1）[依赖类 query](https://tanstack.com/query/v4/docs/guides/dependent-queries) 的瀑布流是避免不了的，比如 /user/1/project 依赖 /user 的数据，非依赖的写多个 useQuery 或者用 useQueries 解效果相同，2）Suspense 会在 Promise 为 pending 状态时用 fallback 渲染，缺点是 fallback 时间过长从而影响渲染，渲染迟了进而影响子组件的数据请求，从而导致瀑布流，3）queryClient.prefetchQuery 可以缓解这个问题，一种用法是放在组件外，可以在代码下载解析时即执行，4）useQueries 暂不支持 suspense，5）如果列表页包含详情页的所有数据，可以用列表页缓存的数据填充详情页缓存，这里也分拉和推两种方式。
