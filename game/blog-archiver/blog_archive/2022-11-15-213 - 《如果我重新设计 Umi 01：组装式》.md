---
title: "213 - 《如果我重新设计 Umi 01：组装式》"
date: 2022-11-15
url: https://sorrycc.com/if-redesign-umi-01
---

发布于 2022年11月15日

# 213 - 《如果我重新设计 Umi 01：组装式》

> 框架当如呼吸，轻巧无痕，用完就走。

1、相比组装式，与其对应的集中式大家应该更熟悉，Umi 和 Next.js 都是这种。这种方式下不给入口，按照约定把用户在 src/pages、src/app.ts 等文件拼成入口文件，写在临时目录里，然后交给 webpack 或 vite 编译。集中式的好处是收口，对哪里能改哪里不能改有明确定义，所以项目一致性会更好。但这个好处也是坏处，普通开发者会不知道项目是如何组织的，会给人感觉比较黑盒。

2、收了口子后，定制的需求是不会变的，应该如何处理？集中式通常会有插件体系，然后挖一些口子。比如 umi 的运行时插件有 render 和 rootContainer 等扩展口子让开发者扩展定制。除了黑盒，这种方式还有个不好的地方是类型提示不友好，比如框架没有办法知道插件里扩展了啥，修改了 render 的啥参数，或者通过 rootContainer 增加了啥 Provider，就没法做自动的类型提示。

3、组装式是啥？我理解是让框架更多向库的定位上靠，专注于提供功能，开放入口，让用户像搭积木一样搭出应用。这样子，每个部分就都是可替换可插拔的，比如不想要内置的约定式路由，自己写一个进去就好。对于开发者来说，对应用会有更多的掌控力，遇到问题绕不过大不了把这部分换掉就好。先看 client 端的例子，其中 mount 方式、Head、路由和约定式路由的组装方式均可替换，甚至可以完全不用 umi 提供的运行时能力。

目录。

```bash
+ src
  - entry-client.tsx
  - root.tsx
```

src/entry-client.tsx。

```ts
import { mount, EntryClient } from 'umi/entry-client';
mount(EntryClient, document);
```

src/root.tsx。

```ts
import { Head, Routes, FileRoutes } from 'umi';
export default function() {
  return (
    <html>
      <Head />
      <body>
        <Routes>
          <FileRoutes />
        </Routes>
      </body>
    </html>
  );
}
```

4、构建配置也可以组装式。比如 webpack，可以在框架层提供原子化的 webpack 能力，同时开放入口，让开发者在 config/webpack.config.ts 里进行组装搭配，然后像 mfsu 这样修改修改多处的提供 compose 方法进行整体扩展。其他构建类的工具以此类推，比如 jest、postcss、babel 等都可按照这种方法做。

config/webpack.config.ts。

```ts
import { base, plugins } from 'umi/webpack';
import { composeWebpackConfig } from '@umijs/mfsu';
export default composeWebpackConfig([
  {
    ...base,
    plugins: { ...plugins, yourPlugin },
  }
]);
```

5、扩展也可以组装式。如果有用过 zustand 和 valtio，在扩展方面，前者用 middleware，后者用 compose，你会发现后者 valtio 天生对类型友好，可以做类型推断。但扩展分运行时和编译时，编译时有构建、配置、路由、devServer、命令行等很多维度的扩展，组装式并不适用于所有场景。要不要扩展以及选择哪种扩展方式我还没想好，等想好了单独开一篇来讲吧。
