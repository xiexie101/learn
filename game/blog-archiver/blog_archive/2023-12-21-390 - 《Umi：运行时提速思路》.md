---
title: "390 - 《Umi：运行时提速思路》"
date: 2023-12-21
url: https://sorrycc.com/umi-runtime-perf
---

发布于 2023年12月21日

# 390 - 《Umi：运行时提速思路》

> 下午和同事 @PeachScript 脑暴想到的，记录下。

先说问题。

```
+ layout
	+ a
		+ a_1
	+ b
```

比如上面的路由结构，现在 Umi 的实现里，layout、a、b 和 a\_1 路由对应的 js 文件都是通过 `import()` 做 code splitting 和按需加载的，所以理论上用户访问 /a/a\_1 url 时的瀑布流如下。

```
/umi.js
    /layout.js
        /a.js
            /a_1.js
```

串行瀑布流肯定是很慢的，尤其当嵌套路由里还有额外请求时，还需要等请求完成后才会加载嵌套的路由。

和 @PeachScript 一起脑暴了一些方案。

1、全部不用 `import()`，产物合成为一个 umi.js 文件  
2、部分不用 `import()`，比如 layout 部分不用，这样 layout 会合到入口的 umi.js 里  
3、在入口文件里加一段逻辑，内置 route map 和 chunk map，然后基于 url 分析出需要加载的 chunk 文件列表，并对这些 chunk 文件做预加载

这些方案里。1 肯定不合适，因为整体产物会变大，这样不管访问哪个路由都需要加载全部 JS 文件，可能比现在的串行瀑布流快，但肯定不是最佳选择；2 只能解一部分问题，不能解非 layout 的嵌套路由的瀑布流问题；3 是目前我们能想到的最佳方案。

理论上 3 完成后，瀑布流应该是这样。

```
/umi.js
    /layout.js
    /a.js
    /a_1.js
```

看着好像不是最佳的？最佳的不应该是下面这样吗？

```
/umi.js
/layout.js
/a.js
/a_1.js
```

没错，我们可以在方案 3 的基础上继续优化，把增加的逻辑提取成 script 放到 head scripts 里执行，就能达到这个瀑布流的效果了。

注：目前还只是想法，具体的 RFC 会由 @PeachScript 来出。
