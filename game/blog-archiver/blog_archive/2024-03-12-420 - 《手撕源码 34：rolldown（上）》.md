---
title: "420 - 《手撕源码 34：rolldown（上）》"
date: 2024-03-12
url: https://sorrycc.com/source-34-rolldown-01
---

发布于 2024年3月12日

# 420 - 《手撕源码 34：rolldown（上）》

> rolldown 刚出，翻下代码。个人感觉一个库刚写出来时是看他的最好时机，因为没考虑那么多的边界场景，复杂度相对较小，看起来轻松。

1、目录结构和代码流。

重要的包的目录结构如下。

```bash
+ crates
	+ rolldown
	+ rolldown_binding (@rolldown/node-binding)
	+ ...
+ packages
	+ node (@rolldown/node)
	+ ...
```

如果从 JS 入口开始看，代码的调用路径是 packages/node > crates/rolldown\_binding > crates/rolldown 。

packages/node 提供 `rolldown` 和 `experimental_scan` 两个方法。前者会调 rolldown\_binding 的 `write` 方法；后者会调 rolldown\_binding 的 `scan` 方法，盲猜之后会结合插件给 vite 做依赖 scan 使用。

crates/rolldown\_binding 是基于 napi 对 crates/rolldown 的接口封装，提供了 `scan`、`write` 和 `generate` 方法，用 Mutex 加锁以避免被同时调用。同时 plugins 配置会被转成 JsAdapterPlugin。

2、rolldown crate 的整体设计。

看下来感觉整体思路应该是参考着 rollup 做的，上次看 rollup 代码已是很久以前，[181 - 《手撕源码 25：Rollup 3 上》](https://sorrycc.com/source-25-rollup-3-01)，忘差不多了。

主入口在 crates/rolldown/src/bundler.rs 的 bundle\_up 方法，构建分三个 stage，分别是 scan、link 和 bundle。后一个 stage 基于上一个 stage 的输出作为输入，很好理解整体的逻辑。

scan stage 会找到所有模块。基于 ModuleLoader 实现，利用 tokio + XXXModuleTask 做并发提速（why tokio 而不是 rayon？有啥特殊考虑？），输出 `{module_table,ast_table,symbols,…}`。实现从 runtime 和 entry 开始 load 模块，依次做 `load_source`（加载源码）、`transform_source`（主要给插件用）、`scan`（code to ast）、`resolve_dependencies`。

link stage 会在模块之间建立关联，数据结构上会在 scan 的基础上额外输出 `sorted_modules` 和 `metas` 信息，后者包含 link 相关的额外信息，比如应该怎么被 wrap、是否用 dynamic exports 等。做的事情包括 sort\_modules（给模块深度优先排序）、determine\_module\_exports\_kind、wrap\_modules（不改 ast，只在 linking\_info 上加信息）、bind\_imports\_and\_exports、create\_exports\_for\_modules、reference\_needed\_symbols、include\_statements（tree\_shaking.rs 模块提供），还没有细看每一步的实现。

bundle stage 会给模块分 chunk 并输出为合并后的代码。做了 generate\_chunks（code splitting）、generate\_chunk\_filenames、compute\_cross\_chunk\_links、对 chunks 做 de\_conflict（par\_bridge）、对 ast\_table 做 finalize\_normal\_module（par\_bridge，对 ast 做最后的修剪）、对 chunks 做 render（ast to code）、render\_chunks。

3、性能。

针对非 wasm target 启用 mimalloc 作为内存分配器。

```rust
#[global_allocator]
static ALLOC = mimalloc::MiMalloc;
```

充分利用并发特性，感觉想到能并发的都并发了。scan stage 用了 tokio 做并发，resolve 时也用了 tokio；link stage 只添加信息不做修改和锁，应该很快；bundle stage 利用 rayon 做并发。

数据结构上无锁。

4、功能。

无 watch、无 HMR、基本无 Runtime、无 CSS、无 alias 等功能。定位应该和 rollup 及 esbuild 差不多，只能 build，不能 dev。dev 还是得结合 vite 或其他上层 bundle 工具使用。

> rolldown 还有不少可以写的，下一篇可以写写工程化、Benchmark、用例、Runtime、插件，再写一篇可以实现一个 toy-rolldown。

参考：  
[https://github.com/rolldown-rs/rolldown](https://github.com/rolldown-rs/rolldown)
