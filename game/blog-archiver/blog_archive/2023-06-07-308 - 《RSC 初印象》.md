---
title: "308 - 《RSC 初印象》"
date: 2023-06-07
url: https://sorrycc.com/rsc-first-impression
---

发布于 2023年6月7日

# 308 - 《RSC 初印象》

本文是读完 Dan 的 [RSC From Scratch. Part 1: Server Components · reactwg server-components · Discussion #5 · GitHub](https://github.com/reactwg/server-components/discussions/5) 之后，换个角度梳理一遍加深印象。

关于 RSC 。

1、RSC 是 React Server Component。顾名思义，就是跑在 Server 上的 React Component。既然是跑在 Server 上，所以 RSC 必然是以 SSR 为基础的。

2、React Component 并不支持异步，比如 `async function Foo() {}` 这种写法。但由于逻辑和业务的需要，比如要请求数据库或文件系统，RSC 需要支持异步。

3、RSC 完全跑在 Server 上，不会跑在 Client（浏览器）上。写的时候无需关心其在 Client 端的交互，Client 端的交互会交给传统的 Client Component。所以大家说这是 PHP 好像也挺形象的。

再看这篇文章。文中提供了详细的教程，引导开发者搭建出一个 RSC + SSR 的实例。文中是从下往上的结构，我这里从上往下再拆解一遍思路。

开始之前，先下载最终实例并在本地跑起来试试。1）打开 [https://codesandbox.io/p/sandbox/agitated-swartz-4hs4v1](https://codesandbox.io/p/sandbox/agitated-swartz-4hs4v1) ，然后在左侧文件树的空位上点右键，然后点「Download sandbox」，2）安装依赖 pnpm i，3）pnpm start，此时会启动 8080 和 8081 两个 Server，如果有报错，可以排查下是否有端口冲突，4）在浏览器里打开 [http://localhost:8080/](http://localhost:8080/) 。

![](https://img.alicdn.com/imgextra/i1/O1CN01bEUHWd1ss4Lazes3d_!!6000000005821-2-tps-1196-802.png)

这个 sandbox 里可以关注的是两部分的逻辑，1）初始加载，2）页面切换。

1、初始加载分 Server（ssr.js） 和 Client（client.js）。Server 先拿到 JSX，然后通过 `renderToString(jsx)` 将其转成 Html，再通过 `JSON.stringify()` 把 jsx string 存在全局变量 `__INITIAL_CLIENT_JSX_STRING__` 里（给 Client 用），最后把前面的部分通过 Html 的方式渲染输出。Client 脚本里，先把 `__INITIAL_CLIENT_JSX_STRING__` 变量里保存的 jsx string 转成 jsx，再通过 `hydrateRoot(element, jsx)` 进行注水。

2、页面切换的逻辑主要在 Client，Server 只需提供获取 jsx 的接口。Client 里先加 `?jsx` query 请求 server 拿到 jsx string，再把 jsx string 转成 jsx，最后通过 `root.render(jsx)` 做重新渲染。这样就能保持客户端的其他状态，保留 SPA 的优势了。

文中的一些技术点。

1、Server 怎么渲染出 JSX？

比如。

```ts
<h1><Foo /></h1>
```

转义之后是这样。

```ts
_jsx('h1', { children: _jsx(Foo, {}) });
```

而这个函数调用执行之后的返回值如下。

```ts
{
  $$typeof: Symbol.for("react.element"),
  type: 'h1',
  props: {
    children: {
      $$typeof: Symbol.for("react.element"),
      type: Foo,
      props: {}
    }
  }
}
```

需要注意的是，这里的 Foo 是 React Component，是函数，需要递归跑一遍，拿到其返回的 jsx 才行。

2、怎么支持 async Server Component？

前一个步骤里递归遍历 jsx 时，用 await 执行 Component 函数即可。

3、JSX 怎么做 stringify 和 parse？

JSX 需要同时在 Server 和 Client 端执行。Server 端用于初始执行时渲染出 Html，Client 用于初始执行时的注水和页面切换后的重新渲染。所以 JSX 需要再 Server 和 Client 之间通讯（同步）。但是 JSX 包含一些非 JSON 合法的数据类型，比如 Symbol.for(“react.element”)，这就需要再 JSON.stringify 和 JSON.parse 时做一层转换，比如在 Server 端把 `Symbol.for("react.element")` 转成 `"$RE"`，然后再在 Client 里转回 `Symbol.for("react.element")` 。

最后，再提一下 RSC 在社区的近期进展。

1、[Next.js 5 月份发布的 13.4 中](https://nextjs.org/blog/next-13-4)，App Router 进入稳定版，其中包含基于 RSC 的全新架构  
2、[RedwoodJS 下个版本 All in RSC](https://tom.preston-werner.com/2023/05/30/redwoods-next-epoch-all-in-on-rsc.html)  
3、[Remix 在做尝试](https://github.com/jacob-ebey/remix-rsc-do-not-use)

参考：  
[RSC From Scratch. Part 1: Server Components · reactwg server-components · Discussion #5 · GitHub](https://github.com/reactwg/server-components/discussions/5)  
[276 - 《手撕源码 30：wakuwork 和 RSC 原理》](https://sorrycc.com/source-30-waku)
