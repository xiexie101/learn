---
title: "127 - 《框架级 codemod：一》"
date: 2022-06-10
url: https://sorrycc.com/codemod-framework-01
---

发布于 2022年6月10日

# 127 - 《框架级 codemod：一》

不知大家是如何面对框架和库的大版本更新的，比如升级 Umi 3 到 4，如果有提供一个一键升级的 codemod 工具，会不会感觉很爽？

社区库的大版本更新通常会有升级文档，但却比较少见到有「一键升级工具」，即通过一条命令完成全部升级；而企业内的框架则通常会提供。提供和不提供都是出于 ROI 的考虑。比如基于 Umi 的蚂蚁内框架 Bigfish，服务了数千个活跃项目，每个项目都按照文档进行一遍升级，成本就要乘以数千。所以虽然 codemod 的开发成本高，但在这个场景下，ROI 还是划算的。

我们最近实现了面向内网框架的 3 升 4 的 codemod，目前在收尾和验证阶段，顺利的话会考虑对外提供。

codemod 背后如何实现？

社区有个库叫 jscodeshift，在 [https://t.zsxq.com/3ZbUf2J](https://t.zsxq.com/3ZbUf2J) 还调研过，但我们最终没有用他。jscodeshift 适用于纯 js 或 ts 代码的改动，比如 react 的 class component 转 function component，用 jscodeshift 是合适的。但对于框架而言，其实远远不够。因为修改的点除了 js 或 ts，还有 package.json、配置、css、eslintrc、prettierrc 等。并且这些修改之间还是有关联的，比如如果有配置 a，改成配置 b，然后做 js 的修改，最后还要在 package.json 中加上某个依赖。

我们实现的 codemod 分 preparer、checker 和 runner 三个阶段。

preparer 是准备给 checker 和 runner 用的 context，包括各种配置、pkg 信息、文件信息、基于前面的分析结果等。配置不能直接 require，我是用 aot 的方式，用 esbuild externals 所有依赖后 build 了一遍再 require 拿到；文件信息除了列表，还有内容，以及基于内容分析拿到的 import 和 export 信息；分析结果比如是有项目中有 ahooks 依赖的引用，如果有，后面需要在 js 和 package.json 部分做响应调整。

checker 是决定当前项目是否可以升级。不能让开发者跑了一半然后发现不能升，再给 revert 回去。比如是否使用了 git 且 git status 是干净的（万一失败了可以轻松回退），是否开启了新版本不支持的配置，是否框架版本是 1 或 2（因为只支持 3 升 4），等等。

runner 是做具体的代码修改，目前包括 ConfigRunner、PackageJSONRunner、JSRunner、CSSRunner 和 ESLintrcRunner。其中最复杂的是 ConfigRunner 和 JSRunner，因为他们涉及 AST 操作。

ConfigRunner 是做配置的删除和设置。他之所以复杂，是因为不清楚开发者是如何组织 config 文件的，比如配置 foo: 1，以下 8 种方式都是合法的。

```ts
export default { foo: 1 };
const foo = 1; export default { foo };
const config = { foo: 1 }; export default config;
const foo = 1; const config = { foo }; export default config;
export default defineConfig({ foo: 1 });
import foo from foo; export default { foo };
const getConfig = () => ({ foo: 1 }); export default getConfig();
function getFoo() { return 1 } export default { foo: getFoo() };
```

除了最后两种使用函数返回的之外，我们都做了支持。不支持函数返回是因为函数返回太动态，边界场景太多，而且这么用的人也少，所以支持的 ROI 太低。

JSRunner 是做 JS 代码的修改。背后实现是用 babel 全家桶，走 parse、traverse 和 generate 的标准流程。

```ts
const ast = parse(code);
traverse(ast, visitor);
const code = generate(ast);
```

结构理顺之后，剩下的就是把每条规则逐一实现，这里包含大量的体力劳动。

还有一点值得一提的是，实现 codemod 时测试用例必不可少。因为 ast 太抽象，很容易漏场景。写用例也是出于 ROI 考虑。
