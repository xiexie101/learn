---
title: "271 - 《手撕源码 29：Farm》"
date: 2023-03-07
url: https://sorrycc.com/source-29-farm
---

发布于 2023年3月7日

# 271 - 《手撕源码 29：Farm》

> 这个系列好久好久没更了。早上看到 [Farm 的新闻](https://zhuanlan.zhihu.com/p/611603260)，没忍住好奇心，把手上的事情放了放，专门花几个小时把源码翻了一遍。在此做下记录。

1、先八卦了下作者，哈哈，因为他在 github 上填的腾讯、知乎上填的还是字节，于是就打听了下。Github id [wre232114](https://github.com/wre232114)，之前在字节互娱部门做的基于 Rust 的构建引擎，后来架构变更，被 rspack 合并，再后来离职跳到腾讯，并把这套方案，命名为 [Farm](https://github.com/farm-fe/farm)，一个基于 Rust + SWC 的构建工具。

2、尝鲜可以 `pnpx @farmfe/cli@latest create` 新建个项目试试。可以看到，1）从 farm.config.ts 里的 input 可以看出，入口文件是 html 类型（但从实现上看应该不挑），2）挑几个刺，没 tsconfig.json，package.json 里依赖用 `*`，start 命令应该用 dev 命令，3）试了下加 antd 依赖再用个 Button，[就报错了](https://t.me/yqtalk/243)，应该是 revolve 规则的问题，有兴趣的可以直接去提 PR。

3、其他的一些小点。1）协议是 MIT，2）作者应该不用 webstorm，好多无伤大雅的小问题，比如我还顺手[混了个 typo 的 PR](https://github.com/farm-fe/farm/pull/47)，3）没有官网文档，哈哈，我还想先去翻翻文档的，那就只能直接翻源码了。

4、整体架构作者有贴一个[架构图](https://img.alicdn.com/imgextra/i2/O1CN01NjDnnp1suMIaL0VKk_!!6000000005826-0-tps-1982-1296.jpg)。1）整体实现分 node 和 rust 两部分，通过 napi 做相互通讯（应该是标配了），2）node 的包在 packages 目录下，主要是 cli 和 core，cli 除了 start、build、create 还有 plugin 的 create 和 build，core 通过 optionalDependencies 声明 binding 库，基于 @napi-rs/cli 打包而来，3）rust 的包在 crates 下，主要是 core、compiler、node 和各个插件包。

5、packages/core 主要 3 个功能，build、start 和 config。1）build 命令就是 `await (new Compiler(config)).compile()`，其中 Compiler 的实现来自 Rust，2）start 命令的实现里包含了 DevServer（HmrEngine、lazyCompilation） + Compiler + FileWatcher，其中 lazyCompilation 是一个中间件，接收到匹配请求后会执行 `await compiler.update(paths)` 添加额外需要编译的 paths，3）config 里有个点是，如果是 ts 文件，会先用自己的 compiler 编译一遍，存在临时目录下，再 `import()` 进来。

6、crates/node 是连接 node 和 rust 的库，会通过 @napi-rs/cli 打包成比如 `@farmfe/core-darwin-arm64` 这样的库。有一点值得注意的是，Farm 同时支持 js plugin 和 rust plugin，其中 object 类型的是 js plugin，会通过 JsPluginAdapter 转成 rust plugin 给 Compiler 使用。

7、crates/compiler 是 Farm 里最核心的包，实现了大量复杂的逻辑，包括 build、generate、plugin、module graph 等。

8、先说插件体系。Farm 全部由插件实现，和 webpack 比较像，也是我喜欢的方式，哈哈。1）PluginDriver 里通过宏的方式定义了一堆 hooks，完整列表有 build\_start、resolve、load、parse、process\_module、analyze\_deps、finalize\_module、build\_end、generate\_start、optimize\_module\_graph、analyze\_module\_graph、partial\_bundling、process\_resource\_pot\_map、render\_resource\_pot、optimize\_resource\_pot、generate\_resources、finalize\_resources、generate\_end、finish，大纲能猜出意思，然后每个插件实现对应的 hook 就可以了，2）这些 hook 里有些是 async，有些是 serial，有些是 first，等等，满足不同场景的需要，3）目前内置了 7 个插件，runtime、resolve、script、html、css、react 和 partial\_bundling。

9、compile 的过程主要分两步，build 和 generate。1）build 负责从入口文件开始生成 module graph，在这个过程里会做 resolve（找到模块）、load（挂载文件）、transform（编译文件）、parse（解析文件产出语法树）、process\_module（做一些语法树相关的事）、analyze\_deps（分析有哪些依赖，然后让依赖重新走一遍这些流程） 、finalize\_module 等事情，2）generate 负责基于 module graph 生成产物。

10、插件 farmfe\_plugin\_script、farmfe\_plugin\_css 和 farmfe\_plugin\_html 顾名思义，分别负责了 JS、CSS 和 HTML 的编译。而他们三个背后都是基于 SWC 做文件的 lexer、parser 和 codegen。1）js 的 parse 基于 swc\_ecma\_parser，然后在 process\_module hook 里针对 ts 和 tsx 做类型声明的删除，2）css 基于 swc\_css\_parser 和 swc\_css\_codegen，然后在 transform hook 里针对 dev 模式把 CSS 包成 JS 的方式加载。

11、说下个人感受。1）感觉是比较完整的库，同时个人比较喜欢这种完全插件化的实现思路，和 webpack 很像，umi 也是这种思路，2）代码很好懂，像我这种 Rust 新手也能不费力地看懂，3）功能上还有大量缺失，比如压缩、tree-shaking、code splitting 等，同时 resolve 的实现也过于简单，很多 edge case 都没覆盖，这也是为啥我加个 antd 就挂了，所以目前肯定是不能用不到生产里的。

12、最近不少基于 rust 的构建工具，包括 turbopack、farm、3.10 要开源的 rspack，同时蚂蚁内部也在做这方面的调研和选型。这些方案有很多可以对比的点，其中有一个是 node 和 rust 的边界线在哪，或者说方案中 rust 的占比是多少，我理解是 turbopack > farm > rspack。turbopack 是全部 rust，farm 和 rspack 的区别是 hook 的实现在哪，rspack 是在 node，而 farm 是在 rust。

#日更

* * *

*   读源码
    *   packages/cli
        *   cli 基于 cac 实现，包括 start、build、create、plugin create 和 plugin build
        *   plugin build
            *   执行 `cargo build --release`
            *   执行 `cargo metadata --format-version 1 --manifest-path xxx`
    *   packages/core
        *   包含了 binding，用 @napi-rs/cli 打包而来
        *   有 `@swc/helpers` 依赖
        *   figlet 依赖用于显示花字
        *   有 ws 和 koa 依赖，应该是自己实现了 server
        *   start command
            *   DevServer（HmrEngine、lazyCompilation） + Compiler + FileWatcher
            *   lazyCompilation
                *   通过中间件实现，接收到 url 匹配请求时会执行 `await compiler.update(paths)` 添加额外 paths
        *   config
            *   如果是 ts 文件，会拿自己的 compiler 编译一遍，输出在 `os.tmpdir() + farmfe/${Date.now()}-farm.config.bundle.mjs` 里，然后 `import()` 拿结果
            *   normalizeUserCompilationConfig
                *   plugins 支持两种类型，string 或 array 为 rust plugin，object 为 js plugin
    *   crates/node
        *   JsCompiler
            *   js\_plugins 通过 JsPluginAdapter 转成正常的 rust plugin
            *   compiler = Compiler::new(config, plugins\_adapters)
            *   compiler.compile()
    *   crates/compiler
        *   CompilationContext
            *   parking\_lot::{Mutex, RwLock}
        *   Plugin
        *   PluginDriver
            *   通过宏的方式定义一堆 hooks，比如 hook\_parallel!(build\_start)
                *   build\_start、resolve、load、parse、process\_module、analyze\_deps、finalize\_module、build\_end、generate\_start、optimize\_module\_graph、analyze\_module\_graph、partial\_bundling、process\_resource\_pot\_map、render\_resource\_pot、optimize\_resource\_pot、generate\_resources、finalize\_resources、generate\_end、finish
        *   compile = build()? + generate()? + finish
        *   build
            *   build 会生成 dep graph
            *   build\_start
            *   基于 rayon::ThreadPoolBuilder 创建 thread\_pool
            *   把 input 传给 build\_module\_graph\_threaded
                *   resolving, loading, transforming and parsing a module in a separate thread
                *   resolve\_module
                *   build\_module > deps
                    *   load > { content, module\_type }
                    *   transform > { content, source\_map\_chain, module\_type }
                    *   parse > ModuleMetaData
                        *   js => { ast: SwcModule, top\_level\_mark, unresolved\_mark, module\_system, hmr\_accepted }
                        *   css => { ast: Stylesheet }（也是基于 swc）
                        *   html => { ast: Document }（也是基于 swc）
                    *   process\_module
                        *   在这里做语法转换
                    *   analyze\_deps > `{ source, kind }[]`
                    *   finalize\_module
                *   add\_module(module)
                *   build\_module\_graph\_threaded for dependencies
            *   build\_end
        *   generate
            *   generate\_start
            *   optimize\_module\_graph
            *   partial\_bundling
                *   analyze\_module\_graph
                *   generate\_resource\_pot\_map
            *   process\_resource\_pot\_map
            *   render\_and\_generate\_resources
            *   finalize\_resources
            *   generate\_end
        *   内置插件
            *   farmfe\_plugin\_runtime
                *   config
            *   farmfe\_plugin\_resolve
                *   resolve
                    *   这个实现也太简单了，怪不得加 antd 会挂
            *   farmfe\_plugin\_script
                *   load
                *   parse
                    *   基于 swc\_ecma\_parser 实现
                *   process\_module
                    *   针对 ts 和 tsx 文件删类型声明
                *   analyze\_deps
                    *   找到依赖
            *   farmfe\_plugin\_partial\_bundling
            *   farmfe\_plugin\_html
            *   farmfe\_plugin\_css
                *   load
                *   transform，开始模式下包成 JS 的方式加载
                *   parse
                    *   parse\_css\_stylesheet，基于 swc\_css\_parser 的 lexer 和 parser
                *   generate\_resources
                    *   codegen\_css\_stylesheet，基于 swc\_css\_codegen
            *   farmfe\_plugin\_react
                *   load
                    *   加了一段 react-refresh 的使用来实现 react 的 hmr
                *   transform
                    *   黑盒逻辑
                *   process\_module
                    *   加 react-refresh 处理
                *   analyze\_deps
                    *   增加 hmr 相关的额外依赖
*   参考
    *   [比 Vite 快 5 倍? 2ms HMR？Farm：基于 Rust 的极速构建引擎！ - 知乎](https://zhuanlan.zhihu.com/p/611603260)
        *   默认采用按需编译，除首屏需要的模块外，其他模块均在加载时编译！因首屏能展示的内容有限，理论上对**任意规模的项目**，Farm 都能支持秒启动！
        *   毫秒级项目启动、2ms HMR
        *   不支持
            *   tree-shaking、code splitting、压缩
    *   [GitHub - farm-fe/farm: Super fast web build tool written in Rust](https://github.com/farm-fe/farm)
