---
title: "409 - 《React Tips》"
date: 2024-01-30
url: https://sorrycc.com/react-tips
---

发布于 2024年1月30日

# 409 - 《React Tips》

![](https://img.alicdn.com/imgextra/i2/O1CN01lV91NH1nRRJTu5yQA_!!6000000005086-0-tps-1920-1280.jpg_1200x1200.jpg)

题图：nadyeldems @ unsplash.com

**1、避免在 useEffect 里获取数据。**

因为，1）组件 unmount 后再 remount 时，数据会被重复获取，2）会导致请求瀑布流，3）通常不能做请求的预加载和缓存，4）不能兼容 SSR。

```tsx
function App(props) {
  const [user, setUser] = useState(null);
  useEffect(() => {
    fetchUser(props.userId).then((result) => {
      setUser(result);
    });
  }, [props.userId]);
  // ...
}
```

推荐的方法是用框架提供的方法，或者请求方案的库，比如 SWR，react-query 等。

```tsx
function App(props) {
  const { data } = useQuery(['user', props.userId], fetchUser);
}
```

**2、避免 useEffect 里出现竞态条件。**

一个例子带代码如下，先渲染 userId 1，再渲染 userId 2，假如 userId 1 的请求比 userId 2 的请求迟返回，那最后一次执行 setUser 的是 userId 1 的结果，而这并不符合预期。

```tsx
function User(props) {
  const [user, setUser] = useState(null);
  useEffect(() => {
    fetch(`/api/users/${props.userId}`).then((result) => {
      setUser(result);
    });
  }, [props.userId]);
  if (!user) return null;
  return <h1>{user.name}</h1>;
}
```

一个解法是，用 AbortController 来取消旧的请求。

```tsx
function User(props) {
  const [user, setUser] = useState(null);
  useEffect(() => {
    const abortController = new AbortController();
    fetch(`/api/users/${props.userId}`, {
      signal: abortController.signal,
    }).then((result) => {
      setUser(result);
    });
    return () => {
      abortController.abort();
    };
  }, [props.userId]);
  if (!user) return null;
  return <h1>{user.name}</h1>;
}
```

**3、如何监听 ref 变更？**

一个常见的错误解法是用 useEffect 加 ref.current 依赖，而 ref.current 是不会触发变更的。

```tsx
function App() {
  const ref = useRef(null);
  useEffect(() => {
    const element = ref.current;
    // ...
  }, [ref.current]);
  return <div ref={ref}>...</div>;
}
```

解法是用 ref 回调。每当 div 被挂载或卸载，ref 回调都会被调用。

```tsx
function App() {
  const ref = useCallback((node) => {
    if (node !== null) {
      // ...
    }
  }, []);
  return <div ref={ref}>...</div>;
}
```

**4、避免 useEffect 导致的无限循环。**

比如下面的场景，setCount 更新 count 到触发 re-render，re-render 会生成新的 user，user 变更又触发 useEffect 里的 setCount，导致无限循环。

```tsx
function App() {
  const [count, setCount] = useState(0);
  const user = { name: 'John', count: 5 };
  useEffect(() => {
    setCount((currCount) => currCount + user.count);
  }, [user]);
  return <div>{count}</div>;
}
```

解法很多，比如，1）用 useMemo 包一下 user，2）useEffect 的依赖用 user.count，3）等。

```tsx
function App() {
  const [count, setCount] = useState(0);
  const user = useMemo(() => ({ name: 'John', count: 5 }), []);
  useEffect(() => {
    setCount((currCount) => currCount + user.count);
  }, [user.count]);
  return <div>{count}</div>;
}
```

**5、用 && 做条件渲染时，应避免 && 左边出现数值。**

比如下面的代码，当 `users.length` 为 0 时，会渲染 0。因为 0 在 React 会被被当成有效的 React 子元素。

```tsx
function App({ users}) {
  return (
    <div>
      {users.length && users.map((u) => <p>u.name</p>)}
    </div>
  );
}
```

解法是把 users.length 转成布尔值，比如 `!!users.length` 或 `users.length > 0`。

**6、如何利用泛型推断动态组件（比如列表、表格）事件处理器的参数类型。**

```tsx
type ListProps<T> = {
  data: T[];
  onClickListItem: (item: T) => void;
};

// 注：这里的 T 后面得加个逗号，不然会和 jsx 语法冲突
const List = <T,>(props: ListProps<T>) => {
  return <h1>list</h1>;
};

function Page() {
  return (
    <List
      data={[{ id: 1, name: 'a' }]}
      onClickListItem={(item) => {
        // 这里有类型
        console.log(item.name);
      }}
    />
  );
}
```

**7、用 Enum 代替条件判断来渲染视图可提升代码可读性。**

条件判断的写法如下。

```tsx
function App({ role }) {
  return (
    <div>
      {
        role === 'admin' ? <Admin /> :
        role === 'user' ? <User /> :
        <Guest />
      }
    </div>
  );
}
```

Enum 的写法如下。

```tsx
function App({ role }) {
  const view = {
    admin: <Admin />,
    user : <User />,
    guest: <Guest />,
  }[role];
  return (
    <div>{view}</div>
  );
}
```

改进下，提 RoleViews 到外面，可减少 JSX 声明，从而提升性能。

```tsx
const RoleViews = {
  admin: Admin,
  user : User,
  guest: Guest,
};
function App({ role }) {
  const View = RoleViews[role] ?? DefaultView;
  return (
    <div><View /></div>
  );
}
```

**8、用组装式（composition）代替大量 props 可提升组件的扩展性。**

大量 props 的写法。

```tsx
function App() {
  return <Dropdown
    items={["item1", "item2"]}
    text="Solutions"
    footerHeading="Documentation"
    footerDesc="Browse our extensive documentation"
    showIcons
    hasFooter
  />
}
```

组装式的写法。

```tsx
function App() {
  return <Dropdown>
    <Dropdown.Button text="Solutions" showIcons />
    <Dropdown.List>
      <Dropdown.Item>item1</Dropdown.Item>
      <Dropdown.Item>item2</Dropdown.Item>
    </Dropdown.List>
    <Dropdown.Footer>
      <h2>Documentation</h2>
      <p>Browse our extensive documentation</p>
    </Dropdown.Footer>
  </Dropdown>
}
```

**9、自定义 Hooks 返回数组加 as const 可锁定类型。**

比如下面的例子，如果不加 `as const`，则 `<button onClick={toggleIsHappy}>` 处会报 `Type 'boolean | (() => void)' is not assignable to type 'MouseEventHandler<HTMLButtonElement> | undefined'.` 的错误。

```tsx
function useToggle(initialState: boolean) {
  const [state, setState] = useState(initialState);
  const toggle = useCallback(() => setState(state => !state), []);
  return [state, toggle] as const;
}

function App() {
  const [isHappy, toggleIsHappy] = useToggle(true);
  return (
    <button onClick={toggleIsHappy}>Hello {isHappy ? 'World' : ''}</button>
  );
}
```

**10、用 ts-pattern 做复杂条件的模式匹配。**

使用前。

```tsx
function App({ address }) {
  if (address.city === 'London' && address.street === 'Baker Street') {
    return <London />;
  }
  if (address.city === 'Paris' && address.street === 'Champs-Élysées') {
    return <Paris />;
  }
  if (address.city === 'New York' && address.street === 'Broadway') {
    return <NewYork />;
  }
  return <Default />;
}
```

使用后。

```tsx
import { match } from 'ts-pattern';
function App({ address }) {
  return match(address)
    .with({ city: 'London', street: 'Baker Street' }, () => <London />)
    .with({ city: 'Paris', street: 'Champs-Élysées' }, () => <Paris />)
    .with({ city: 'New York', street: 'Broadway' }, () => <NewYork />)
    .otherwise(() => <Default />);
}
```

参考：  
[https://twitter.com/\_georgemoller](https://twitter.com/_georgemoller)
