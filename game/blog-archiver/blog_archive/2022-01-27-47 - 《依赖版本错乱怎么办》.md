---
title: "47 - 《依赖版本错乱怎么办》"
date: 2022-01-27
url: https://sorrycc.com/dependency-version-chaos
---

发布于 2022年1月27日

# 47 - 《依赖版本错乱怎么办》

今天同事反馈的一个案例，记录下。

一个很老的项目，技术栈是 roadhog@1 和 dva@2.5.0-beta.2。遇到的问题是 history 找错了版本，期望用 4，但却用了 5。

业务同学很认真，遇到问题后排查、整理、并写了 2000 字的总结长文，但我翻了下，发现文中虽然有很多猜测、解法和建议，但并没有找到问题根源，解法是 WorkAround，并且建议是 XY Problem。简单解释 XY Problem，就是出现了问题 X，你理解后觉得是问题 Y，然后大家一起努力解决了问题 Y，却发现不是问题 X 的解或不是最优解。

那遇到了具体怎么排查呢？

1、确定谁依赖了 history 并引发问题，设答案为 X  
2、确认 X 对于 history 的依赖关系是否正确  
3、确认 X 和 history 的 node\_modules 上下级结构是否正确  
4、确认是否 webpack resolve 规则的锅

如果 2 有问题，那是依赖包的锅。举几个错误的用法，首先 X 都 import 了 history，然后，

a、X 的 package.json 中没在 dependencies 或 peerDependencies 里声明 history  
b、X 的 package.json 中通过 peerDependencies 里声明 history，但使用 X 的 Y 没有在 package.json 中通过 dependencies 声明 history。当然 Y 也可以继续用 peerDependencies 声明 history，然后一直往上推，但多层级 peerDependencies 相对较少

上述两个错误用法，会让 history 用哪个版本完全看天。可能跑了几年都是好的，然后 history 发个有 break change 的大版本就让项目挂了。

接着排查，如果 3 有问题，那是 npm client 的锅。npm client 通常有 hoist 的操作，把依赖在 node\_modules 中上提，以减少重复依赖的存在。但这个规则和 peerDependencies 之间是有可能冲突的，可能导致问题。当然，如果你用 pnpm，可以完全忽略这个问题。

具体怎么排查？先找 X 的下级 node\_modules，再找 X 的同级，再找 X 的父级往上的 node\_modules，确保 history 的版本是正确的。

比如，

```bash
// 下级
+ X/node_modules/history@4
// 同级
+ X
+ history@4
// 父级
+ node_modules
    + history@4
    + Y/node_modules/X
```

最后，如果 2 和 3 都正确，那通常就是 webpack resolve 规则的问题。有几个常见的错误，1）alias 问题，比如把 history 隐射到另一个错误的位置，可能导致问题 2）resolve.modules 问题，比如 roadhog@1 在这部分的逻辑是有问题的，先找的项目依赖，而不是当前文件的 node\_modules，参考 [https://github.com/sorrycc/roadhog/blob/1.x/src/config/common.js#L47-L49](https://github.com/sorrycc/roadhog/blob/1.x/src/config/common.js#L47-L49) 。

这个问题看似简单，但涉及知识点却是不少，包括 webpack、npm client、roadhog、依赖本身问题、webpack resolve 规则、依赖 hoist 等，并且每个环节都可能导致问题。
