---
title: "96 - 《Bigfish 4 特性 08：SSR & SSG》"
date: 2022-04-13
url: https://sorrycc.com/bigfish-4-feat-08-ssr-and-ssg
---

发布于 2022年4月13日

# 96 - 《Bigfish 4 特性 08：SSR & SSG》

> 4 月会更新 20 篇 Bigfish 4（含 Umi 4）的新特性，这是第八篇。

先解释下名词。SSR 是 Server Side Render（服务端渲染），即在服务端完成页面渲染，返回完整的 HTML 和 CSS，提升首屏渲染时间，同时解 SEO 爬虫抓不到内容的问题；SSG 是 Server Side Generation，基于 SSR 在构建阶段完成渲染，生成大部分页面对应的 HTML 文件，适用于既是静态无服务器又想拥有 SSR 优点的场景。

由于我们的业务属性原因，Bigfish 的 SSR 在内网应用场景相对少，大多集中在官网和组件文档方面。很多对 C 的项目，渲染性能和 SEO 是强需求。

SSR 不止是 ReactDOM.renderToString() + ReactDOM.hydrate()，还有 server 产物的 bundle、SSG、数据加载策略、路由文件的拆分、CSR & SSR 的选择和混用、assets 资源的处理、逻辑复用、HTML 拼接、路由和数据的加载及隐射关系、组件如何获取数据、潜在内存问题的处理、高可用等。

## 数据方案迭代

先看数据加载策略。

SSR 的加载策略已今时不同往日。加载策略要考虑不同的时机，1）页面初始加载时 2）页面切换时 3）build（即 SSG）时。不同时机的环境是不同的，初始加载时和 SSG 时肯定发生在 node 侧，而页面切换时用 node 侧还是 browser 侧是可以选择的。

Next.js 最早用的是 getInitialProps，getInitialProps 在页面加载时会在 node（server）侧执行，而在页面切换时会在 browser 侧执行。Umi 3 实现参考了这种实现。这种方式的问题是，node 和 browser 能拿到的入参是不同的，比如 node 下拿到 request 和 response，访问 database 等，这个方法如果要设计成既在 node 跑又在 browser 跑，那能做的事的边界就小了，比如只能做做 fetch 之类的。

```js
Page.getInitialProps = async (ctx) => {
 return { data: await fetch('/url') };
};
```

大家如果有看 Next.js 的文档，会发现他已不推荐使用 getInitialProps，而是推荐用 getStaticProps 和 getServerSideProps，适用不同的场景，其中前者是给 SSG 用的。

getServerSideProps 顾名思义，只在 server 端跑。那他如何解路由切换时的数据加载问题？答案是通过 API 请求。切换路由时，框架会匹配路由，请求 API 加载数据，API 背后是路由组件里定义的 getServerSideProps。由于只在 node 侧跑，能做的事的边界会比较宽。

```js
export async function getServerSideProps() {
 return { data: await fetch('/url') };
}
```

最近新出的 Remix 框架，SSR 的方式和 getServerSideProps 是一致的。回头看 Bigfish，Bigfish 3 用的方案是前者，Bigfish 4 用的方案是后者。与时俱进，哈哈。

## Bigfish 中的 SSR

Bigfish 中使用 SSR 只需三步。

1、配置开启 SSR

```js
export default {
 ssr: {}
}
```

2、在路由组件中定义数据

```js
// 定义 SSR 数据加载
export async loader() {}
```

3、在路由组件或其子组件中使用数据

```js
// 组件里使用数据
const loaderData = useLoaderData();
```

## 工程化

方案做到能用简单，但要做到好用，会有非常多工程化的点需要考虑。这里举几个例子。

比如前面聊的数据加载方案。数据加载通过在路由组件的 loader 方法定义，而这个 loader 方法可能涉及数据库链接、请求发起、鉴权等操作，这些操作的背后会有 node 依赖，而 node 依赖不应该被打包到 browser 的 bundle 库中，所以就需要单独提取出来。提取的方案在《03：默认最快的请求》里有提，方案是一样的，就是借助 esbuild 的 tree-shaking，分两步，1）提取 loader 内容，2）从路由组件中删除 loader。

数据加载方案除了提取 loader ，也还要做很多，不具体展开，思路差不多是这样。loader 提取后按路由 id 存放，请求过来时做路由匹配，把所有匹配路由的 loader 并行加载，然后返回数据并序列化到 HTML 中。客户端框架基于序列化的数据和路由做一一对应，通过 useLoaderData() 提取。

SSR 需要做一次额外的打包，打包方案也有多种选择。可供选择的方案有 esbuild 和 webpack，我们选了 esbuild，原因有几点。1）速度极快，2）风险可控，由于产物是给 node 消费的，就不需要考虑补丁、语法糖啥的，3）不需要考虑热更新。选 esbuild 同时也带来了额外的成本，需要把我们在 webpack 上的自定义项在 esbuild 里重新实现一遍，比如 css modules、css in js、svg as component 等。

SSR 打包过程中，有个需要考虑的点是资源的复用，举一些例子。比如图片、svg 等资源类文件，不能 server 产物有一份，browser 产物也有一份，重复的内容会让用户访问页面时加载两份，解法是利用 browser 产物的 manifest 信息打通 browser 和 server 产物；同时 inline base64 也要谨慎使用，因为会导致 html 和 js 里包含重复的内容；再有 css modules 中 className 的 hash 值也要保持一致，解法是通过 css-loader 的 getLocalIdent 配置打通 browser 和 server 产物。

## SSR 的未来

SSR 的未来是下一代 SSR 吗？可能不是。

SSR 可以让首屏渲染提速，但对于富应用来说，TTI（可交互时间）才是更重要的。但开启 SSR 在 TTI 反而会有反效果，我理解的原因有几个。1）重复，包括数据、资源文件、渲染都可能存在重复，2）SSR 会有 Hydration 的过程，而 Hydration 相对来说是慢的，需要加载完整的 JS Bundle、执行代码、关联 event hanlder、恢复应用 state、重建组件树。

![](https://img.alicdn.com/imgextra/i4/O1CN01W48iG21DG9Kvhenbe_!!6000000000188-2-tps-1937-1080.png)

社区对 Hydration 慢的一个解是序列化，不仅序列化状态，还有事件和组件树。对这部分感兴趣的同学可以关注 astro 和 qwik 等新型框架。
