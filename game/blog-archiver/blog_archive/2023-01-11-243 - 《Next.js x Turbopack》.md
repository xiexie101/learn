---
title: "243 - 《Next.js x Turbopack》"
date: 2023-01-11
url: https://sorrycc.com/next-js-turbopack
---

发布于 2023年1月11日

# 243 - 《Next.js x Turbopack》

上午带着两个问题看了下 Next.js 使用 Turbopack 的链路，都得到答案了，在此分享下。1）Next.js 是如何使用 Turbopack 的，2）如果 Umi 要用 Turbopack，应该如何做？

## Next.js 如何使用 Turbopack

1、入口在 [next.js/next-dev.ts at 9dedc94500cc059792abf5c71484b871140e6049 · vercel/next.js · GitHub](https://github.com/vercel/next.js/blob/9dedc94500cc059792abf5c71484b871140e6049/packages/next/src/cli/next-dev.ts#L373)。

```ts
let bindings: any = await loadBindings();
bindings.turbo.startDev();
```

loadBinding 会先尝试加载 wasm 的版本，再加载 native 的版本。wasm 版本是给某些平台+设备的组合专用的，和 swc 有关，和 turbopack 无关，先忽略。然后会走到 loadNative 的逻辑。

2、loadNative 代码在 [next.js/index.ts at efcec4c1e303848a5293cef6961be8f73fd5160b · vercel/next.js · GitHub](https://github.com/vercel/next.js/blob/efcec4c1e303848a5293cef6961be8f73fd5160b/packages/next/src/build/swc/index.ts#L273)。

有两种加载方式，1）prebuilt binary，加载 @next/swc/native/next-swc.xxx.node，2）npm package，加载 @next/swc-xxx。两种都会尝试，先 1 再 2，我理解应该是方案的过渡期吧。

然后会返回 nativeBindings 对象，包含 transform、transformSync、turbo、mdx 等，其中 turbo 即 turbopack，他包含 `startDev` 方法。

```ts
let bindings;
// try prebuilt binary
bindings = require(`@next/swc/native/next-swc.${triple.platformArchABI}.node`);
// try prebuilt package
bindings = `@next/swc-${triple.platformArchABI}`;
const nativeBindings = {
  turbo: {
    startDev() {
      bindings.startTurboDev();
    }
  }
};
```

3、bindings.startTurboDev 方法来自哪里？从 require 来源看，不难发现是来自 packages/next-swc，这个名字其实不能达意的，应该是历史原因，turbopack 算临时补充在 swc 包里进行挂载，相信后面会做调整。

打开 packages/next-swc/package.json，[next.js/package.json at c7162c42b22b6b808f2a13fc623d59dc14296fad · vercel/next.js · GitHub](https://github.com/vercel/next.js/blob/c7162c42b22b6b808f2a13fc623d59dc14296fad/packages/next-swc/package.json#L6)，这里有 build-native 的命令，他用 -p 指定了 next-swc-napi 这个包。

```ts
"scripts": {  
  "build-native": "napi build --platform -p next-swc-napi --cargo-name next_swc_napi --features plugin,rustls-tls --js false native",
}
```

然后就可以在 [next.js/turbopack.rs at b45c81577cf44401d992e95aedfa41ce10683258 · vercel/next.js · GitHub](https://github.com/vercel/next.js/blob/b45c81577cf44401d992e95aedfa41ce10683258/packages/next-swc/crates/napi/src/turbopack.rs#L6) 找到 startTurboDev 的来源 start\_turbo\_dev 方法了，用 use 语句可以发现，start\_turbo\_dev 来自 `next_binding::turbo::next_dev`。

```ts
#[napi]
pub async fn start_turbo_dev(options: Buffer) -> napi::Result<()> {
}
```

4、next\_binding 包来自哪？来自 turbo 仓库，[turbo/crates/next-binding at main · vercel/turbo · GitHub](https://github.com/vercel/turbo/tree/main/crates/next-binding)。turbo 仓库包含大量 turbo 前缀的包以及少量 next 前缀的包，turbo 前缀是通用的，next 是 next 专属的（感觉是废话）。

## 如果 umi 要用 turbopack 可以怎么做

拍脑袋想的，待验证。

1、Fork turbo 库，因为其基于 workspace 组织，内部大量包没有发布。只能通过 fork 的方式，然后参考 next 前缀的包建立一些 umi 前缀的包。

2、基于 napi 打包 binding 库。

3、在 js 里加载 binding 库。

参考：  
\[\[调研 Turbopack 接入方案\]\]
