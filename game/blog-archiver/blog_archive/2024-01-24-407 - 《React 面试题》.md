---
title: "407 - 《React 面试题》"
date: 2024-01-24
url: https://sorrycc.com/react-interview-questions
---

发布于 2024年1月24日

# 407 - 《React 面试题》

**1、解释 React 中的 Virtual DOM 是什么**

虚拟 DOM（VDOM）是一种编程概念，在这种概念中，「虚拟」的 UI 是存在内存中的，并通过 ReactDOM 等库与「真实」的 DOM 同步。

**2、Virtual DOM 和 DOM 有什么区别？**

虚拟 DOM 与真实 DOM 的对象基本相同，不同点是虚拟 DOM 是一个轻量级的拷贝。它不能操作 DOM 元素。其主要目的是在内存中对 DOM 元素进行快速计算。

**3、什么是 JSX？**

JSX 是 JavaScript XML 的简写。他是 React 使用的文件类型，他结合了 JavaScript 的表达能力和类 HTML 的模板语法。

**4、当我们谈论在 React 中的渲染时，你理解的是什么？**

渲染意味着 React 正在调用你的一个组件。

![](https://img.alicdn.com/imgextra/i3/O1CN01nLHcHg1RA6mHQAuY7_!!6000000002070-2-tps-984-360.png)

**5、解释 React 中组件的概念**

组件是构建 React 应用程序 UI 的模块。这些组件将整个 UI 分割成小的独立且可重用的部分。

**6、React 中的 props 是什么，它们与 state 的主要区别是什么？**

Props 是 React 中 Properties 的缩写。它们是只读变量，必须保持纯净，即不可变。这有助于维护单向数据流，并通常用于渲染动态生成的数据。与 State 的主要区别在于，props 是不可变的只读变量。

**7、你如何更新组件的状态？**

在函数组件中，你可以使用 useState 钩子来定义和更新一个状态变量。它返回一个数组，该数组的第一个位置保存状态变量，第二个位置保存设置或更新函数。你可以使用这个函数来更新状态变量，像这样：

```ts
setSomeState('some value')
```

**8、什么是合成事件？**

合成事件是作为浏览器原生事件跨浏览器包装器的对象。它们将不同浏览器的行为合并到一个 API 中。这样做是为了确保事件在不同浏览器中显示一致的属性。

**9、什么是 refs，举一个你用它的例子。**

Refs 是 React 中 References 的缩写。它是一个变量，用于保存对一个值的引用。你可以使用 useRef 钩子定义一个引用，它会返回一个引用变量，你可以通过调用 ref.current 键来访问。使用 ref 的例子比如对特定元素执行 DOM 计算。

**10、React 的渲染过程是如何？**

![](https://img.alicdn.com/imgextra/i1/O1CN01KSEt4z1P5rsagXsbG_!!6000000001790-2-tps-1198-756.png)

**11、你如何在函数组件中复用逻辑？**

可以用 customHooks 存储多个组件中复用数据或逻辑的函数，比如用 `useActiveUser()` 返回来自用户的所有数据。

**12、在 React 中什么是 key，它们的作用是什么？**

key 是一个字符串或数字，用于唯一标识一个 React 元素。key 在数组中尤为重要，因为它告诉 React 每个组件对应哪个数组项，以便稍后进行匹配。

如果你的数组项可以移动（例如由于排序）、被插入或被删除，这就变得很重要。一个选得好的 key 可以帮助 React 推断到底发生了什么，并对 DOM 树进行正确的更新。

**13、受控组件和非受控组件有什么区别？**

受控组件是指其状态和行为由父组件控制的组件。这些组件依赖从父组件传递下来的 props 来更新它们的状态和行为。非受控组件是指内部管理自己状态的组件。

**14、解释 React 中服务器端渲染与客户端渲染的主要区别**

服务器端渲染（SSR）是指在服务器上完成 React 应用程序的初始渲染。服务器为应用程序的初始状态生成 HTML，并将其发送到浏览器。当 JavaScript 包加载后，React 接管，应用继续作为客户端的 SPA（单页应用程序）运行。

**15、在 React 组件中，如何避免不必要的渲染？**

这取决于每个用例，但一种技术可能是用 useCallback 或 useMemo 包装组件接收的 props，并且在组件本身上使用 React.memo，以便仅在 props 改变时重新渲染。

另一种思路是检查组件本身的 useEffects，看看是否有不必要的渲染从内部触发。

**16、什么是 Portal？可用于什么场景下？**

React 有一个内置函数叫做 `React.createPortal`，它在他调用的组件和 DOM 元素之间创建了一座桥梁，用于将子节点渲染到存在于父组件 DOM 层次结构之外的 DOM 节点。

典型场景比如，1）当你需要将子组件渲染到 body 元素下，以避免 CSS 的层级问题，2）在父组件的 DOM 层级外渲染模态框、弹出窗口或悬浮提示等 UI 元素。

**17、阐述 useEffect 和 useLayoutEffect 之间的主要区别**

useEffect 在渲染阶段之后异步运行，这意味着它不会阻塞浏览器的渲染和布局工作。

useLayoutEffect 在渲染阶段之后、浏览器的布局和绘制阶段之前，同步立即运行。

![](https://img.alicdn.com/imgextra/i3/O1CN01nKzkoT1kBv2fwkFzn_!!6000000004646-2-tps-884-652.png)

**18、在 React 中你通常怎么获取数据？**

如果不使用任何第三方库，比如 react-query 或 swr，可以小心地使用 useEffect 在 React 中获取数据。

**19、React 中的 hooks 是什么？**

Hooks 是 React 管理函数组件中状态和副作用的方式。Hooks 是以 use 开头的命名函数，它们允许我们在不同组件间复用有状态逻辑，而无需编写类组件。

**20、如果你希望一个组件在最初渲染时只执行一次操作，你会如何在函数组件中实现它？**

我们可以通过使用 useEffect 和一个空的依赖数组来实现这一点。

```tsx
function HomePage() {
  useEffect(() => {
    tackPageView('HomePage');
  }, []);
  return <div>HomePage</div>;
}
```

**21、什么是 prop-drilling（属性钻取），如何避免它？**

Prop drilling 是一个非官方术语，用于描述通过多个嵌套的子组件传递数据，以便将这些数据传递给深层嵌套的组件。

这个问题有很多解法，比如，1）使用像 Redux 这样的集中式数据流方案来管理你的应用状态，2）利用 React 的组合模型，3）利用 context，4）…

**22、你如何将组件的状态重置为其初始状态？**

传入不同的 key 可以重置组件状态。

```tsx
function App() {
  const [key, setKey] = useState(0);
  function resetFormState() {
    setKey(Math.random());
  }
  return (
    <>
      <button onClick={resetFormState}>Reset</button>
      <Form key={key} />
    </>
  );
}
```

**23、解释 useState 和 useEffect 之间的区别。**

useState 和 useEffect 都是 React 内置的 Hook。useState 用于添加状态变量，useEffect 用于与外部系统同步。

**24、如果你必须在组件中设置一个 key，你会从哪里获取这个值？**

不同的数据来源提供不同的 key 来源。如果数据来自数据库，可以使数据库的 key 或 id，他们本质上是唯一的；如果是本地生成的数据，比如笔记应用的笔记，可以在创建笔记时使用递增计数器、`crypto.randomUUID()` 或像 `uuid` 这样的包。

**25、解释 React 组件懒加载的概念**

React.lazy 允许你推迟加载组件的代码，直到它首次被渲染。

在组件外部调用 lazy 来声明一个懒加载的 React 组件：

```tsx
import { lazy } from 'react';
const MarkdownPreview = lazy(() => {
  return import('./MarkdownPreview.js');
});
```

**26、解释 useMemo 和 useCallback 之间的主要区别**

其中 useMemo 用于缓存值，比如对象、数组、字符串、数字等，以避免昂贵的计算被重复执行；useCallback 用于缓存函数，以避免将不必要的新函数实例传递给子组件而触发不必要的渲染。

**27、什么时候需要使用 forwardRef？**

forwardRef 允许你的组件通过 ref 向父组件暴露一个 DOM 节点。调用 forwardRef() 让你的组件接收一个 ref 并将其转发给子组件。

```tsx
import { forwardRef } from 'react';
const MyInput = forwardRef((props, ref) => {
  // ...
});
```

**28、useEffect 清理函数何时运行？**

清理函数不仅在卸载时运行，而且在每次依赖改变引发的重新渲染之前都会运行。

**29、解释 React 中 Reducers 和 Context 的概念**

Reducers 允许你合并组件状态更新逻辑。Context 让你将信息深入传递给其他组件。你可以将 reducers 和 context 结合起来，以管理复杂的组件状态。

**30、在 React 组件的全局范围内，如何捕获渲染错误？**

我会使用一个 Error Boundary（错误边界），这是一个特殊的组件，它允许你展示一些备用的用户界面来代替崩溃的部分 —— 例如，一个错误信息。

![](https://img.alicdn.com/imgextra/i2/O1CN01ZXBsT91D9HRIenEJI_!!6000000000173-2-tps-964-764.png)

**31、解释以下代码有什么问题**

![](https://img.alicdn.com/imgextra/i2/O1CN01PCkzHI1eViT39mvnK_!!6000000003877-2-tps-956-562.png)

这里的问题是我们没有正确使用 useEffect。useEffect 应该只用于 props/state 和外部系统之间的同步。

在这种情况下，我们使用它从当前/之前的状态（firstName，lastName）派生出一个新状态（fullName）。解决方案是在渲染阶段像这样派生 fullName 状态：

![](https://img.alicdn.com/imgextra/i3/O1CN01rsM27m1kGV0IYfmFJ_!!6000000004656-2-tps-1184-488.png)

**32、useEffect 如何检查其数组依赖项中的变化？**

useEffect 会使用 `Object.is` 比较来对每个依赖项及其先前的值进行比较。对象和数组通过引用来比较，而原始变量则通过值来比较。

**33、ReactNode 和 JSX.Element 有啥区别？**

React.ReactNode 是 React 组件可以渲染的任何内容，包括 JSX、字符串、null、undefined、数字；JSX.Element 则仅代表 JSX。

![](https://img.alicdn.com/imgextra/i4/O1CN017Vsxag1PgVZAnFAur_!!6000000001870-2-tps-849-852.png)

参考：  
[https://master-react.georgemoller.com/](https://master-react.georgemoller.com/)
