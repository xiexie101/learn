---
title: "171 - 《grandpa 方案》"
date: 2022-08-19
url: https://sorrycc.com/grandpa
---

发布于 2022年8月19日

# 171 - 《grandpa 方案》

> 有兴趣参与的同学请联系我，可以在搭完架子后参与一部分工作，长期有空余时间的优先。

## 背景

某次直播写 dva 3 时想到的点，由于重新搭建 dva 3，我需要重头开始处理 package.json、prettier、tsconfig、eslint、test、打包工具、发布脚本等。这种重复劳动怎么能重复消耗人力呢？于是就想着写个工具自动做这件事。

这和现有的很多脚手架有啥区别？1）原子化，都是重头搭建，脚手架是一下子搭建好，可能会有些东西不是你需要的，2）可扩展，可以补充你自己的原子化能力，3）可回退，添加 prettier 不想要？再执行下工具删除就好。

这和 umi g 或者 modern.js 的「微生成器」的功能比较像，我希望重新设计后，使之成为 umi g 和 father g 的内核。名字待定，不一定叫 grandpa，发现好多人对这类词比较敏感，比如 father，不少人就是拒绝这个名字的。

## 实现

先给原子级的生成器一个名字，就叫「generator」吧。然后我理解主要做三件事，1）generator 的定义，2）generator 的查询 3）generator 的执行。

generator 的定义感觉 4 个属性就够，name、check、enable、disable。name 用于交互式的展示和选择，check 用于检查当前 generator 是否执行过，enable 和 disable 用于启用和回退。

比如，

```
export default defineGenerator({
  name,
  enable() {},
  disable() {},
  check() {},
});
```

generator 的查询是要找到所有 generator。除了内置 generator，还要支持通过插件（比如 grandpa-plugin-foo）扩展和本地扩展。插件和本地扩展的方式应该是相同的，都是在根目录下新建 generators 目录，然后里面的文件即 generator。写到这，我已经想让 umi 的项目和插件也拥有这个能力了。查询还要提供交互式的能力，让用户在不知道有什么的时候，也能找到想要的。

generator 的执行就是执行 enable 或 disable 方法，主要考虑的点是如何让这两个方法的编写简单。我的想法是，1）封装 zx 这个写脚本利器，然后方法里就可以直接 await zx.$`pnpm i` 进行依赖安装了，2）提供大量常用任务的辅助方法，addDeps、removeDeps、支持模板和 context 的 writeFile、installDeps、updatePackageJSON 等。

比如，

```ts
async function enable({ zx, utils }) {
  utils.addDeps({ name: 'prettier', version: '2', isDev: true });
  zx.$`pnpm install`;
}
```

## 使用

npx grandpa

## Action

*   \[x\] 搭建仓库
*   \[x\] 实现 core 的部分，包含简单查询和执行
*   \[ \] 支持插件扩展
*   \[x\] 支持本地扩展
*   \[ \] 执行部分添加 zx 属性
*   \[x\] 执行部分添加 addDeps、removeDeps、updatePackageJSON 方法
*   \[x\] 执行部分添加 writeFile
*   \[ \] 执行部分添加 installDeps
*   \[x\] 实现 generator:prettier
*   \[ \] 实现 generator:typescript
*   \[ \] 实现 generator:jest
*   \[ \] 实现 generator:father
*   \[ \] 实现 generator:packageJSON
*   \[ \] …此处应该还有大量其他 generator
*   \[ \] 接入 umi
*   \[ \] 接入 father
*   \[ \] 文档

参考：  
[https://github.com/sorrycc/gimi](https://github.com/sorrycc/gimi)
