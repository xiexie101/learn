---
title: "432 - 《内部代码别上插件机制》"
date: 2024-04-22
url: https://sorrycc.com/dont-use-plugin-for-inner-code
---

发布于 2024年4月22日

# 432 - 《内部代码别上插件机制》

> 源于上周内部的一个讨论。

Webpack 内部是以插件形式组织的。做 Umi 时借鉴了这个，Umi 内部也是这么操作的。这是个好的实践吗？之前觉得是，甚至 Umi 对外宣传时还以这个为卖点，但现在觉得不是。Webpack 代码难读应该是公认的，其中插件机制应该功不可没。

说下我的看法。

1、插件机制让代码不直观。

```ts
// without plugin
function build() {
  a.build();
  b.build();
}

// with plugin
function build() {
  applyPlugins('build');
}
register('a', { build() {});
register('b', { build() {});
```

任何事件驱动或插件驱动的编程方式都会让控制流的跟踪变得困难，从而导致不直观。比如上面的代码，使用插件机制之后，读 build 函数时，你是不知道他到底做了哪些事的，需要去读所有的插件，以及他们的顺序和依赖关系如何。这带来了额外的复杂度。插件机制让单个插件的复杂度降低，但却提升了项目整体的复杂度。

2、插件机制可能导致「无限坑位」问题。

当现有坑位不满足需求时，你会需要在代码里不断地挖坑（Hook）来让插件填，比如 Umi 处理 middleware 有 addBeforeMiddlewares、addMiddlewares 和 addAfterMiddlewares 三个 Hook。甚至插件里挖额外的坑位让其他插件填（Umi 的插件里也有不少）。

3、插件机制需要额外的中间层类型声明。

Umi 实现时提供了额外手动维护的 types.ts。

所以，插件机制应对外提供，而不是对内。

参考：  
[413 - 《读书笔记：A Philosophy of Software Design》](https://sorrycc.com/book-a-philosophy-of-software-design)
