---
title: "526 - 《Cline》"
date: 2025-02-18
url: https://sorrycc.com/cline
---

发布于 2025年2月18日

# 526 - 《Cline》

> 下午翻了下 Cline，做下记录。

1、Cline 是一款 VSCode 插件、开源的 Coding Agent。（注：目前他专注在 Agent 上，并没有提供 Tab 代码补全的能力。）

![](https://media.githubusercontent.com/media/cline/cline/main/assets/docs/demo.gif)

2、Cline 功能列表。

1）Plan/Act 双模式。Plan 模式下，做信息收集、需求澄清和方案设计，Plan 模式下的 Cline，就像一位经验丰富的架构师，在项目启动之初，帮助开发者理清思路，避免盲目开发；Act 模式下，根据前面制定的 Plan，一步一步执行代码修改、命令运行、浏览器操作等，直至完成最终目标。

2） 最核心的是 Code Agent。类似 Cursor 的 Agent 模式。Cline 内置了不少 tool，比如 CLI 执行（execute\_command）、文件系统（read\_file、write\_to\_file、replace\_in\_file、search\_files、list\_files、list\_code\_definition\_names 等）、浏览器模拟（基于 Claude 3.5 Sonnet 的 Computer Use）等。

3）考虑了安全问题。比如支持通过 .clintignore 忽略 .env、.pem 等敏感文件的读取，比如允许配置哪些操作是自动 Approve 的，比如有 CheckPoint 的概念，保存每次改动后的代码为 Snapshot。

4）上下文感知和 Cursor 的类似。支持 @ 提及文件、文件夹、URL、Terminal 等，同时会利用 VSCode 环境信息（可见编辑器、打开的选项卡、终端输出、问题诊断等）增加上下文信息。

5）支持 MCP，感觉是标配了。

6）成本与性能优化。有 Prompt Caching、Context Window 管理、Token 用量计算等方法。但由于 Cline 本身的处理比较简单粗暴，相同的任务，Token 用量会比 Cursor 要大。

3、Cline 原理。

![](https://cdn.jsdelivr.net/gh/sorrycc-bot/images@main/uPic/6Y2r6l.png)  
图来自 [https://www.nazha.co/posts/how-cline-works](https://www.nazha.co/posts/how-cline-works) 。

1）核心模块。Cline 的源码主要分为以下几个核心模块，各司其职。

*   **Webview UI 层 (webview-ui/)：** 基于 React 和 VSCode Webview UI Toolkit 构建用户界面，负责用户交互、状态展示和用户指令的传递。
*   **Extension Core 层 (src/core/)：** Cline 的核心逻辑所在，负责任务流程编排、工具调用管理、提示工程和对话管理。Cline.ts 是该层级的核心类，协调各个子模块完成复杂的编码任务。
*   **Integrations 层 (src/integrations/)：** 封装了 Cline 与 VS Code 各个子系统的集成逻辑，例如编辑器 (editor/)、终端 (terminal/)、浏览器 (browser/)、Checkpoints (checkpoints/) 和 Diagnostics (diagnostics/) 等。
*   **Services 层 (src/services/)：** 提供了各种独立的服务模块，例如身份验证 (auth/)、MCP 服务器连接 (mcp/)、文件系统操作 (glob/)、代码解析 (tree-sitter/) 和日志记录 (logging/) 等。
*   **API 层 (src/api/)：** 负责与各种 AI 模型 API 进行交互，包括 Anthropic、OpenAI、Bedrock、Vertex、Gemini 等，并提供统一的 API 接口和数据转换层，providers/ 目录下包含了各种 API Provider 的 Handler 实现。

2）一些核心流程。

*   **任务执行流程：** 在 Cline.ts 中，可以看到 Cline 如何通过 recursivelyMakeClineRequests 方法，将用户任务分解为一系列步骤，并循环调用各种工具来逐步完成任务。
*   **工具调用流程：** 以 execute\_command 工具为例，TerminalManager.ts 负责终端的创建和管理，TerminalProcess.ts 封装了命令执行和输出处理的细节，Cline.ts 则负责工具参数的组装、用户授权的请求和工具执行结果的处理。
*   **上下文管理流程：** Cline.ts 中的 loadContext 方法揭示了 Cline 如何收集和处理上下文信息，包括工作区文件结构、可见编辑器、打开的选项卡、终端输出和问题诊断等。ClineIgnoreController.ts 则包含了 .clineignore 功能的具体实现，以及如何控制 Cline 对工作区文件的访问权限。
*   **MCP：** McpHub.ts 负责 MCP Server 的连接管理、工具和资源的发现与加载。

3）插件激活流程。

> 之前没搞过 VSCode 插件，额外看了下 VSCode 插件的激活流程。

*   当 Cline 扩展被激活时 (extension.ts 的 activate 函数被调用)，会创建一个 ClineProvider 实例 (`src/core/webview/ClineProvider.ts`)，并使用 `vscode.window.registerWebviewViewProvider` API 注册为一个 Webview 视图提供器。
    *   ClineProvider 类实现了 `vscode.WebviewViewProvider` 接口，负责提供 Webview 视图的内容。
    *   ClineProvider.sideBarId 是在 package.json 中定义的 Webview 视图的 ID `claude-dev.SidebarProvider`
    *   `webviewOptions: { retainContextWhenHidden: true }` 配置项确保 Webview 视图在隐藏时 (例如用户切换到其他视图) 仍然保留其上下文 (例如 JavaScript 运行状态, DOM 结构)，避免每次显示时都重新加载，提升性能和用户体验。
*   当 VS Code 需要加载 Cline 扩展的 Webview 视图时 (例如用户点击侧边栏 Cline 图标，或者打开 “Cline: Open in New Tab” 标签页)，会调用已注册的 ClineProvider 的 resolveWebviewView 方法 (`src/core/webview/ClineProvider.ts`)。
    *   resolveWebviewView 方法是 WebviewViewProvider 接口的核心方法，VS Code 会将 WebviewView 或 WebviewPanel 实例作为参数传递给该方法。
    *   在 resolveWebviewView 方法中，ClineProvider 会配置 Webview 的选项，例如 `enableScripts: true` 允许在 Webview 中运行 JavaScript 脚本, `localResourceRoots: [this.context.extensionUri]` 设置 Webview 可以访问的本地资源根目录。
    *   ClineProvider 调用 `getHtmlContent` 方法生成 Webview 的 HTML 内容，并将 HTML 内容设置为 `webviewView.webview.html`。getHtmlContent 方法负责构建 HTML 字符串，其中包含了对 Webview UI (React 应用) 的 CSS 和 JavaScript 资源的引用 (例如 main.css, main.js)。
    *   ClineProvider 调用 `setWebviewMessageListener` 方法，设置 Webview 的消息监听器，用于处理来自 Webview 前端的消息
*   加载 Webview HTML。getHtmlContent 方法 (src/core/webview/ClineProvider.ts) 负责生成 Webview 的 HTML 内容，这个 HTML 文件是 Webview 渲染的入口点。HTML 文件在 `webview-ui/public/index.html`，其会挂载 `webview-ui/src/index.tsx` 渲染 `#root` 元素。

4、工程化。

1）[git-lfs](https://git-lfs.com/) 。第一次看到这个，记录下。

Git LFS（Large File Storage）是由 GitHub 开发的扩展，用于高效管理大文件和二进制文件。它通过将大文件存储在独立的服务器上，而在 Git 仓库中保留轻量级的指针文件，从而避免传统 Git 在处理大文件时可能遇到的性能问题。

Git LFS 不直接将大文件存储在 Git 仓库中，而是创建一个小于 1KB 的文本指针文件，这个文件包含了指向实际大文件的元数据（如文件大小和 SHA-256 哈希值）。实际的大文件则存储在 LFS 服务器上。

安装。

```
brew install git-lfs
```

2）如何本地调试 VSCode 插件。

按 `F5` (or `Run`\->`Start Debugging`)，开一个带当前 extension 的 VSCode 窗口。

3）测试。

基于 vitest 和 [vscode-test](https://github.com/Microsoft/vscode-test)，后者用于 vscode extension 的测试（注：也可以考虑 [vscode-test-cli](https://github.com/microsoft/vscode-test-cli)）。

vscode-test 是一个用于简化 Visual Studio Code extension 测试的库。它允许开发人员在 VS Code 的专用实例中运行测试，确保测试在与扩展部署后的运行环境非常相似的环境中执行。这对于确保扩展在实际条件下按预期运行至关重要。

5、Cline 的价值。

我个人应该不会去用 Cline。因为已经有 Cursor 了，相比 Cline 好用很多，我个人倾向于用更好的。而且 Cline 加的那个 token 实时计算，感觉会给人无形的压力，随便 chat 一下，钱就出去了。还是一次性提前付费，从心理上比较好（Cline 后期应该也会提供云服务吧）。虽然 Cline 也有不少眼前一亮的功能。比如安全上的考虑和 [Memory Bank](https://docs.cline.bot/improving-your-prompting-skills/custom-instructions-library/cline-memory-bank) 。

![](https://cdn.jsdelivr.net/gh/sorrycc-bot/images@main/uPic/T3VY3i.png)

看 Cline 主要是从蚂蚁的角度来看。1）安全。大厂出于安全的考虑，通常不会用国外的大模型，可能有人偷偷用，但绝不会大量推开。所以 Cline + DeepSeek 看起来是最佳的大厂内部程序员提效组合，同时拉长时间来看，后面内部能用模型能力肯定越来越强，coding agent 也会有更多发挥的空间。2）大厂有很多内部的流程、文档、答疑、screen to code、api generator 可以整合，结合内部的平台，还是有很多潜在需求的。比如内部框架也可以提供不少定制化的 tools（或者 MCP server）。

所以，我理解 Cline 的价值不在于个人，而在于为企业提供内部服务。

参考：  
[https://github.com/cline/cline](https://github.com/cline/cline)  
[https://github.com/RooVetGit/Roo-Code](https://github.com/RooVetGit/Roo-Code)  
[https://www.nazha.co/posts/how-cline-works](https://www.nazha.co/posts/how-cline-works)  
[https://github.com/cline/cline/blob/main/src/core/prompts/system.ts](https://github.com/cline/cline/blob/main/src/core/prompts/system.ts)
