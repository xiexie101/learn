---
title: "138 - 《手撕源码 13：Fresh》"
date: 2022-06-22
url: https://sorrycc.com/source-13-fresh
---

发布于 2022年6月22日

# 138 - 《手撕源码 13：Fresh》

![](https://img.alicdn.com/imgextra/i1/O1CN01PinVR31FuZZNuhN4I_!!6000000000547-1-tps-470-750.gif)

Fresh 昨天（2022.6.21）发了 1.0.0-rc.1，作者是 denoland core team 成员，支持类 next.js 的文件系统路由、无构建步骤、支持 api routes、支持 islands、支持部署到 Deno Deploy 等，虽然文档还在施工中，但感觉值得一翻。

下午翻了下源码，学到不少。整体代码简单易懂，连不熟 deno 的我看下来都没遇到卡点。代码仓库是 [https://github.com/lucacasonato/fresh](https://github.com/lucacasonato/fresh) ，如果要跑例子，直接 cd examples/counter && deno task start 就好。

观察 example 项目，你会发现有几个根文件，dev.ts、fresh.gen.ts 和 main.ts。dev.ts 在 dev 模式下使用，会在执行 main.ts 之前实时生成 fresh.gen.ts；fresh.gen.ts 是 dev.ts 生成的 manifest 文件，包含 routes、islands、statics、baseUrl 等信息；main.ts 是主入口，上线后也就是执行这个。

Fresh 基于 islands 架构或者叫 0JS 方案，整体是静态，然后挖了一些位置实现动态交互。这种架构的产物性能非常好，整体不依赖 js 完成渲染，然后通过必要的 js 按需给需要交互的 islands 加上交互。社区上其他的 0js 方案还有 astro、qwik 和 [elderjs](https://elderguide.com/tech/elderjs/)。至于 islands 架构是啥？具体可参考 [https://www.patterns.dev/posts/islands-architecture/](https://www.patterns.dev/posts/islands-architecture/) 。

Fresh 的 islands 如何实现？1）构建时，会将 islands 和 runtime 同时作为 entry 打包，所以产物中会有各个 island 的文件，2）访问路由时，服务端会通过 renderToString 将所有节点一起返回，包含 islands，同时会多返回一份 islands 的数据，通过 `id=__FRSH_ISLAND_PROPS` 节点输出，并且给 islands 加上 `<!--frsh-xxx:xxx-->` 的注释 3）客户端渲染时，runtime 会遍历（代码中方法叫 revive）dom 节点，遇到 `<!--frsh-xxx:xxx-->` 注释节点时，用 islands 的数据和组件渲染一遍，加上交互的能力。其中 2 和 3 的 vnode 和 render 能力基于 preact。

为啥前一段的第一个步骤是构建，而 Fresh 却声称是无构建？因为这个构建是在部署之后在服务端完成，当有用户访问 `/_frsh/js/buildId/:path*` 路由时，才会实时构建并存在缓存里（虽然没看过，但我猜其他框架的 ISR 也是这么搞的）。Fresh 的构建基于 esbuild-wasm（esbuild 的 wasm 版），通过 esbuild\_deno\_loader 的 denoPlugin 支持 deno 构建。

我发现我有点喜欢 deno 了。
