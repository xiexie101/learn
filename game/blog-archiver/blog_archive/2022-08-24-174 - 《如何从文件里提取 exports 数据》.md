---
title: "174 - 《如何从文件里提取 exports 数据》"
date: 2022-08-24
url: https://sorrycc.com/how-to-extract-exports
---

发布于 2022年8月24日

# 174 - 《如何从文件里提取 exports 数据》

昨天（2022.8.23）在群里抛一个问题，感觉没人知道答案？我也是才刚在 umi 4 的 mpa 场景里用的这种方式。umi 3 的约定式路由组件属性分析里其实也有实现，但方式不同。

问题是这样，

一个文件，比如 foo.ts，他会通过 export 的方式声明一些信息，export const props = { foo: 1, bar: 2 }，然后我们需要在 node 环境中通过编程的方式拿到这些属性，比如 foo.ts 的输出就是 { foo: 1, bar: 2 } 。

一些拍脑袋能想到的方案，

1、直接 require foo.ts  
2、用 Babel 分析 foo.ts 的 ExportDeclaration  
3、用 es-module-lexer 分析

方案 1 有几个问题，1）node 模块系统是不支持 .ts 的，需要额外通过 register 或者 loader 支持，2）foo.ts 所在的场景不是 node，而是 browser，这意味着除了 .ts、.tsx、.js，还会有 .css、.svg、.png 等其他类型文件的引用，这些 require 支持不了或者支持起来很 hack。

方案 2 是 umi 3 中使用的，相关代码在 [https://github.com/umijs/umi/tree/3.x/packages/ast/src/getExportProps](https://github.com/umijs/umi/tree/3.x/packages/ast/src/getExportProps) 。通过 Babel，用静态语法分析的方式，能做，但也有问题。问题是，1）复杂，2）场景支持不全，比如遇到 export const props = { foo: 1, bar: require(‘./bar.ts’) }，就得外分析 ./bar.ts 文件，由于 JavaScript 的动态性，这是很难穷举的，或者遇到动态的场景比如 export const props = { foo: 1, bar: 2+1 }，这个 2+1 用静态分析的方法就彻底搞不出来了。

方案 3 群里同学也有提到，看似可行但实际并不可行，跑不通的。es-module-lexer 只能拿到 export 信息的 key，并不能拿到值。

所以，我的方案是啥？

是「打包」！如果要分析 foo.ts，就把 foo.ts 打包一遍，然后拿打包产物的 export 信息。展开说是用 esbuild 打包，然后用 eval 执行结果代码。（eval 应该有更好的方案，比如用 vm 模块，求 PR）心急的同学可以直接看代码，仅 85 行，并且其中一半是 loader 声明。代码见： [https://github.com/umijs/umi/blob/master/packages/preset-umi/src/features/mpa/extractExports.ts](https://github.com/umijs/umi/blob/master/packages/preset-umi/src/features/mpa/extractExports.ts) 。

基础代码是，

```ts
const res = await esbuild.build({});  
const code = res.outputFiles[0].text;  
eval(code);
```

esbuild 有三个关键点，

1、要配 write: false，不输出文件时产物才会出现在 build result 里  
2、虚拟入口文件，我们给入口文件加 ?entry 的查询参数，然后通过插件的 onResolve 识别出这类模块，通过 onLoad 构建虚拟入口文件，再在虚拟入口文件里依赖不带 ?entry 的入口文件  
3、external 依赖，通过在插件里用 onResolve 识别非 . 或者 / 开头的依赖，把他们设置为 external: true，这样依赖是不会包含在产物里的，优点是，1）速度快，2）乱七八糟的问题少

个人感觉 esbuild 由于其速度优势，给框架带来了很多想象空间，umi 4 里不少功能都是通过 esbuild 的 transform 或 build 实现的。最近还有一个利用 esbuild 的 bundle 能力提升 mfsu 功能的想法。
