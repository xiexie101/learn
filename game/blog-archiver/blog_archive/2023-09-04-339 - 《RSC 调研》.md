---
title: "339 - 《RSC 调研》"
date: 2023-09-04
url: https://sorrycc.com/rsc-research
---

发布于 2023年9月4日

# 339 - 《RSC 调研》

> 一个内部的调研任务。

把 RSC 相关的知识点再调研了一遍，写下我的理解。时间有限，还没有实操实现过 Toy Version。

1、RSC 是 React Server Components，即增加了 Server 组件的概念，也即有对应的 Client 组件。基于此，默认全部为 Server 组件，加 “use client” 后即为 Client 组件。二者之间有不同的规则限制，以及复用组件和 Hook 时也有很多规则限制，这是会给业务开发带来的额外成本。

2、RSC 的执行逻辑是在 Server 渲染 React 节点，注意，1）遇到 native 组件或 Client 组件时停止，2）返回的渲染结果是 ui 描述而非 HTML，其中 Client 组件需额外包含渲染他们用的打包信息。到 Client 之后，接受 React 流式响应，反序列化，然后渲染 native 组件和 Client 组件。

以上是 RSC RFC 的简化描述，但不同框架对此的实现也是有差异的。

RSC 的最简实现可以看 [https://github.com/reactjs/server-components-demo](https://github.com/reactjs/server-components-demo) 。1）在 webpack 配置的基础上增加 react-server-dom-webpack/plugin 用于打包，把 client 组件拆成多个单独的入口，2）server 运行时不打包，通过 react-server-dom-webpack/node-register 给 node require 加 hook 实时分析 require 的文件，遇到 client 组件时直接返回节点描述而非组件本身。

而 RSC 要上生产，这个最简实现肯定是不够的。比如 Server 组件得做打包，原因是，1）通常 RSC 会基于 SSR，那 Server 组件其实可以复用 SSR 的打包逻辑，针对 Client 组件做一次特殊处理就好，2）不打包在处理资源文件和 CSS Modules 时会和打包的 Client 组件不一致，导致注水不匹配之类的问题。

如果 Umi/Bigfish 要接入 RSC，能想到的改造点是。

1、构建相关。如何打包 Server 产物和 Client 产物，Server 相对简单，Client 侧相对复杂，尤其是当 react 官网插件无法满足需求时会变得复杂，比如 Smallfish 的实现是 Fork 了一份修改的。  
2、一套 Runtime。  
3、和现有体系的集成。包括，1）和路由的集成（Smallfish 是 MPA，无需考虑），2）和现有 SSR 及其数据获取方式 useServerData 的集成。  
4、RSC 请求获取方案，参考 Next.js 的 Server Action。  
5、一套降级方案。如果 RSC 故障，需降级为 CSR 方案。

整体成本预计在数人月。

理解完 RSC，再回到 [https://open.alipay.com/portal/forum](https://open.alipay.com/portal/forum) 问题本身以及看 RSC 能解的问题，来看是否应该和需要上 RSC。

RSC 关乎性能主要是三点，1）0 Bundle Size 组件，有些重客户端的事比如 Markdown 渲染、语法高亮灯，在客户端做需要大尺寸的 js 文件，而放客户端做只需返回结果，所以是 0 Bundle Size，2）自动代码分割，由于服务器组件将客户端组件的所有导入都视为潜在的代码分割点，所以理论上挂载一个 client 的搜索组件，只需要加载搜索相关的 client js 即可，当然，这也依赖框架如何实现和打包 client 组件，3）无请求瀑布，其实也不是无请求瀑布，而是把 client 到 server 之间的请求瀑布，改成了 server 内部的请求瀑布，所有请求发生在 server 端，请求所需时间大幅降低。

再看 [https://open.alipay.com/portal/forum](https://open.alipay.com/portal/forum) 的性能问题，在我看来主要是请求瀑布的问题，有很明显的「主应用 > 子应用 > 文章列表 > Tag 列表」串行四步加载过程，而且无缓存。关于性能优化的一些想法。

1、假如没有微前端的主子应用加载，应该默认就能提升不少。

2、纯客户端优化能解子应用内部的请求瀑布问题，比如让子应用加载、文章列表和 Tag 列表的加载并行。同时如果基于 react-query，通过缓存和 preload 等机制，可以让加载完成的 Tab 和 tag 切换体验更好。

3、如果改成基于 SSR，可以做到子应用内容直出，还是挺适合论坛类型的应用的。

4、在 SSR 的基础上增加 RSC，感觉在这个场景下收益并不高，能想到的收益是减少一些可交互时间所需的 JS 的尺寸，但能减少的量未知。

参考：  
[https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md)  
[https://github.com/facebook/react/blob/main/packages/react-client/src/ReactFlightClient.js](https://github.com/facebook/react/blob/main/packages/react-client/src/ReactFlightClient.js)  
[https://nextjs.org/docs/app/building-your-application/data-fetching/forms-and-mutations](https://nextjs.org/docs/app/building-your-application/data-fetching/forms-and-mutations)  
[308 - 《RSC 初印象》](https://sorrycc.com/rsc-first-impression)  
[276 - 《手撕源码 30：wakuwork 和 RSC 原理》](https://sorrycc.com/source-30-waku)  
[316 - 《Full Stack React 笔记（1）》](https://sorrycc.com/full-stack-react-note-01)

* * *

[https://yuque.antfin.com/peiqiao.ppq/docs/rsc-08](https://yuque.antfin.com/peiqiao.ppq/docs/rsc-08)
