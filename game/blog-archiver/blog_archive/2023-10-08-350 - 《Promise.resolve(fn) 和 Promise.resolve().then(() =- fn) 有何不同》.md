---
title: "350 - 《Promise.resolve(fn) 和 Promise.resolve().then(() => fn) 有何不同》"
date: 2023-10-08
url: https://sorrycc.com/promise-resolve-problem
---

发布于 2023年10月8日

# 350 - 《Promise.resolve(fn) 和 Promise.resolve().then(() => fn) 有何不同》

背景是，我们需要在构建工具中增加一个配置项，把 import() 转成 require()，但 import() 返回的是 Promise，而 require 是同步执行的，所以就要给 require() 包装成 Promise 返回。

这时有两种选择，

1、`Promise.resolve(require('foo'))`  
2、`Promise.resolve().then(() => require('foo'))`

咋一看效果相同，我的同事 review 实现时也提出了这个疑问。但如果你的 Promise 功力足够深，还是会发现有些不同的。

有两点不同，1）错误处理，2）执行方式。通过下面这个例子就能看到了。

```ts
function fn() {
    throw new Error('error');
}
Promise.resolve(fn()).catch(e => {
    console.error(`catch: ${e.message}`);
});
console.log(2);
// /private/tmp/sorrycc-5Rtzd4/test.js:11
//    throw new Error('error');
//    ^
// Error: error
//     at fn (/private/tmp/sorrycc-5Rtzd4/test.js:11:11)
//     at Object.<anonymous> (/private/tmp/sorrycc-// 5Rtzd4/test.js:13:17)
```

Promise.resolve(fn()) 会先执行 fn()，再执行 Promise.resolve()。所以，1）fn() 是同步执行的，2）fn() 如果出现错误会直接抛出，而不会落到 Promise.resolve() 的 catch 里。

```ts
function fn() {
    throw new Error('error');
}
Promise.resolve().then(() => fn()).catch(e => {
    console.error(`catch: ${e.message}`);
});
console.log(2);
// 2
// catch: error
```

Promise.resolve().then(() => fn()) 会先执行 Promise.resolve()，然后在 then() 里执行 fn。所以，1）fn() 是异步的，例子中也是先输出 2 再 catch 到错误，2）fn() 的错误会被 Promise catch 到。

所以，除非明确知道 fn() 不会抛错，那通常都应该选择后一种方案。

最后回到我们的场景，处理 import() 的转换我们需要的肯定是后者，import 模块的执行应当是异步的。

参考：  
[https://github.com/airbnb/babel-plugin-dynamic-import-node](https://github.com/airbnb/babel-plugin-dynamic-import-node)  
[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)  
[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)
