---
title: "234 - 《极简交互的极致体验》"
date: 2022-12-27
url: https://sorrycc.com/ultimate-experience
---

发布于 2022年12月27日

# 234 - 《极简交互的极致体验》

想象一个场景，一个显示随机数的按钮，其内容来自远程服务器，按钮点击后会再次请求服务器更新随机数，你会怎么做？又有哪些可以优化的点来把这个交互做到极致？

![](https://img.alicdn.com/imgextra/i3/O1CN01M9TkIT1mgiuv69W16_!!6000000004984-1-tps-183-95.gif)

通常大家拍脑袋想到的会是，

1、loading 状态的处理  
2、异常状态的处理

但其实还有很多其他的。而用 React 原生实现通常就是用 useState 存数字 + useEffect 发请求 + useReducer 强制更新，代码如下。

```tsx
const [key, forceUpdate] = useReducer(x => x + 1, 0);
const [num, setNum] = useState<string>();
const [loading, setLoading] = useState(false);
const [error, setError] = useState("");

useEffect(() => {  
  setLoading(true);
  fetchNumber()
    .then((random) => {
      setLoading(false);
      setNum(random);
    }).catch((error) => {
      setError(error.message);
    });
}, [key]);

if (error) return <p>{error}</p>;
return <button onClick={forceUpdate}>Random number: {loading ? "..." : num}</button>;
```

这段代码没啥大问题，但如果要精益求精，可以从哪些点出发去优化这段交互呢？

**1、loading 处理。** 目前 loading 状态的处理比较简单。要注意 loading 状态在初始和 refetch 时可以是不一致的，比如初始时是从无到有的动画，而 refetch 时可以是数字变化的动画。

**2、出错处理。** 目前出错处理比较粗暴，有错误时直接显示了错误，连按钮都没了，既没有自动重试机制，也没有重试按钮。出错处理的选择是很多的，1）要不要自动重试，利用指数退避策略重试，多次重试后依旧失败才反馈给用户，2）反馈错误的方式也有多种，比如全局用 toast 反馈、局部交互上反馈、布局组件上通过 error boundary 反馈。

**3、状态保新。** 按钮状态是否要保新？如果是，可以考虑，1）定时发请求更新，2）窗口聚焦时发请求更新，3）网络恢复时发请求更新，4）…

**4、多次触发。** 目前没有处理按钮多次点击的情况，多点几下后的效果见下图，问题包括，1）UI 多次渲染和闪烁，2）存在 race condition，最后显示的未必是最后一次点击的。一些常见的处理方法，1）loading 时让按钮失效，最简单但会让用户有挫败感，用户期望的可能是最后一次点击能拿到正确的值，2）防抖或节流，3）让用户随便点，但保证最后一次更新的数据是最后一次点击触发的，4）在 3 的基础上，取消非最后一次点击的所有请求，同时节省用户带宽和服务端资源。

![](https://img.alicdn.com/imgextra/i3/O1CN01BzfANt23jn2GSYXbM_!!6000000007292-1-tps-183-95.gif)

**5、加载时机。** 按钮初始随机数加载的时机决定渲染时间，早请求、早渲染。如果请求是随组件一起，那可能会滞后，尤其是应用 Suspense 之后，请求瀑布问题会更严重。此时也有多种选择，1）prefetch，当然 prefetch 的时机也有多个选择，比如随组件代码一起、在前序页面发起等，2）和 react-router 的 loader 或 umi 的 client loader 结合使用，让他们解决加载时机的问题，路由匹配即发起请求，又快又准确。

**6、数据缓存。** 缓存有不同类型，比如内存缓存、物理缓存，大部分场景内存缓存就够用。当用户跳转到其他页面后再跳回来时，或者点击浏览器的前进后退按钮时，数据是否应该重新发起？如果不应该，或者一小段时间内不应该，那就不能仅仅依赖 react 组件层，可能还得有个缓存层。

这一通操作下来，这个交互的体验应该就没啥问题了。但是大家可能觉得实现成本会不会太高？比如群里同学反馈的，多次触发可以用「rxjs一把梭，只留最后一次就switchMap，只留第一次就exhaustMap」。而且上面的例子太简单，不涉及表单、数据变更、分页等，涉及了会更复杂一些。

深入接触 React Query 这类请求管理库之前我也这么觉得，后来发现 React Query 其实已经很好地处理了这些体验细节，而且大部分功能的处理都是默认的，所以借助 React Query，可以花很小的成本实现较好的体验。
