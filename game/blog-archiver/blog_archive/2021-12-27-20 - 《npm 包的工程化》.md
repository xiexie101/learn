---
title: "20 - 《npm 包的工程化》"
date: 2021-12-27
url: https://sorrycc.com/npm-package-engineering
---

发布于 2021年12月27日

# 20 - 《npm 包的工程化》

> 以下实践均已应用在 [https://github.com/umijs/umi-next](https://github.com/umijs/umi-next) 仓库。

组织方式可选 single repo、multiple repos 和 monorepo。除很简单的 single repo 外，我会优先考虑 monorepo。好处很多，比如一个仓库所以代码组织组织和跳转容易，跨 repo 修改一次完成，统一的工具链，简化依赖等。

monorepo 的组织最早是 lerna + npm，然后 umi 3 时用 lerna + yarn，umi 4 时切换到 pnpm。pnpm 相比 yarn 和 npm 优势非常大，比如安装快、更安全、支持 monorepo、无幽灵依赖、无 NPM doppelgangers 等。由于 pnpm 原生支持 monorepo，所以就无需其他 monorepo script runner 比如 lerna。

pnpm 有一个 Tip 是要提交 pnpm-lock.yaml，然后作为 hash 值在 CI/CD 环节缓存 .pnpm-store 目录，可大幅节省时间。如果需要 e2e，还需要 playwright, cypress，这部分 umi 4 仓库还没用上。

辅助脚本比如发布、检查 npm client 等，推荐 zx + esno + TypeScript 的组合。esno 用于执行 TypeScript，基于 esbuild 所以极快；zx 封装了大量脚本库，无需安装依赖也无需 import 依赖，直接用。有个 Tip 是脚本自身无需处理 monorepo 的执行，交给 pnpm 就好。

Git Hooks 是 husky + lint-staged 的组合。前者用于配置 git hooks 的执行脚本，后者让执行脚本更快一些，只覆盖修改过（staged）的文件。

编译打包的选择很多，rollup、webpack（打 umd）、father-build、tsup、tsc、microbundle 等，不止十个。npm 源码编译可简单可复杂，简单的直接用 tsc 就搞定，复杂的需要考虑 Node vs. Browser、Bundle vs. F2F（File to File）、cjs vs. mjs vs. esm vs. umd、Dep External vs. Dep Bundle 等。此外，还需要正确处理 depdendencies、devDependencies、peerDependences、sideEffects 等配置，单独处理 dts 生成。

Umi 4 的打包目前是直接用 tsc，然后大家可以期待下 father 4，方案讨论了几轮，覆盖前面描述到的各种问题。  
代码风格和质量方面。一般是 editorconfig + eslint + prettier，editorconfig 提供基础配置，eslint 负责质量，prettier 负责风格。我自己较少用 eslint。prettier 的一个 Tip 是加上 prettier-plugin-organize-imports 和 prettier-plugin-packagejson 插件，补上 prettier 官方功能的缺漏。

测试是 Jest + ts-jest + ts-node + @types/jest 的组合。ts-jest 是为了可以用 ts 写用例，ts-node 是为了可以用 ts 写 jest.config.ts，@types/jest 是为了使用 test、assert 等语法时有 dts 定义和提示。

发布有点复杂，这篇内容够多了，就不展开了，直接看代码吧，适用于统一版本的 monorepo，[https://github.com/umijs/umi-next/blob/master/scripts/release.ts](https://github.com/umijs/umi-next/blob/master/scripts/release.ts) 。做的事情很多，但由于用了 zx，看起来还算清晰。
