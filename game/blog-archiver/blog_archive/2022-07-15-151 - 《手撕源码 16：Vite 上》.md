---
title: "151 - 《手撕源码 16：Vite 上》"
date: 2022-07-15
url: https://sorrycc.com/source-16-vite-01
---

发布于 2022年7月15日

# 151 - 《手撕源码 16：Vite 上》

一年多前翻过 Vite 源码，还整理了 [https://github.com/sorrycc/toy-vite](https://github.com/sorrycc/toy-vite) 在内部做过分享。一年过去，发现已经忘光了。趁着 Vite 3 发布，重新捡起来看一遍。

CLI 提供 dev、build、optmize 和 preview 功能。

dev 的流程是读取配置，创建 Http Server，绑中间件，初始化 Module Graph（依赖图谱），初始化 pluginContainer（插件体系），做 dep optimizier（依赖预编译），就搞定了。然后等着用户访问，url 过来之后做按需 transform（代码主要在这）。dev 还支持 middlewareMode，顾名思义，就是不启动 server，把 vite 作为中间件使用。

中间件包含 time、cors（基于 cors）、proxy（基于 http-proxy）、base、launchEditor、servePublic、transform、serveRawFs、serveStatic、spaFallback（基于 connect-history-api-fallback）、用户配置（放在 html 之前，所以用户可以改写 indexHtml 的内容）、indexHtml、vite404、error。

build 的流程是读取配置，初始化 pluginContainer，挂载大量插件（20+），组装好 rollup 配置，然后跑 rollup。支持多个进行并行执行，应该是 ssr + csr 的场景。支持 ssr 打包。支持 lib 打包。支持 watch 模式。

optmize 和 preview 没啥好说的，前者是 dev 和 build 之外手动执行依赖预编译，后者是 build 产物的预览模式。

optimizer，这是 Vite 快的秘密武器之一。optimizer 的流程是找到入口，通过 esbuild + esbuildScanPlugin 打包入口来记录可能用到的依赖，再跑 esbuild + esbuildDepPlugin 做依赖预编译，入口是拍平的每个依赖。

工程化方面。

*   使用 pnpm 作为包管理工具，同时添加 pnpm 为依赖（这是为啥？）
*   使用 tsx 执行 ts 脚本
*   使用 rollup 打包 vite 主包，使用 unbuild 打包插件包
*   使用 api-extractor 提取类型
*   使用 prettier 2.7，并开启 --cache 参数
*   使用 eslint-define-config 为 eslint 配置提供 defineConfig 方法
*   使用 simple-git-hooks 代替 husky 作为 git hooks 库
*   产物是 EMS 格式，为了兼容，提供 CJS Proxy，区分处理同步和异步方法

参考：

[https://vitejs.dev/](https://vitejs.dev/)  
[https://github.com/vitejs/vite](https://github.com/vitejs/vite)  
[https://github.com/sorrycc/toy-vite](https://github.com/sorrycc/toy-vite)  
[https://juejin.cn/book/7050063811973218341](https://juejin.cn/book/7050063811973218341)  
[https://github.com/sanyuan0704/juejin-book-vite/tree/main/mini-vite](https://github.com/sanyuan0704/juejin-book-vite/tree/main/mini-vite)
