---
title: "374 - 《Mako 开发日志（7） - NApi》"
date: 2023-11-22
url: https://sorrycc.com/mako-devlog-07
---

发布于 2023年11月22日

# 374 - 《Mako 开发日志（7） - NApi》

> 这几天调整了下 Mako 接入 NApi 的方式，写下心得。

1、背景是，1124 要发内部正式版，然后找了个内网很大的项目做 Benchmark，分别用 Mako、Webpack 和其他基于 Rust 写的构建工具做对比。一对比发现 Mako 咋这么慢。。然后进一步排查发现是和我们使用 Less 的方式有关。这个项目里有 500 多个 Less 文件，意味着要跑 500 多次 Less 编译。而我们之前想着 Less 就是个中间态，就随便上了一种方案，用调 lessc 命令行编译的方式做的。这意味着 lessc 命令行的启动和 less 的初始化都要重复做很多次，小项目可能没啥感觉，但大项目 500 多次就很慢了。

2、新方案是用 NApi 的方式走 Node 函数编译 less，可以让 lessc 命令行的启动和 less 的初始化只做一次。最终结果是，上述项目的模块构建部分的时间，从 21854ms 降低到了 6887ms。

3、NApi 我遇到的有几种使用场景，1）rust 里定义函数，供 js 层调用，这应该是最常见的场景，2）rust 里定义函数，其参数包含 js 函数，rust 里调用 js 函数，3）基于 2，要额外拿到 js 函数的返回值，4）基于 3，js 函数返回值要支持 promise，5）基于 2，js 函数可能在主线程里被调用，也可能在子线程里被调用。

4、定义函数很简单，只要加 `#[napi]` 即可（注：也可以用 `#[js_function()]`）。其第一个参数 env，可选，用于获取当前状态的上下文，但需要注意的是 env 不能在多线程中传递。

```rust
#[napi]
fn test(env: Env) {}
```

```js
test();
```

5、传 JS 函数给 Rust 用 JsFunction 就好，可以使用他的 .call 方法调用并拿到返回值。需要注意的是，如果要支持异步的 js 方法，比如 Promise，可参考 [https://github.com/parcel-bundler/lightningcss/blob/a8b7ea0/node/src/lib.rs#L239](https://github.com/parcel-bundler/lightningcss/blob/a8b7ea0/node/src/lib.rs#L239) 实现。

```rust
#[napi]
fn test(env: Env, func: JsFunction) {
  let result = func.call(None, &[env.create_string("hello")?])?;
  let result: JsString = result.try_into()?;
}
```

```js
test((message) => {
  return `hello ${message}`;
});
```

6、上述方案比较简单。但是如果要支持多线程，就得用 Threadsafe Function，这时会变得复杂一些。而大部分注重性能的 Rust 应用都会应用多线程，所以这个复杂度通常是绕不开的。一些注意点。1）ThreadsafeFunction 有两个实现，1 是官方的，2 是 lightningcss fork 的，见 [https://github.com/parcel-bundler/lightningcss/blob/a8b7ea0/node/src/threadsafe\_function.rs](https://github.com/parcel-bundler/lightningcss/blob/a8b7ea0/node/src/threadsafe_function.rs) ，我用的是后者，其好处是 call 完 js 函数后能拿到返回值；2）Threadsafe Function 拿回调值得用 channel，可以用 mpsc 标准库的，也可以用 crossbeam-channel crate 的，后者据说更快，3）用了 channel 后就不能在主线程 .recv() 等消息了，会卡主，所以得用 env.execute\_tokio\_future 或 rayon::spawn 启一个子线程做，4）如果要返回 promise，可以用 env.create\_deferred() 。

```rust
thread_local! {
  static CHANNEL: (Sender<napi::Result<String>>, Receiver<napi::Result<String>>) = mpsc::channel::<Result<String>>();
}

#[napi]
fn test(env: Env, func: JsFunction) -> napi::Result<JsObject> {
  // create threadsafe function
  let tsfn = ThreadsafeFunction::create(
    env.raw(),
    unsafe { func.raw() },
    0,
    |ctx: ThreadSafeCallContext<ReadMessage>| {
      let str = ctx.env.create_string(&ctx.value.message)?;
      let result = ctx.callback.unwrap().call(None, &vec![str])?;
      await_promise(ctx.env, result, ctx.value.tx.clone()).unwrap();
      Ok(())
    },
  )?;
  // create deferr
  let (deferred, promise) = env.create_deferred()?;
  // run in thread
  env.execute_tokio_future(
    async move {
      let ret = CHANNEL.with(|channel| {
        let (tx, rx) = channel;
        tsfn.call(
          ReadMessage {
            message: ".foo { color:red; }".to_string(),
            tx: tx.clone(),
          },
          ThreadsafeFunctionCallMode::Blocking,
        );
        let ret = rx
          .recv()
          .unwrap_or_else(|e| panic!("recv error: {:?}", e.to_string()));
        ret
      });
      deferred.resolve(move |env| match ret {
        Ok(s) => env.to_js_value(&s),
        Err(e) => Err(std::convert::From::from(e)),
      });
      Ok(())
    },
    move |&mut _, _res| Ok(_res),
  )?;
  Ok(promise)
}

struct ReadMessage {
  pub message: String,
  pub tx: Sender<Result<String>>,
}
```

参考：  
[https://napi.rs/docs/concepts/threadsafe-function](https://napi.rs/docs/concepts/threadsafe-function)  
[https://github.com/parcel-bundler/lightningcss](https://github.com/parcel-bundler/lightningcss)
