---
title: "506 - 《TNF，我理解的下一代框架》"
date: 2024-12-31
url: https://sorrycc.com/tnf-the-next-framework
---

发布于 2024年12月31日

# 506 - 《TNF，我理解的下一代框架》

> TNF 陆陆续续写了快两个月，和大家正式介绍下他。

1、TNF 的由来。

TNF 全称 The Next Framework，是我理解的下一代前端框架。Github 地址是 [https://github.com/umijs/tnf](https://github.com/umijs/tnf) 。

![](https://tcc.sorrycc.com/p/776c2e49-fec4-4db7-b9c4-2274c31b25e6.png)

Umi 从 3 到 4，路由是个很大的痛。当时没啥选择，由于 React Router 的新功能用了 React Router 的新版本，但 React Router 新版本存在不少 break change（比如 history 和 search query 等），导致大家在升级时需要在这部分投入大量的时间。我们也投入了大量时间写这部分的 code mode 脚本来辅助项目升级。

这之后，就一直想把路由换了，要么手写，要么社区有更合适的方案。手写成本太高，一直没投入。直到 10 月底看到 @tanstack/router，觉得就是他了。

当时记录的优点如下。

1）性能，preload、load、load 和 component 代码分离、内置 mini 版 react query 所以有路由级的 stale while revalidate  
2）TypeScript Safe  
3）扩展能力极好，可编程式扩展，所以对框架开发者友好  
4）除了 router，与 router 相关的 ssr（流和非流）、loader 等方案的 runtime 层也都有  
5）有配套的工程化方案，比如针对约定式路由的 generator、runtime devtool、tsr 命令行等  
6）功能相比 react-router 强大很多，场景考虑很全  
7）search 是第一公民，无需自己手动 new UrlSearchParams

这个路由方案是催生我写 tnf 的一大原因。

2、TNF 是什么。

Umi 大而全，我希望 TNF 是小而美的。保持内核的精简，然后把每个功能都做到极致。

![](https://tcc.sorrycc.com/p/49f2efca-2c02-460f-88bf-970914941158.png)

开始做 TNF 时脑暴了 24 个关键词，最终做到现在感觉可以成为卖点或者说和已有框架不同的有这些。

*   性能优先（产品体验 UX）
*   AI 友好（以及 Chat 功能）
*   插件体系、组装式和生态友好（兼容 unplugin 和 Vite）
*   CSR 是一等公民（考虑国内的现状，CSR 本应很简单）
*   安全（TypeScript 类型安全、路由类型安全、可独立运行的 Doctor 和规则）

其他我有记但感觉略显薄弱的还有这些。

*   迭代后更强大的路由（依赖 @tanstack/router）
*   速度（不仅构建，前序操作也会用 Rust 处理重 CPU 的任务）
*   最佳实践迭代（国际化、测试、Mock、数据流、微前端等）
*   跨端（？）

TNF 目前提供的命令包括基础的 dev、build、preview，增量生成文件的 generate，预生成临时目录的 sync（类似之前的 umi setup），还有操作配置的 config，以及可独立运行的 doctor 。构建器目前是 mako only；功能层 ant design pro 需要的都有，mock、proxy、国际化、微前端等，我们有用 tnf 的方式[重新组织了 ant design pro](https://github.com/umijs/tnf-ant-design-pro)，功能完整但体验更好一些。

3、产品性能。

如在[《前端，本应更快》](https://yuque.antfin.com/yunqian/write/hhgyipocpo6ivv3n#zoz0k) 中描述的，产品性能好无非四个点，产物尺寸、下载尺寸、请求策略和渲染性能。

产物尺寸和下载尺寸略，参考 [《前端，本应更快》](https://yuque.antfin.com/yunqian/write/hhgyipocpo6ivv3n#zoz0k) 。

请求策略 TNF 依赖 @tanstack/router 有完整功能的基于路由的 preload 和 stale-while-revalidate，这是 CSR 场景下目前社区最好的方案。如果按照推荐的方式写数据请求，CSR 下可以做到 assets（js & css）和请求在初始化载入和切换时的并发最大化和无瀑布流。

以下是 tnf with ant-design-pro 的效果图，别点太快的话，基本就告别 loading 状态了。

![](https://tcc.sorrycc.com/p/986facc3-274f-4faa-a497-ff950fe7b614.gif)

基于路由做请求策略的方案很重要。之前有同学问，Umi 增强后的 prefetch + client loader + 手写 [swr](https://github.com/vercel/swr) 或 [@tanstack/query](https://tanstack.com/query/latest) 是否也能达到类似效果？答案是不能，只能做到 60% - 70%。差在哪里？「没有基于路由的 stale-while-revalidate」。勉强实现的方式是正常用 swr 或 @tanstack/query 的 hook，然后在 loader 里做 prefetch，这里会存在大量的硬编码和耦合，维护成本会变高。

渲染性能主要是减少不必要的 re-render，TNF 做了这些。

1）接入 react scan 检测不必要的 re-render  
2）接入 react compiler 减少不必要的 re-render（compiler 只有 babel 版本，通过自定义 loader 接的 mako）  
3）国际化方案用了性能更友好的 react-i18next，相比现在的 react-intl，性能相关的优点是前者支持国际化文件的按需加载

4、AI。

> 大家都可以产出 react + antd 的代码，但是如何产出地质量高、可维护性好、CLEAN、采用率高呢？

TNF 作为一个前端框架，应如何做好和 AI 的结合？

我理解 ai 应用就是 model + prompt + tools。合适的模型，搭配合适 prompt，在加上满足各种定制化需求的 function tools，就是现在大多 ai 服务的公式。

AI 应用于前端也不例外。model 对外可以选最先进的 Claude 3.5 Sonnet、O1 或新出的 DeepSeek V3，对内的敏感项目可选内部的模型或者通义千问。prompt 包含你的要求，以及让 AI 对你的项目和最佳实践的理解。tools 除了通用的还应有前端或框架特有的精确操作，比如安装依赖、修改配置等。

model 层前端框架做不了啥，另外两个还是有不少能做的。1）prompt，可提供详细的项目描述、最佳实践、框架文档、三方库文档等，让 model 充分懂你的项目。2）tools，除了提供通用能力（fs 等）、前端通用能力（npm client、node 等），还可提供框架特有能力（config、generate、routes 等）。

上一条里，更重要的是 prompt 的部分。好的 prompt 可以让 model 更懂项目，这很重要。AI 提效的一个关键是采用率。如果有 AI 辅助，但他生成给你的大多是你不想要的，这对于研发效率来说就可能是个反作用了。

应用场景有几种，AI Editor（Cursor、VSCode + Github Copilot、Windsurf 等）和 Agent（Devin、[cali](https://github.com/callstackincubator/cali)、@umijs/ai 等）。前者可以利用框架提供的 prompt，后者可以利用框架提供的 prompt + tools。

TNF 目前做了这些，

1）在 .tnf 临时目录下提供 docs 目录（参考 Devin 改成 knowledge 会不会更合适），包含项目介绍、最佳实践、tnf 自身文档、重要依赖（mako、tanstack routes 等）文档。  
2）针对 cursor 编辑器提供 .cursorrules 文件。  
3）提供 tools，目前包含对 build、config、sync、generate、doctor 命令的封装。  
4）提供了 @umijs/ai（可能改个名，不带 umijs 前缀），参考 [493 - 《Umi AI》](https://sorrycc.com/umi-ai)，一个前端开发的通用 agent，但目前还没和 TNF 做集成。

TODO 的有这些，

1）提供 tnf chat 命令，确认后自动安装 @umijs/ai 依赖，然后继续，提供 chat 能力，让用户可以用自然语言和项目进行交互，比如「enable react scan」等  
2）完善 prompt，补充更规范的项目描述（尝试集成 ai-digest）、补充更全的最佳实践文档（比如国际化、微前端、数据流等）、添加工程化文档（prettier、eslint、husky 等）、更多框架文档（错误码、FAQ 等）、三方库文档（随依赖按需引入，感觉这是通用需求，可以考虑做成通用库）  
3）提供常见任务的 prompts 集

试过用 Devin 和 Cursor 基于这一套（主要是 Prompt）生成新的 Page，产出质量还是挺高的，准确、符合代码拆分要求、Clean 架构、配套的 Mock 数据等。Devin 的见 [PR](https://github.com/test-devin/test-devin-tnf/pull/1)，Cursor 的效果更好一些，见下图。

```bash
# Cursor Chat
based on @docs , please add a todos page, including page, components, mock, services and hooks if need
```

TODO：20M 的图：。

5、组装式。

熟悉 Umi 的朋友们都知道 Umi 有 runtime 插件，用户在其中 export 方法即可扩展 Umi 内部的功能。用户只管定义 Hook，然后交给框架来决定这些 Hook 在什么时候被执行。

```ts
export function rootContainer() {}
export function render() {}
export function getInitialState() {}
```

这种方式的优点是简单，缺点则是黑盒，这也是之前 Umi 被反馈比较多的点。最近一段时间没怎么看 Umi，我甚至都一时想不起 rootContainer 和 render 的区别是啥。。在我的设想里，下一代的框架应该是组装式的，让开发者通过搭“积木”的方式搭出应用，而不是配出应用。

以 qiankun 为例，qiankun 插件有 runtime、插件本体等。尤其是 runtime 的处理，是通过把 qiankun 的 runtime 写到临时目录，同时处理依赖引用为绝对路径，在添加 export 到 umi，然后开发者才可以引用，比如 `import { MicroApp } from 'umi'`。TNF 组装式的实现则是这样，1）提供 @umijs/tnf-qiankun 的包，包含两部分，插件和 runtime，2）用户通过 `import { MicroApp } from '@umijs/tnf-qiankun'` 来使用 runtime 的部分。

以此类推，tnf 大部分非核心的扩展功能都会如此，比如 tailwindcss、antd 辅助、国际化等功能，提供一个额外的 @umijs/tnf- 前缀的包。好处是轻黑盒，更少黑科技（import from umi、绝对路径依赖等），和框架层少耦合，用户按需使用。缺点是用起来略繁琐，但感觉这个权衡是值得的。

tnf 里有个功能，是约定 `src/client.tsx` 如果存在，则会作为用户的 client 入口，把入口的能力全部交给用户，然后在这个文件里，用户可以使用框架内部提供的路由等能力。当然，也可以不使用。

```tsx
import { createRouter } from '@umijs/tnf/router';
import { Client } from '@umijs/tnf/ssr';

export function createClient() {
  const router = createRouter({ ... });
  return {
    Root: function Root() {
      return <Client router={router} />;
    },
  };
}
```

6、插件和生态。

做 TNF 之前我在考虑三鱼合一的事。由于直接做新框架替换三鱼的成本太高，短期应该做不了。所以退而求其次做 Fishkit，提供一套写框架的框架或 SDK，可参考的竞品是 [vinxi](https://github.com/nksaraf/vinxi) 和 [nuxt 仓库的 un 系列](https://unjs.io/packages?q=&order=1&orderBy=title)。Roadmap 是先有 [Fishkit](https://yuque.antfin.com/yunqian/private/cxbcigt69h4l5dqp)，然后大家基于 kit 研发，作为下一代框架的基础。再提升 kit 在框架的覆盖率之后，最后统一三鱼和开发下一代框架就顺理成章。

那 Fishkit 怎么切入三条鱼？思考后觉得以插件为切入点是比较合适的方式。所以有了 [funplugin](https://yuque.antfin.com/yunqian/private/al5f6ug1xkmbidzd)，意为 Fish Universe Plugin。框架之间需要一个统一的插件层。在尚不能统一框架的当下，用一个统一的插件层，来兼容不同框架的插件，以实现框架无关的插件层，减少不必要的维护成本和框架迁移的成本。

Funplugin 提供一个 createFunplugin 的 API，用于创建插件。除了通用的 hooks 之外，还提供了特殊场景下的出逃口子，可补充每个框架特有的 hooks。

```ts
import { createFunplugin } from '@umijs/funplugin';
const unplugin = createFunplugin((options) => {
  return {
    name,
    enforce: 'pre',
    // General Hooks
    ...hooks,
    // Framework Specified Hooks
    umi: {},
    smallfish: {},
  };
});
```

他会返回 `{ umi, smallfish, minifish, … }`，可传给这些框架作为插件使用。比如 Umi 框架的。

```ts
export default {
  plugins: [
    createFunplugin().umi,
  ],
};
```

TNF 的[插件体系](https://github.com/umijs/tnf/blob/master/docs/plugin.md)是 funplugin 的实践者。还有不少 Hook 和 Context 待实现，整体设计更接近 rollup 的风格。采用这种风格也是为了尽量兼容 Vite 插件。因为感觉 Webpack 虽然依旧占据市场大多数，但其生态是向下走的趋势。按目前的趋势来看，Vite 的生态会越来越好，很多框架都是 vite + 插件的实现方式。尤其是未来 rolldown 出来之后。现在社区新的元框架本质上都是一个 Vite 插件，比如 sveltekit 新版本就[只留了一个 sync 命令](https://github.com/sveltejs/kit/blob/main/packages/kit/src/cli.js#L27)，剩下的都是 Vite 插件。

7、试试。

```bash
$ pnpm create tnf
```

![](https://tcc.sorrycc.com/p/073d160a-9421-4f3c-843d-cbfc8cc1a3be.gif)
