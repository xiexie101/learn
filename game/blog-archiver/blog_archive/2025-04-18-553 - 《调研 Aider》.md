---
title: "553 - 《调研 Aider》"
date: 2025-04-18
url: https://sorrycc.com/aider
---

发布于 2025年4月18日

# 553 - 《调研 Aider》

> 接着调研又一个 Code Agent 工具，这应该是目前最成熟的一个，花了我好多时间来看。

1、介绍。

Aider 是又一个 Code Agent CLI，基于 Python 实现。

特性。

*   **browser 模式**，通过 `--browser` 开启
*   **集成 Git**，可以做 commit
*   **Architect 模式**，可以使用两个不同的模型来完成每个编码任务：一个 “Architect 模型” 负责描述如何解决编码问题，一个 “Editor 模型” 将 Architect 的提议转化为具体的代码编辑。
*   **代码 Linting 和测试**，默认情况下，每次编辑文件后都会运行内置的 linter，并在发现语法错误时提供修复建议，支持多种语言
*   **模型别名**，比如 3 表示 gpt-3.5-turbo，sonnet 表示 claude-3-5-sonnet-20240620 等，可以在 `.aider.conf.yml` 中自定义
*   **无限输出**，对于支持 prefill 的模型，比如 Claude 3.5 Sonnet、DeepSeek Coder 和 Mistral，可以绕过模型限制，生成非常长的回复
*   **提示缓存**，对于支持 Prompt Cache 的模型，比如 Anthropic 的 Sonnet 和 Haiku、DeepSeek 的 Chat，开启后可以节省成本并加快编码速度
*   **与 IDE/编辑器的集成**，Aider 的 --watch-files 模式可以任何 IDE 或编辑器集成，注释里带 AI、AI! 或 AI? 的都会被识别
*   **Slash 命令**，可以用以 `/` 开头的命令来执行各种操作
*   **语音输入**，基于 [portaudio](https://www.portaudio.com/) 录音然后调用 OpenAI 的 Whisper 接口转文本
*   **Docker 运行**，处于安全考虑

快速上手。

```bash
brew install portaudio
uv pip install --system aider-chat boto3
aider
```

![](https://cdn.jsdelivr.net/gh/sorrycc-bot/images@main/uPic/7l2Cvj.png)

命令行参数。

*   模型和密钥
    *   `--model <模型名称>`，指定 LLM 模型，可以用完整的模型名称，也可以用别名
    *   `--api-key <提供商>=<密钥>`，提供密钥，比如 `aider --model deepseek --api-key deepseek=YOUR_DEEPSEEK_API_KEY`（注：通过环境变量比如 OPENAI\_API\_KEY 也有效）
    *   `--list-models <部分模型名称>`，列出和名称匹配的模型，比如 `aider --list-models turbo`
*   浏览器模式
    *   `--browser`，启用 浏览器 UI
*   架构模式
    *   `--architect`，启用架构模式，使用两个不同的模型完成编码任务：一个 Architect 模型负责描述解决方案，一个 Editor 模型将提议转化为代码编辑
    *   `--editor-model <模型名称>`，在 Architect 模式下指定用于生成具体文件编辑指令的 Editor 模型
*   Lint 和测试
    *   `--lint`，运行代码 linter 并尝试修复错误
    *   `--lint-cmd <命令>`，配置要使用的自定义代码 linter 命令
    *   `--test`，运行测试命令并尝试修复失败的测试
    *   `--test-cmd <命令>`，配置要使用的自定义测试命令
*   配置类
    *   `--config-file <文件路径>`，指定 YAML 配置文件路径，默认会找 `.aider.conf.yml` 文件
    *   `--model-settings-file <文件路径>`，指定包含模型特定设置的文件路径. 默认是 `.aider.model.settings.yml`
    *   `--model-metadata-file <文件路径>`，指定包含模型元数据（如上下文窗口大小和成本）的文件路径. 默认是 .aider.model.metadata.json
    *   `--alias <别名定义>`，在命令行中定义模型别名. 例如，aider --alias “fast:gpt-4o-mini”. 可以在配置文件中定义更持久的别名
    *   `--editor <编辑器命令>`，指定要与 /editor 命令一起使用的文本编辑器
    *   `--line-endings <类型>`，设置文件写入的行尾格式
    *   `--map-tokens <tokens>`，为存储库映射设置令牌预算
    *   `--subtree-only`，将 Aider 限制在当前目录子树中，这有助于处理大型代码库
    *   `--watch-files`，启用文件监视模式，Aider 将监视源文件的更改，并响应你在代码注释中添加的指令
*   GIT 相关
    *   `--attribute-commit-message <前缀>`，为所有提交消息添加一个前缀
    *   `--no-git`，在没有 git 仓库的情况下运行 Aider
*   其他略

子命令，以 `/` 开头，用于执行特定操作。

*   **`/add`**: 添加文件到聊天会话
*   **`/architect`**: 进入 **architect/editor 模式**，该模式利用两种不同的语言模型. 一个 architect 模型描述如何解决编码问题，而一个 editor 模型将该提案转换为特定的文件编辑
*   **`/ask`**: 切换到 **ask 模式**，在该模式下，它将讨论你的代码并回答有关代码的问题，但不会对文件进行任何更改
*   **`/chat-mode`**: 切换到新的聊天模式，可选 `code`、`architect`、`ask` 和 `help`
*   **`/code`**: 切换回 **code 模式**，在该模式下，它将修改你的代码
*   **`/drop`**: 从聊天会话中删除文件，用于释放上下文空间
*   **`/edit`**: /editor 命令的别名
*   **`/editor`**: 打开你配置的文本编辑器，以便你可以编写更广泛或更复杂的提示. Aider 将等待你关闭编辑器后再继续。可以使用 `--editor` 命令行参数、`AIDER_EDITOR` 环境变量或 `.aider.conf.yml` 文件中的 `editor:` 设置来配置编辑器
*   **`/editor-model`**: 在 architect 模式下切换 **Editor Model** 到一个新的语言模型.
*   **`/exit`**: 退出 Aider
*   **`/git`**: 运行 git 命令
*   **`/help`**: 你可以询问有关使用 Aider、自定义设置、故障排除、使用 LLM 等问题
*   **`/lint`**: **lint 并修复**已添加到聊天中的所有文件
*   **`/load`**: 从指定文件中加载并执行一系列命令
*   **`/ls`**: 列出当前聊天会话或存储库中的文件
*   **`/model`**: 切换主语言模型
*   **`/read`**: 将**文件的内容读取**到聊天上下文中，这些文件通常标记为只读，可以来自文件系统上的任何位置，包括 git 存储库外部
*   **`/reasoning-effort`**: 对于支持此功能的模型（如 o3-mini 和 Grok 3 Mini），此命令允许你**控制模型的推理水平**
*   **`/run`**: 用于**运行 shell 命令**，接受完整的 shell 命令，`!` 是此命令的别名
*   **`/save`**: 此命令将**创建一个包含 `/add` 和 `/read-only` 命令的文件**，该文件可用于在以后的聊天会话中重新创建当前文件上下文
*   **`/settings`**: 此命令用于**显示活动的 Aider 设置**.
*   **`/test`**: 运行测试命令并尝试修复
*   **`/think-tokens`**: 对于支持思考令牌的模型（如 Sonnet），此命令允许你**设置思考令牌预算**，可能使用人类可读的格式（例如，8k，0.5M）
*   **`/tokens`**: 报告上下文窗口的令牌使用情况
*   **`/undo`**: 撤消 Aider 所做的最后一次更改，可以多次使用
*   **`/voice`**: 使用语音输入
*   **`/web`**: 抓取 URL 的内容，将其转换为 Markdown 并添加到聊天中，你也可以直接将 URL 粘贴到聊天中
*   **`/weak-model`**: 指定用于提交消息和聊天历史记录摘要等任务的模型
*   **`/clear`**: 清除对话历史记录
*   **`/clipboard`**: 将图像或文本从剪贴板粘贴到聊天中
*   **`/copy-context`**: 将当前代码上下文复制到剪贴板
*   **`/diff`**: 调用 `git diff` 以显示所做的更改，使用你首选的 diff 工具
*   **`/context`**: 自动识别给定请求需要编辑哪些文件

2、实现。

1）watch 模式。

主要代码在 `watch.py`。流程是这样，后台线程监视文件 -> 检测到变化 -> `filter_func` 检查（gitignore + AI 注释）-> 如果通过，记录变化文件并中断用户输入 -> `process_changes` 被调用 -> 自动添加文件 -> 根据 `ai!`/`ai?` 选择提示 -> 提取所有 AI 注释及上下文 -> 生成最终提示 -> 发送给 LLM。

两个相关提示词，`!` 用前者，`?` 用后者。

```
I've written your instructions in comments in the code and marked them with "ai"
You can see the "AI" comments shown below (marked with █).
Find them in the code files I've shared with you, and follow their instructions.

After completing those instructions, also be sure to remove all the "AI" comments from the code too.
```

```
/ask
Find the "AI" comments below (marked with █) in the code files I've shared with you.
They contain my questions that I need you to answer and other instructions for you.
```

2）Voice 模式。

主要代码在 `voice.py`。流程是这样，Voice Mode 通过 `sounddevice` 录制音频，使用 `queue` 缓冲数据，通过 `prompt_toolkit` 提供交互式录音提示，用 `soundfile` 和 `pydub` 处理音频文件，最后调用 `litellm` (Whisper API) 进行转录，并将结果插入到用户的下一个输入提示中。

3）Prompt Cache 。

Aider 的 Prompt Cache 通过在发送给 LLM 的消息中添加特殊的 `cache_control` 头部来工作，比如 `cache_control: {"type": "ephemeral"}` 。它标记了提示中相对静态的部分（如系统指令、文件内容、仓库地图），让支持此功能的 LLM 提供商（如 Anthropic）可以缓存这些部分。当后续请求包含相同的可缓存部分时，提供商可以直接使用缓存，从而节省令牌和成本。可选的缓存预热功能可以帮助保持缓存的有效性。

通常，系统提示 (system)、示例 (examples)、仓库地图 (repo) 和只读文件 (readonly\_files) 以及聊天文件 (chat\_files) 的内容块会被标记为可缓存。

还有个 Cache Warming 的功能。如果开启（通过 `--cache-keepalive-pings` 参数），会启动一个后台线程 (`warm_cache_worker`)，定期（默认约 5 分钟）将可缓存的消息部分 (`chunks.cacheable_messages()`) 发送给 LLM，请求非常短的响应（`max_tokens=1`）。这有助于保持 LLM 提供商端的缓存处于活动状态，以便在用户实际发送提示时能够命中缓存。

计算 token 时通过 `prompt_cache_hit_tokens` 或 `cache_read_input_tokens` 和 `cache_creation_input_tokens` (或 `cache_write_input_tokens`) 等字段，更准确地计算实际消耗的令牌数和相应的成本，区分缓存命中、缓存写入和实际发送的 token 。

> 再多说下 Prompt Cache。OpenAI 内置带了 Prompt Cache 功能，无需手动配置 header，只要，1）把静态内容放最前，注意：要静态！要静态！要静态！千万不要在 SYSTEM PROMPT 里写动态内容，顺序可以是这样，「System prompt → 工具定义 → RAG 背景 → 用户最新输入」，2）TOKEN 要 >= 1024，因为总输入 ≥ 1024 tokens 时才开始缓存；之后以 **128 token** 为步长继续缓存。然后，未再次访问 5‑10 min 会逐出；最晚 1h 清空。

4）Architect 模式。

Aider 的 `architect` 模式实现了一种两阶段的代码生成方法。首先，主模型（架构师）根据用户请求和代码上下文，生成一份高级的修改计划和指令，但不直接编写代码。然后，这些指令被传递给一个独立的编辑器模型，该模型负责根据指令生成并应用具体的代码更改。这种分工允许架构师专注于设计，编辑器专注于实现，旨在提高处理复杂代码修改任务的能力和准确性。

实现层是这样。1）ArchitectCoder（来自 `coders/architect_coder.py`）基于 `aider/coders/architect_prompts.py` 里的 ArchitectPrompts 引导 LLM 扮演架构师的角色，要求 LLM 分析用户的请求和现有代码，然后提供清晰、完整的修改指令给 「Editor」，并且明确指示不要输出完整的代码块，只需描述如何修改，2）在 `reply_completed` 中，基于 editor\_model 和 editor\_edit\_format 创建一个新的 Coder，基于 editor\_edit\_format 可能是 `EditorDiffFencedCoder`、`EditorEditBlockCoder` 或 `EditorWholeFileCoder`，然后把 ArchitectCoder 返回的消息传给他做实际的代码编辑。

提示词如下。

```
Act as an expert architect engineer and provide direction to your editor engineer.
Study the change request and the current code.
Describe how to modify the code to complete the request.
The editor engineer will rely solely on your instructions, so make them unambiguous and complete.
Explain all needed code changes clearly and completely, but concisely.
Just show the changes needed.

DO NOT show the entire updated function/file/etc!

Always reply to the user in {language}.
```

5）编辑模式。

Aider 有几种编辑模式，分别是 `diff`、`editblock` 和 `wholefile`。

`diff` 模式会要求大模型以类似于 `diff -U0` 命令产生的统一差异格式（Unified Diff Format）输出变更。通过在变更行的前面加上 `-`（表示删除）或 `+`（表示添加）来标示具体的修改内容。Aider 使用的 `diff -U0` 变体省略了行号，并且上下文行数（`-U` 后面的数字）通常设置为 0 或一个较小的值，以减少冗余信息。其缺点是「脆弱性」和「LLM 生成难度」，原始文件在生成 `diff` 后发生了微小变化（即使是空格或空行），就会导致上下文或要删除的行无法精确匹配，`diff` 应用就会失败。

`editblock` 模式。它使用一种特殊的「搜索/替换」块格式来指示需要进行的更改，格式如下。缺点是「冗长」和「复杂修改困难」。对于涉及多处修改或大型重构的任务，LLM 需要生成多个 `editblock`，管理起来比较复杂，也容易出错。`editblock` 还有个 `editblock-fenced` 的变体。别在于它使用代码围栏（如 `python …` ）将整个搜索替换块包围起来，格式要求更严格一些。

```
<<<<<<< SEARCH
# 要查找和替换的原始代码行
=======
# 替换后的新代码行
>>>>>>> REPLACE
```

`wholefile` 模式。要求 LLM 返回需要修改的**整个文件**的**完整最终内容**，然后用 LLM 返回的文件内容覆盖掉原始文件的内容。缺点是「Token 消耗大」和「可能因为上下文无法容纳而部分丢失或产生幻觉」。适用于创建新文件、对文件进行大规模重构或修改等场景。

6）Assistant Prefill 。

Assistant Prefill 或者叫 prefix caching，是用来实现模拟“无限”输出上下文窗口的技术。当检测到模型因为达到最大输出 token 而停止生成时，Aider 会捕获已生成的部分内容，并将其作为 assistant role 的“预填充”信息包含在下一个发送给模型的请求中。这使得模型能够从中断处继续生成，Aider 则负责将所有部分响应无缝拼接，从而允许生成远超单次调用限制的、非常长的代码或解释，实现了类似“无限输出”的效果。

实现关键点在位于 `aider/coders/base_coder.py` 的 `send_message` 方法中。捕获 `FinishReasonLength` 异常，如果模型支持预填充，则使用 `get_multi_response_content_in_progress()` 获取当前已接收到的所有部分响应，更新 `messages` 列表，将捕获到的部分响应添加到最后一个 `assistant` 角色的消息内容中。循环继续，直到 LLM 没有抛出 `FinishReasonLength` 为止。Aider 随后会将所有接收到的部分响应拼接在一起，形成一个完整的、连贯的最终响应。

7）GIT 功能集成。

Aider 还是做了不少和 GIT 相关的功能。

*   初始时，会检测是否为 git 仓库，不是的话会建议做初始化，并检测 [user.name](http://user.name) 和 user.email 的配置情况
*   使用 `repo.git.ls_files()` 或遍历 `repo.head.commit.tree` 来获取 Git 跟踪的文件列表
*   使用 `repo.ignored()` 检查文件是否被忽略，支持 `.gitignore` 和 `.aiderignore`
*   如果 `.aider*` 或 `.env` 文件未被忽略，它会询问用户是否将其添加到 `.gitignore`
*   在 LLM 提出代码更改并应用这些更改后，如果 `auto_commits` 选项启用 (默认启用)，Aider 会自动提交这些更改，并且支持 `--no-verify` 选项跳过 commit hook
*   使用 `repo.git.diff()` 生成差异，可以生成工作目录与 HEAD 之间的差异、暂存区与 HEAD 之间的差异，或两个提交之间的差异，用于向 LLM 提供上下文以生成提交消息
*   `/undo` 命令允许用户撤销由 Aider 在当前会话中进行的最后一次提交，通过检查最后一次提交的哈希值是否在 Aider 记录的提交哈希集合中来实现，使用 `git reset --soft HEAD~1` 将 HEAD 移回上一个提交，并使用 `git checkout HEAD~1 -- <file>` 来恢复被更改的文件

COMMIT PROMPT 如下。

```
You are an expert software engineer that generates concise, \
one-line Git commit messages based on the provided diffs.
Review the provided context and diffs which are about to be committed to a git repo.
Review the diffs carefully.
Generate a one-line commit message for those changes.
The commit message should be structured as follows: <type>: <description>
Use these for <type>: fix, feat, build, chore, ci, docs, style, refactor, perf, test

Ensure the commit message:
- Starts with the appropriate prefix.
- Is in the imperative mood (e.g., \"add feature\" not \"added feature\" or \"adding feature\").
- Does not exceed 72 characters.

Reply only with the one-line commit message, without any additional text, explanations, \
or line breaks.
```

8）Browser 模式。

Aider 的浏览器模式基于 Streamlit 框架实现。他将核心 `Coder` 逻辑包装在一个 Streamlit 应用中，利用 Streamlit 的缓存和状态管理来维持会话，并使用其 UI 组件来提供交互式界面。

当你运行 `aider --gui` 或 `aider --browser` 时，`aider/main.py` 会解析参数，并调用 `streamlit.web.cli.main()` 来启动一个 Streamlit 应用。这个应用的入口点是 `aider/gui.py` 文件。

9）一些有用的其他功能。

*   **Message 长度管理。**`history.py` 里的 `ChatSummary` 是做这件事的。他通过智能地用 LLM 生成的摘要替换掉聊天记录中较早的部分，来动态地缩减聊天记录的长度，同时尽量保留最近的交互细节，确保整个对话历史能够适应 LLM 的上下文窗口大小限制。
*   **粘贴板监听。** `copypaste.py` 里的 `ClipboardWatcher` 通过后台线程定期检查剪贴板内容。并将新的剪贴板内容设置为输入提示的 placeholder，方便用户直接使用粘贴的内容作为输入。

10）依赖情况。

*   **LLM 交互和模型管理:**
    *   `litellm`: 与各种大型语言模型（LLMs）交互的核心库。它提供了一个统一的接口来调用 OpenAI、Anthropic、Google Gemini、Bedrock、Ollama、OpenRouter 等多种模型的 API。
    *   `openai`: OpenAI 官方 Python 客户端库，用于直接与 OpenAI API 交互（如果 `litellm` 底层需要）。
    *   `anthropic`: Anthropic 官方 Python 客户端库，用于直接与 Anthropic API 交互（如果 `litellm` 底层需要）。
    *   `google-generativeai`: Google 官方 Python 客户端库，用于与 Gemini 模型交互。
    *   `boto3`: AWS SDK for Python，用于与 AWS Bedrock 上的模型交互。
    *   `packaging`: 用于解析和比较版本号。
*   **Git 版本控制集成:**
    *   `GitPython`: 用于与本地 Git 仓库进行交互，实现自动提交、差异比较、获取跟踪文件列表等功能。
*   **文件和代码处理:**
    *   `pathspec`: 用于解析 `.gitignore` 和 `.aiderignore` 文件中的模式，以确定哪些文件应该被忽略。
    *   `diff-match-patch`: Google 的库，用于计算文本差异并应用补丁，是某些编辑格式（如 `udiff`）的基础。
    *   `grep-ast`: 用于解析代码文件，提取代码结构（如函数、类定义）以构建仓库地图（Repo Map）和支持代码分析。
    *   `pygments`: 用于在终端输出中对代码进行语法高亮。
    *   `PyYAML` / `pyyaml`: 用于解析 YAML 格式的配置文件（`.aider.conf.yml`）和模型设置文件。
    *   `json5`: 用于解析可能包含注释的 JSON5 格式的模型元数据文件。
*   **命令行界面 (CLI) 和用户交互:**
    *   `prompt_toolkit`: 提供强大的交互式命令行界面，支持历史记录、自动补全、Vi/Emacs 编辑模式等。
    *   `rich`: 用于在终端中创建美观、格式化的输出，包括颜色、表格、Markdown 渲染等。
    *   `python-dotenv`: 用于从 `.env` 文件加载环境变量，方便管理 API 密钥等敏感信息。
    *   `configargparse`: 扩展了 `argparse`，允许从配置文件和环境变量加载命令行参数。
    *   `pyperclip`: 用于与系统剪贴板交互，支持 `/copy` 和 `/paste` 命令。
*   **Web 功能 (可选):**
    *   `requests`: 用于发出 HTTP 请求，例如检查 Aider 更新或通过 `/web` 命令抓取网页内容（作为备用方案）。
    *   `playwright`: 一个强大的浏览器自动化库，用于 `/web` 命令，可以执行 JavaScript 并获取动态加载的内容。
    *   `beautifulsoup4`: 用于解析 HTML 内容。
    *   `pypandoc`: 用于将 HTML 转换为 Markdown。
    *   `streamlit`: 用于运行 Aider 的图形用户界面（GUI）模式 (`--gui` 或 `--browser`)。
*   **语音输入 (可选):**
    *   `sounddevice`: 用于录制音频。
    *   `soundfile`: 用于读写音频文件。
    *   `pydub`: 用于音频格式转换（如 WAV 转 MP3）。
*   **交互式帮助 (可选):**
    *   `llama-index-embeddings-huggingface`: 用于 `/help` 命令，提供基于文档的问答功能。
    *   `networkx`: 用于构建和分析仓库地图中的代码依赖关系图。
    *   `diskcache`: 用于缓存代码标签（tags），加速仓库地图的生成。
*   **其他:**
    *   `watchfiles`: 用于 `--watch-files` 功能，监控文件系统变化。
    *   `pillow`: 用于处理图像，例如 `/paste` 命令粘贴剪贴板中的图像。
    *   `importlib_resources`: 用于访问包内的数据文件（如默认模型设置）。

3、基准测试。

[https://github.com/exercism/python/tree/main/exercises/practice/accumulate](https://github.com/exercism/python/tree/main/exercises/practice/accumulate)

3、感受。

*   Aider 应该是社区最成熟的 Code Agent CLI 了，功能上也最丰富，而且支持任意模型

参考：  
[https://github.com/Aider-AI/aider](https://github.com/Aider-AI/aider)  
[https://aider.chat/](https://aider.chat/)
