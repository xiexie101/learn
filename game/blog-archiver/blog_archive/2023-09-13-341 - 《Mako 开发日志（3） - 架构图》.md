---
title: "341 - 《Mako 开发日志（3） - 架构图》"
date: 2023-09-13
url: https://sorrycc.com/mako-devlog-03
---

发布于 2023年9月13日

# 341 - 《Mako 开发日志（3） - 架构图》

![](https://img.alicdn.com/imgextra/i3/O1CN01FQBVrz1qQTHN5MgxF_!!6000000005490-2-tps-1690-1680.png)

昨天（2023.9.12）下午应要画了 Mako 的架构图，做下介绍。

1、整体架构和 Farm 比较像，做的过程中较多地参考了 Farm。当然，和 Farm 也还是有不少不同的。作为构建方案的后来者，团队同学在做的过程中会不自觉地同时参考 webpack、Farm、rspack、esbuild 等前辈。同时我们搞了个实例仓库，可以一键验证同一份代码在多个不同构建工具下的效果。

2、整体编译分 Build、Generate 和 Update。Build 主要任务是编译和解析文件，生成 Module Graph；Generate 是真正复杂的部分，Tree Shaking、Code Splitting、HMR、Runtime、Scope Hoisting 等均在这个环节完成；Update 即热更，如果说 Generate 是硬复杂，Update 则是软复杂，这里的细节和边界场景非常多。

3、做一些功能层的解释。

1）Tree Shaking 参考 [340 - 《Tree Shaking 原理》](https://sorrycc.com/tree-shaking-principle)。

2）Code Splitting 也挺复杂的，评估做得好不好有两个重要维度，重复度和缓存命中率。重复度指一个模块尽量不要出现在多个 Chunk 里，如果存在重复，可能还会导致一些额外问题，比如多实例，比如尺寸增加会导致构建时间的增加。缓存命中率指每次构建之后如何尽量少地更新 Chunk，让用户的浏览器里利用尽量多的缓存文件，基于此，就应该做比如把一些非常稳定的依赖合到一起，他们很少变，每次发布后使用时用老的缓存文件，对于用户来说就能提速。此外，mpa（多页应用）和 spa（单页应用）的 Code Splitting 在实现上是两套逻辑。参考 [202 - 《Umi 最佳实践：拆包策略》](https://sorrycc.com/umi-best-practise-code-splitting)。

3）HMR 和 Update。除了 HMR 本身设计 Runtime 和 Compile 两部分的实现，比较复杂之外，这部分更多考研的是细活，有很多边界场景都会影响 DX，这也是很多新的构建工具没有做好的地方。比如先 import 文件再创建文件的场景，比如 SourceMap 的更新问题，比如 Fast Refresh 的识别逻辑问题，比如 Resolve 文件识别后的恢复问题，比如报错展示和恢复问题，比如 Update 阶段如何利用缓存解决性能问题，等等。

4）Constant Folding，常量折叠。比如如下的这段代码，在 production 时就不应该引入 ./cjs/react.development.js 的，反之也一样。这功能不复杂，需要支持执行简单的表达式，然后删除 falsy 的分支。但带来的尺寸减少量还是很客观的。

```ts
if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = require('./cjs/react.development.js');
}
```

5）Scope hoisting，范围提升或者叫作用域合并。即将模块组中的所有作用域合并为一个作用域。这个功能带来的尺寸减少量比想象中大地多，我们还没实现，所以产物尺寸和 webpack 的相差还比较大。

4、一开始是没有插件层的，但是代码写着写着发现越来越耦合，于是就加了一个插件层。完了之后就可以按照功能的维度去组织代码了。

5、应用层我们是要支持内部的三条 fish 框架的。先通过 napi 打包出 node bindings 供 node 代码调用；基于此，封装了一个 bundler-mako 给 umi 使用，和现有的 bundler-webpack、bundler-vite、bundler-esbuild 一样，就是多了一个构建工具；这是现状，但未来框架和 mako（rust 工具链）的整合肯定不止如此；同时，我们还提供了一个 bundless 模式为其中一条 fish 框架服务；此外，还有个脑洞是提供 wasm 产物，这样就可以在浏览器里使用 mako，便于接入各种无代码和低代码平台的场景。

6、依赖层分前端类、Utils 类和 Rust 语言增强类。前端类主要是 swc 系的依赖，我们将其用于 JavaScript 和 CSS 的整个生命周期，从代码到 ast，做 transform，再从 ast 到代码，以及压缩和 sourcemap，都是基于 swc；nodejs-resolver 是 rspack 开源的底层库，用于 resolve 一个模块，和 webpack 的 enhanced-resolve 功能基本对齐，帮我们省去了很多时间；Utils 类和大部分 rust crate 的选择应该是类似的，用 anyhow+thiserror 做错误处理、serde 做序列化、tracing 做日志、clap 做命令行解析、config 做配置管理、notify 做文件监听等；Rust 语言增强类，用 tokio + rayon 做并发和多线程，napi 打包 node bindings 等。

参考：  
[https://github.com/evanw/esbuild/blob/main/docs/architecture.md](https://github.com/evanw/esbuild/blob/main/docs/architecture.md)  
[https://github.com/farm-fe/rfcs/blob/main/rfcs/001-core-architecture/rfc.zh-CN.md](https://github.com/farm-fe/rfcs/blob/main/rfcs/001-core-architecture/rfc.zh-CN.md)
