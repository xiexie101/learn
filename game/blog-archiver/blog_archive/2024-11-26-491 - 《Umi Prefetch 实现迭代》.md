---
title: "491 - 《Umi Prefetch 实现迭代》"
date: 2024-11-26
url: https://sorrycc.com/umi-prefetch-iter
---

发布于 2024年11月26日

# 491 - 《Umi Prefetch 实现迭代》

1、早就知道 Umi Prefetch 有问题了，因为要开发 TNF，而 TNF 可以完美解决这个问题，就想着先不修了。然后有人提了个 [issue](https://github.com/umijs/umi/issues/12790)，说 Umi Prefetch 挂了。于是换了种思路修复了下，做下简单记录。

2、Umi Prefetch 是通过配置 `routePrefetch` 开启的。他包含 3 个能力的 prefetch，1）js & css，2）client loader，3）server loader。逻辑是，当路由匹配时，会做所有匹配路由的这些内容的预加载和恢复。

3、其好处有两个，1）预加载可以让请求提前发起，所以如果点慢一点点，会有秒开的错觉，2）解决瀑布流的问题，详见 [91 - 《Bigfish 4 特性 03：默认最快的请求》](https://sorrycc.com/bigfish-4-feat-03-fastest-request)。

4、这次出问题的是 js & css 的预加载。要做基于路由的 js & css 的预加载，就需要知道路由和 js & css 的隐射关系。之前的实现，拿产物里的 manifest，然后基于约定的 chunk name 来分析出路由和他产物的关系，这里的问题是，1）存在很大的不确定性，2）只有 build 下有效，因为 dev 不会持续更新 manifest。

![](https://tcc.sorrycc.com/p/5724a9ca-a718-4b7b-8d91-ff1d04827a0c.gif)

5、然后这次换了种实现，见 [PR](https://github.com/umijs/umi/pull/12792) 。

路由动态加载的代码是这样的，然后 fooComp 就可以在渲染时被按需加载。

```ts
const fooComp = React.lazy(() => import('./pages/foo'));
```

如果要预加载，提前去执行 `import('./pages/foo')` 这一段就好了。所以得想办法从 fooComp 里拿到这个。翻了下 React 里 [ReactLazy 的实现](https://github.com/facebook/react/blob/0940414/packages/react/src/ReactLazy.js#L135)后找到方法，可以通过 `._payload?._result` 拿到 lazy 组件的 ctor 函数。

```ts
const lazyCtor = opts.routeComponents[id]?._payload?._result;
if (typeof lazyCtor == 'function') {
  lazyCtor();
}
```

所以，这样就好了。同时还能支持 dev，也不再依赖生成 manifest 映射。

参考：  
[https://github.com/umijs/umi/pull/12805](https://github.com/umijs/umi/pull/12805)  
[https://github.com/umijs/umi/pull/12792](https://github.com/umijs/umi/pull/12792)  
[https://github.com/umijs/umi/issues/12790](https://github.com/umijs/umi/issues/12790)  
[91 - 《Bigfish 4 特性 03：默认最快的请求》](https://sorrycc.com/bigfish-4-feat-03-fastest-request)
