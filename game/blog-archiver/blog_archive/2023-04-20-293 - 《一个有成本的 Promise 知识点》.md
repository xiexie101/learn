---
title: "293 - 《一个有成本的 Promise 知识点》"
date: 2023-04-20
url: https://sorrycc.com/promise-case
---

发布于 2023年4月20日

# 293 - 《一个有成本的 Promise 知识点》

这个知识点的成本是一位同事几小时的时间和内部框架的一次回滚，记录下，怕忘。背景是今天（2023.04.20）内部框架发布之后，遇到打包后某些文件没有产出的问题，然后就回滚了。

经排查，问题是这样。

1、Umi 框架的插件可以利用 `api.onBuildComplete` 在构建完成后做一些事，同时支持异步执行。比如这样，build 结束后就会分别打印 1 和 2。

```ts
api.onBuildComplete(async () => { console.log(1); });
api.onBuildComplete(async () => { console.log(2); });
```

2、但是有个插件这样写。

```ts
api.onBuildComplete(async () => { return new Promise(() => {}) });
api.onBuildComplete(async () => { console.log(2); });
```

就出问题了，问题是 `console.log(2)` 没有执行，所以 2 被打印。这是个比喻，实际情况是在构建完成后会生成一些额外的文件，所以问题是这些文件也没有生成。同时，更严重的是，这个问题没有报错退出，所以流程上会以为他成功了，然后直接完成部署。

简化下这个问题，代码如下。

```ts
async function cli() {
  await build();
}

async function build() {
  console.log(1);
  await new Promise(() => {});
  console.log(2);
}

cli().then(() => {
  console.log('done');
}).catch(e => {
  console.error(e);
});
```

然后你用 node 执行这个文件，他只会打印 1，然后直接退出了。2 没有打印，done 也没有打印，也没有走到 `console.error(e)` 分支输出 error。

为啥？

原因在于 `build` 函数中的 Promise 永远不会 resolve 或 reject 。这导致 `await new Promise(() => {});` 一直处于等待状态，永远不会完成。因此，`cli().then()` 中的回调函数也永远不会被调用。直接走到下一步，程序结束。

那为啥 node 线程退出了？没有等 build 里的 Promise？

在 Node.js 中，如果没有任何在等待的 I/O 操作，事件循环将结束，进程将退出。他会根据事件循环中的待处理任务来决定何时退出进程。如果事件循环为空，即没有待处理任务（如定时器、I/O操作等），Node.js 将退出。在之前的代码里，由于没有创建任何真实的异步操作，事件循环很快就变为空，导致 Node.js 退出。

如何避免？

脑暴的一个解法是结合 `.finally` 和 `process.exit`。加个 `.finally` 作标记，然后在 `process.exit` 退出时间里检测是否有这个标记，如果没有，就说明是意外退出了。但这仅是个想法，应该不会是实施，还是会通过规范插件写法，加强 CI 和测试来解这个问题。
