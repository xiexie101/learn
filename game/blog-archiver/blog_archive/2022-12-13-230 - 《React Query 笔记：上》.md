---
title: "230 - 《React Query 笔记：上》"
date: 2022-12-13
url: https://sorrycc.com/react-query-note-01
---

发布于 2022年12月13日

# 230 - 《React Query 笔记：上》

要开始做请求方案的调研，第一个深入看的是 React Query（下面简称为 RQ）。本文是 [Practical React Query | TkDodo’s blog](https://tkdodo.eu/blog/practical-react-query) 系列文章的阅读笔记。

0、为啥很多人会认为 apollo 会取代 redux？apollo 是请求方案，而 redux 是全局状态库，看起来八竿子打不着，但如果我们能在客户端通过缓存的方式访问服务端的数据，那对于 80% 的应用来说，剩下需要处理的客户端状态其实很少。所以，apollo 会取代 redux 吗？It Depends。而 apollo 是处理 graphql 的，RQ 则把 apollo 的很多功能带到了 restful 的 api 场景（且不限于此）。

1、一些文档外的使用技巧。1）默认值的选择很好，但对于新手用户也会有时不时的措手不及，需要理解他们，2）使用 React Query DevTools，会告诉你缓存的数据状态，同时也要结合 Chrome DevTool 的网络面板，因为开发模式请求通常比较快，3）把 query key 当 useEffect 的依赖数组使用，两者非常相似，4）通过传入 initialData 可以让切换状态时先用缓存中的数据做预填充，提升用户体验，比如 todo app 的 filter 从全部切换到完成时的场景，5）保持服务端和客户端状态分离，useQuery() 得到的数据不要存本地 copy，以避免拿到老数据，6）enable 配置项非常强大，可以做很多事，比如依赖另一个查询的数据、modal 打开时关闭数据轮询、等待用户输入时禁用、用户输入信息后禁用默认数据的查询等，7）不要尝试通过 queryClient.setQueryData 修改 query cache 使他成为本地状态管理器，因为每次后台重新获取都可能覆盖他们，8）把 useQuery 包起来用会有额外好处，比如 ui 和逻辑分离等。

2、如果后端没有返回期望的数据格式，那就需要做格式化了。这时有多个选择，1）后端转，缺点是不一定能实现，2）queryFn 里转，缺点是每次 fetch 时需要跑一遍，同时如果你有一个不能自由修改的 service 层可能行不通（不能通过 openapi 生成的），3）render 函数中转，缺点是语法复杂，需借助 useMemo 提升性能，同时数据可能 undefined，4）用 select option 转，没啥明显缺点。所以，相对来说，方案 4 会更好，最佳优化（调用次数最少）、同时允许部分订阅。

3、RQ 内置了一些渲染优化的能力。1）notifyOnChangeProps 配置，从版本 4 起默认开启 track 模式，跟踪你使用了哪些 props，然后只在这些 props 变更后做 notify，可选配置是 all 或 String 数组，选 String 数组 要注意 props 的同步手动更新，避免出现该渲染没渲染然后使用过期数据的问题，2）RQ 做了结构共享，比如 `[{id:1,text:1},{id:2,text:2}]`，如果更新数据后只变更了 id 1，那通过 `useItems(/*id*/2)` 拿的数据会保持引用一致性，不会 notify 更新，详见 [replaceEqualDeep 的测试](https://github.com/TanStack/query/blob/80cecef22c3e088d6cd9f8fbc5cd9e2c0aab962f/src/core/tests/utils.test.tsx#L97-L304)。

4、RQ 有 3 种状态，success、error 和 loading（idle 在版本 4 里去掉了），以及另一个维度的 isFetching。应该是怎样的状态检测顺序？通常大家会写 loading、error、data（即 success）这样的顺序，但这在 refetch 时，会导致的问题是，loading 或 error 状态时看不到数据。所以更推荐的判断顺序是 data、error、loading。

5、如何做测试？这里有个例子这里有个[例子](https://github.com/TkDodo/testing-react-query)。1）不要 [mock fetch](https://kentcdodds.com/blog/stop-mocking-fetch)，用 [MSW](https://mswjs.io/)，2）给每个测试一个 QueryClientProvider 并创建新的 QueryClient，好处是完全隔离（备选方案是每次测试完清 QueryClient 的缓存，缺点是并行运行测试时可能会出错），3）自定义 hook 用 [react-hooks-testing-library](https://react-hooks-testing-library.com/) 做测试，4）测试使用 useQuery 的组件时记得用 QueryClientProvider 包一下，参考 [react-query 内部的测试用例](https://github.com/TanStack/query/blob/ead2e5dd5237f3d004b66316b5f36af718286d2d/src/react/tests/utils.tsx#L6-L17)，5）设置 retry 为 false，否则可能会因为默认要做 3 次 exponential backoff 重试而导致超时，同时注意不要在 useQuery 里写死 retry 参数，改用 `queryClient.setQueryDefaults('todos', { retry: 5 })` 会对测试更友好，6）由于 useQuery 是异步的，记得要加 `await waitFor(() => result.current.isSuccess)` 等待请求完成，7）如果命令行有太多日志，可以通过设置 QueryClient 的 logger 参数避免冗余报错，`logger: { error: () => {}, log: console.log, warn: console.warn: console.warn }`。

6、关于类型。1）useQuery 有两种写法，泛型和类型推导，推荐后者，让 queryFn 返回正确的类型，剩下的全部走推导，注意这里会缺 error 的类型，写的时候可以用 `error instanceof Error` 确保下，2）useQuery 加上 enabled 参数时就可能是 undefined 了，需在 queryFn 里处理 undefined 时抛错，3）使用 useInfiniteQuery 时记得给 queryFn 的 pageParam 加类型，4）使用 default queryFn 时要注意 queryKey 的参数类型。

7、RQ + WebSocket 有两种用法。1）推模式，服务端推送数据，客户端通过 `queryClient.setQueriesData` 更新数据，缺点是推送了并不需要的数据，比如你并不在需要数据的那个页面，2）拉模式，服务端只发送事件，告知客户端哪些数据更新了，然后客户端通过 `queryClient.invalidateQueries` 让那些请求缓存失效，在需要的时候再去服务端拉数据。个人建议无脑用第二种。同时要注意修改 staleTime 为 Infinity，WebSocket 会保证本地数据是最新的，无需通过 staleTime 设置过期时间。

8、query key 应该如何组织？一些背景知识。1）useQuery 和 useInfiniteQuery 共享同一个缓存，所以 key 不能重复，2）重新获取不同参数的数据时，不能用 refetch(xxx)，refetch 不能重新获取相同 key 的数据，解法是给 useQuery 传不同的 key，3）与查询缓存交互有多种方法，比如 invalidateQueries 和 setQueriesData 等。那么如何高效地组织 query key？1）用比如 `['todos', 'list', { filter: 'all' }]` 这样的结构，好处是在 invalidate 或突变操作时会更灵活，比如同时操作所有的 todos > list，2）使用 query key factory，避免手写容易导致的错误，比如 `todoKeys.all`、`todoKeys.detail(id)`。

9、和 query key 相关的是，queryFn 应该怎么写？1）内联，比如 `useQuery(['todos', p1, p2], () => fetchXXX(p1, p2))`，缺点是 key 和 fn 里的参数必须同步更新，一旦遗漏比如忘记更新 key 里的参数，会导致请求数据不刷新，2）QueryFunctionContext，比如 `useQuery(['todos', p1, p2], ({ queryKey }) => fetchXXX(queryKey[1], queryKey[2]))`，只只需维护 query key 里的参数即可，缺点是内联函数才有类型，同时 queryKey 是数组格式，前面几项通常会用不到，3）在 2 的基础上，支持独立函数，`QueryFunctionContext<ReturnType<typeof queryKey>>`，4）在 3 的基础上，把 key 由数组改成 object，比如 `useQuery({ scope: 'todos', entity: 'list', state, sorting }, fn)`，看起来是目前最完美的版本，类型也安全。

参考：  
[Practical React Query | TkDodo’s blog](https://tkdodo.eu/blog/practical-react-query)  
[231 - 《React Query 笔记：下》](https://sorrycc.com/react-query-note-02)
