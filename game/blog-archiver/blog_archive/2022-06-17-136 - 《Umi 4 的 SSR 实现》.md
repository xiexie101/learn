---
title: "136 - 《Umi 4 的 SSR 实现》"
date: 2022-06-17
url: https://sorrycc.com/umi-4-ssr
---

发布于 2022年6月17日

# 136 - 《Umi 4 的 SSR 实现》

花了好几天，终于合完 SSR 的 PR 了，趁着还热乎，做下笔记。

这个是 Todos DEMO，[https://test-vercel-chencheng.vercel.app/，数据](https://test-vercel-chencheng.vercel.app/%EF%BC%8C%E6%95%B0%E6%8D%AE) API 基于在 herokuapp 上部署的 strapi 应用。由于免费的 herokuapp 比较慢，好久没人访问有个冷启动的过程，会超时，刷新下就好。

Umi 的 SSR 实现分 5 步，

1、生成临时文件，作为 SSR 的入口

SSR 需要一份单独的产物，用于在服务端渲染时处理请求，所以需要一个区别于 umi.ts 的不同的入口文件，这个入口文件和 umi.ts 的区别是，导出一个 request handler，用于处理请求。

```ts
export default createRequestHandler({ …args });
```

由于 umi 中支持在路由组件中声明 serverLoader，需要在路由组件中找出带 serverLoader exports 的组件，传给 createRequestHandler，方便在 runtime 代码中调用并返回渲染用的初始数据。

```ts
export async function serverLoader() {}
```

2、构建 SSR 入口文件，基于 esbuild

SSR 产物是 node 的，所以不需要处理例如补丁、语法、兼容等奇怪的问题，用 esbuild 最合适不过了，而且快。所以 Umi 4 的构建方案是 SSR esbuild，CSR webpack。

这带来几个问题，1）webpack 层实现的功能需要在 esbuild 侧也实现一遍，比如 less 编译、svg as component、mdx 等，2）esbuild 和 webpack 之间需要保持一致性，让两者串起来，我们在这部分花了很多时间，而且还没搞完。

一致性举几个例子。比如图片，webpack 打包之后在 js 里是通过 url 的方式引用，esbuild 打包时，就不需要再处理一遍图片，而是应该直接用 webpack 打包好之后的图片地址。再比如 CSS Modules，webpack 打包好之后，每个样式名在 js 中是有一份 map 映射表的，esbuild 打包时不需要处理 CSS Modules 的打包，但应该和 webpack 打包时用相同的 hash 值算法。

Umi 4 的实现里。图片等资源文件是通过在 webpack 层产出 build-manifest.json，esbuild 里引用的方式保持一致性；CSS Modules 的类名在 esbuild 打包中的实现是先用 @parcel/css 拿到 CSS 文件里的样式名 exports，然后再用和 webpack 中相同的 hash 值算法。

3、server runtime

server runtime 主要三件事，1）匹配声明了 server loader 的路由，2）执行 server loader 拿到 loader data，3）渲染。

匹配路由是用 react-router 提供的 matchRoutes，传入路由和 request url。需要注意的是路由格式是嵌套数据类型，比如 `[{ path:'/', routes: [ { path: '/foo' } ] }]` 。然后过滤出其中包含了 server loader 声明的路由。

然后并行执行 server loader，把 loader data 存起来。

最后把 loader data、路由表、request url 放一起渲染，拿到 jsx。loader data 通常是通过全局变量的方式传给 client runtime，一遍 client 里可以通过 hooks 的方式获取到。jsx 推荐用 stream 的方式，可以让用户更早看到骨架屏。

注：server loader 的执行不仅是在初始加载时，在路由切换时 client 也会请求 server 执行 server loader 拿到数据后通过 http 返回。

4、client runtime

ssr 模式下的 client runtime，要做的事情有几个，1）通过 ReactDOM.hydrateRoot 切换到 hydrate 模式渲染，2）在切换路由时通过 http 的方式请求 server 执行 server loader，3）提供额外 API。

Umi 新增的额外 API 有 userServerLoaderData 和 useFetcher。前者用于获取 server loader 的数据；或者用于手动触发更新 server loader 数据，场景比如做了增删改之后可能都需要。

5、部署

时间原因，目前仅支持了 vercel。

Vercel 约定 api 目录下的文件为 serverless 函数，所以首先需要在此写一个文件（umi.server.js）用于处理 ssr 渲染。然后再通过 vercel.json 的配置，把相关请求重定向到 api/umi.server 即可。
