---
title: "284 - 《手写 Toy Bundler》"
date: 2023-04-06
url: https://sorrycc.com/toy-bundler
---

发布于 2023年4月6日

# 284 - 《手写 Toy Bundler》

代码：  
[https://github.com/sorrycc/toy-bundler](https://github.com/sorrycc/toy-bundler)

基本思路是这样，

1、resolve config，解析用户配置，包括确定入口文件  
2、build，生成模块依赖图谱  
3、generate，根据依赖图谱生成代码

build 是以入口文件为起点构建依赖图谱。基本思路如下，从入口文件开始，做 load、parse、transform、analyze\_deps 和 resolve，然后把依赖添加到队列里接着跑，直到分析完所有文件为止。

```ts
const seen = new Set();
const queue = [entryPoint];
while (queue.length) {
  const module = queue.shift()!;
  if (seen.has(module)) continue;
  seen.add(module);

  // 1、load
  let content = load();
  // 2、parse
  let ast = parse(content);
  // 3、transform
  let { content } = transform(ast);
  // 4、analyze
  let { deps, exports, imports, ... } = analyze(ast, content);
  // 5、resolve
  let resolvedDepsMap = resolve(deps, module);

  let metaData = { id, content, ast, deps, resolvedDepsMap, imports, exports, ... };
  modules.set(module, metaData);
  queue.push(...resolvedDepsMap.values());
}
```

generate 是基于 build 生成的依赖图谱生成最终代码，包含 runtime 的处理、module 转 code 以及将其封成可以在浏览器里跑的版本，以及 tree-shaking、code splitting 等也是在这边处理。

module 渲染逻辑如下，

```ts
import foo from './foo';
foo();

↓ ↓ ↓

const foo = require(/* ./foo module id */123);
foo();

↓ ↓ ↓

define(/* current module id */0, (module, exports, require) => {
const foo = require(/* ./foo module id */123);
foo();
});
```

最后通过一个 runtime 把所有内容拼起来，针对 node、browser 会有不同的 runtime。

```ts
const modules = new Map();
const define = (name, moduleFactory) => {
  modules.set(name, moduleFactory);
};
const requireModule = (name) => {
  const moduleFactory = modules.get(name);
  const module = {
    exports: {},
  };
  moduleFactory(module, module.exports, requireModule);
  return module.exports;
};
requireModule(/* entry module id */0);
```

参考：  
[Building a JavaScript Bundler | Christoph Nakazawa](https://cpojer.net/posts/building-a-javascript-bundler)
