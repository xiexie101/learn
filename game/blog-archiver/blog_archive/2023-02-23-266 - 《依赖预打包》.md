---
title: "266 - 《依赖预打包》"
date: 2023-02-23
url: https://sorrycc.com/dep-pre-bundle
---

发布于 2023年2月23日

# 266 - 《依赖预打包》

> 我本以为大家都知道这是啥了，看到有人提，就写一篇。但是写完发现他把问题删了，😄。

1、依赖预打包是啥？就是把依赖提前打包好放在你的 npm 包里，然后在 package.json 中删除响应的依赖，然后使用的时候直接引打包后的文件即可。

比如你的 npm 包依赖了 a，而 a 又依赖了 b，那正常结构应该是这样。

```
node_modules
  a
    node_modules
      b
index.ts
package.json
```

经过依赖预打包，会变成这样。

```
compiled
  a.js
index.ts
package.json
```

2、带来什么好处？1）锁定依赖，对于用户和用户的项目来说会更安全，不会出现三方库升级导致的意外情况发现，我们可以把我更新的主动权，可以定期（Umi 是 4 周 1 次）走完测试流程后再更新，见 [28 - 《依赖版本锁不锁》](https://sorrycc.com/npm-lock)，2）速度更快，因为少了很多 resolve 的机制和文件 IO，理论上会更快，3）让 peerDependences 警告消失，4）复用一个库的多个版本，因为你不能直接在 package.json 中声明相同库的不同版本，比如要同时支持 webpack 4 和 webpack 5，5）忘了，感觉还有的。

3、有什么缺点？1）不是即时享受到三方库的 bugfix 更新，需要等 npm 开发者主动更新，通常会有滞后，比如 umi 3 的 core-js 好久没更新，但有同学会需要用到新版本的 at 方法补丁，2）依赖版本滞后带来的版本不一致问题，比如 umi 锁了 babel 的老版本，而其他依赖依赖了 babel 新版本的 runtime，可能会存在一些问题，3）潜在的尺寸变大和依赖重复，比如你依赖 a 和 b，而 a 和 b 都依赖 c，如果 a 和 b 是分开打包的，和 c 就会重复。

4、什么场景应该用？框架和工具应该用，功能原子化的 npm 包不应该用；node 环境应该用，browser 环境的 npm 包（比如 antd）不应该用。为啥原子化的 npm 包不应该用，因为没意义，不解啥具体的问题，并且如果每个 npm 包都把依赖打包起来，那就会存在大量重复。为啥 browser 环境的 npm 包不应该用？因为预打包后就没有 tree-shaking 能力了，任何对最终产品的用户带来影响的方案都应该慎重考虑。

5、怎么实现？几种方式，1）基于 ncc，这是 next.js 和 umi 用的方式，2）我们在 father 里也封了一层，如果你用 father，可以用相关命令做依赖预打包，3）YingCi 好像也封了一个包，忘记名了，4）用 esbuild 或 webpack 把你的源码文件和依赖一起打了，相对小型或职责单一的工具（非框架）会更推荐这么做，vite 好像是这种。

6、Tips。1）同类库应该放一起打包，比如 babel 和他的插件们应该放一起，不然处理 externals 都处理不过来，为啥要 externals？为了减少潜在的重复，2）要记得处理类型，比如打包了 express.js，那得同时有 express.d.ts，这里也有不同的处理方法，一是把类型也做打包，二是手动声明相关的类型，umi 是前者，但在边界场景下还有坑没修。
