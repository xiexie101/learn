---
title: "201 - 《手撕源码 28：island.js》"
date: 2022-10-24
url: https://sorrycc.com/source-28-island-js
---

发布于 2022年10月24日

# 201 - 《手撕源码 28：island.js》

今天来看下三元同学的 islands.js 是如何实现的，其实在官网文档 [https://island.sanyuan0704.top/zh/guide/islands-arch.html#islandjs-的实现](https://island.sanyuan0704.top/zh/guide/islands-arch.html#islandjs-%E7%9A%84%E5%AE%9E%E7%8E%B0) 有介绍，下面以我的语言重新组织下。

## islands.js 是如何实现 islands 的？

假如你有一个文件，

```ts
import A from 'A';
import B from 'B';

<A />
<B __islands />
```

由于 islands.js 约定带 `__islands` props 的组件即 islands。上述文件中，`<A />` 会静态渲染，`<B />` 会动态注水。

先做 server build，产出用于 ssr 或 ssg（渲染 html）的脚本。这里有个关键步骤，1）通过 babel 插件加 islands import 信息，2）hack jsx/runtime 收集当前页面的 islands 信息。

babel 插件转换后，上述代码会转换为，

```ts
import A from 'A';
import B from 'B';

<A />
<B __islands="B!!ISLAND!!当前文件路径" foo="bar" />
```

然后通过 hack jsx/runtime，用于收集 islandToPathMap 和 islandsProps 信息。

```ts
export const data = { islandProps, islandToPathMap };
function hackJsx(jsx, type, props, ...args) {
  if (props && props.__island) {
    data.islandProps.push(props);
    data.islandToPathMap[type.name] = props.__islands;
  }
}
```

通过 server 产物导出的 render 方法进行渲染，执行 hackJsx，就可以收集到上述 data。有了 data 后，就能知道页面和 islands 的对应关系了。

然后动态生成以下代码片段，并以此为 entry 做 islands 文件的构建。

```ts
import B from 'B';
window.ISLANDS = { B };
window.ISLAND_PROPS = [{ foo: 'bar' }];
```

构建后拿到产物路径，比如 `assets/island_inject.123.js`，这段代码会动态注入 html 中，比如。

```ts
<script type="module" src="/assets/island_inject.123.js"></script>
```

最后就是注水环节，让 islands 有 JS 交互能力。以下这段代码会经过打包后，内联在 html 里代码里运行。

```ts
const { hydrateRoot } = await import('react-dom/client');
const islands = document.querySelectorAll('[__island]');
for (let i = 0; i < islands.length; i++) {
  const island = islands[i];
  const [id, index] = island.getAttribute('__island')!.split(':');
  const Element = window.ISLANDS[id];
  hydrateRoot(island, <Element {...window.ISLAND_PROPS[index]} />);
}
```

## 问题

以下我理解代码时觉得可能潜在的实现问题。

问题一、babel-plugin-islands 有不少没覆盖的场景，比如：

1、内联组件，比如 `function Foo() {} <Foo __islands />` 的场景  
2、非直接 import 组件，比如 `import { A } from 'a'; const { B } = A; <B __islands />`

问题二、build islands bundle 的方式有几个问题。

1、现在是为每个 page build 自己的 islands 时，可能存在重复。比如 Page 1 有 A 和 B，Page 2 有 B 和 C，此时就会有重复的 B  
2、islands 产物是通过 import 的方式打包到 window.ISLANDS 上，这意味着并不是支持动态按需加载，比如点 search 框时才加载 search 脚本，比如当页面滚动到一定位置才加载很下面才出现的轮播组件脚本

参考：  
[https://juejin.cn/post/7155300194773860382](https://juejin.cn/post/7155300194773860382)  
[https://github.com/sanyuan0704/island.js](https://github.com/sanyuan0704/island.js)  
[https://mp.weixin.qq.com/s/8qNI4a-3P2KId9WRAnz2dw](https://mp.weixin.qq.com/s/8qNI4a-3P2KId9WRAnz2dw)
