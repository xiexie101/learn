---
title: "369 - 《如何开发构建工具》"
date: 2023-11-09
url: https://sorrycc.com/how-to-write-bundler
---

发布于 2023年11月9日

# 369 - 《如何开发构建工具》

> 准备明天周会分享，时间 30m 左右，但想了太多，感觉内容够一本书了。时间有限，先写了一部分，应该能凑够 30m 了。后面的内容找时间慢慢补。

## 大纲

*   手写一个 Toy Version
    *   Toy Version
    *   构建器的基本流程
*   构建器基础
    *   写 Rust 就是写数据结构
        *   module、module graph、chunk、chunk graph
    *   JavaScript、TypeScript、JSX
    *   CSS、CSS Modules、Auto Prefixer、Inline or Extract
    *   语法错误和兼容
    *   AST 的一生
    *   Resolve
    *   Alias、Externals、Remote Externals
    *   Runtime
    *   Platform（Browser、Node、Worker 等）
    *   Source Map
    *   JSON
    *   Assets 和 Base64
    *   Minify
    *   Rust 语言的错误处理
    *   Binding
*   构建器进阶
    *   产物格式（ESM、CJS、UMD、IIFE 等）
    *   Worker
    *   WASM
    *   Polyfill
    *   Top Level Await
    *   SVG
    *   Hash
    *   Dead Code Detect
    *   Circular Dependency Check
    *   Optimize Package Imports
    *   多 Entry
    *   产物性能
    *   基于 Rust 的插件体系
    *   Bundless
*   构建器高级
    *   Hot Module Replacement、Watch Mode
    *   Tree Shaking
    *   Code Splitting
    *   Scope Hoisting
    *   Constant folding
    *   基于 Rust 的构建性能
    *   缓存
    *   面向用户的插件设计
*   构建器的工程化
    *   日志
    *   火焰图、puffin
    *   Benchmark
    *   Less
    *   发包
*   生产级的构建器
    *   用 E2E 测试确保稳定性
    *   CodeMod
    *   Edge Case 收集
    *   Tree Shaking 的稳定性
    *   监控
*   备选
    *   Case Cansitive Detect
    *   Stats
    *   Manifest

## 手写一个 Toy Version

### Toy Version

> 注：这部分从 [284 - 《手写 Toy Bundler》](https://sorrycc.com/toy-bundler) 复制而来。

早在写 Mako 之前，先写了一个构建器的 Toy Version。代码见 [https://github.com/sorrycc/toy-bundler](https://github.com/sorrycc/toy-bundler) 。

基本思路是这样，

1、resolve config，解析用户配置，包括确定入口文件  
2、build，生成模块依赖图谱  
3、generate，根据依赖图谱生成代码

build 是以入口文件为起点构建依赖图谱。基本思路如下，从入口文件开始，做 load、parse、transform、analyze\_deps 和 resolve，然后把依赖添加到队列里接着跑，直到分析完所有文件为止。

```ts
const seen = new Set();
const queue = [entryPoint];
while (queue.length) {
  const module = queue.shift()!;
  if (seen.has(module)) continue;
  seen.add(module);

  // 1、load
  let content = load();
  // 2、parse
  let ast = parse(content);
  // 3、transform
  let { content } = transform(ast);
  // 4、analyze
  let { deps, exports, imports, ... } = analyze(ast, content);
  // 5、resolve
  let resolvedDepsMap = resolve(deps, module);

  let metaData = { id, content, ast, deps, resolvedDepsMap, imports, exports, ... };
  modules.set(module, metaData);
  queue.push(...resolvedDepsMap.values());
}
```

generate 是基于 build 生成的依赖图谱生成最终代码，包含 runtime 的处理、module 转 code 以及将其封成可以在浏览器里跑的版本，以及 tree-shaking、code splitting 等也是在这边处理。

module 渲染逻辑如下，

```ts
import foo from './foo';
foo();

↓ ↓ ↓

const foo = require(/* ./foo module id */123);
foo();

↓ ↓ ↓

define(/* current module id */0, (module, exports, require) => {
const foo = require(/* ./foo module id */123);
foo();
});
```

最后通过一个 runtime 把所有内容拼起来，针对 node、browser 会有不同的 runtime。

```ts
const modules = new Map();
const define = (name, moduleFactory) => {
  modules.set(name, moduleFactory);
};
const requireModule = (name) => {
  const moduleFactory = modules.get(name);
  const module = {
    exports: {},
  };
  moduleFactory(module, module.exports, requireModule);
  return module.exports;
};
requireModule(/* entry module id */0);
```

### 构建器的基本流程

没画 Mako 的图，先以 esbuild 的架构图用于讲解下 Mako 的流程，大差不差。

![](https://img.alicdn.com/imgextra/i4/O1CN01yuql0x1G9EDdQLApx_!!6000000000579-2-tps-1504-1144.png)

分两个阶段，1）Build，2）Generate。

Build 阶段的目的是为了构建一个完整的 Module Graph。所以会先收集 Entry，然后以 Entry 为入口找到所有模块，再对每个模块并行做 Load、Parse、Transform、Analyze Deps、Resolve、Add to Module Graph 的过程。

Generate 阶段是真正复杂的部分，很多复杂的功能都是在这个阶段完成。在 Mako 的流程里，会先做 Tree Shaking，再做 Chunk 的 Group 和 Optimize 以生成 Chunk Group，再做一次 transform，再针对每个 Chunk 里的每个模块的 Runtime 代码注入、Ast to Code、压缩、Source Map 生成等。

Transform 简单来说就是针对 AST 的修改。我们会发现，Build 和 Generate 里都有 Transform。Build 里的 Transform 里会做 React 相关、Env Replacer 环境变量替换、Try Resolve 允许 try 语句里 require 模块失败、Define 替换及常量折叠、import() 到 require 的转换以禁用拆包、基于 targets 浏览器等平台版本的 JS 语法转换等；Generate 里的 Transform 会做 ESM 到 CommonJS 的转换，模块里 import 语句 source 依赖的替换等。为啥要拆成两部分做？因为有些事情不能做太早，比如在 Tree Shaking 之前就把模块转成 CommonJS，那 Tree Shaking 就分析不出模块的副作用情况了。

Rust 中有 petgraph 这个包可以做图相关的事，非常方便，省了好多事，Mako、Rspack 和 Farm 都在用。

图中有部分是并行的，在 Mako 中也是一样。不是所有用 Rust 写的代码都是快的，只有充分利用并行，把 CPU 利用到极致的代码才可能会快。

此外，这张图里还有个流程没有提到，就是 esbuild 不支持的增量 watch 和 HMR 流程，而这通常是决定日常研发体验的关键因素。先简述下流程（TODO：补图）。当 watch 到一个文件发生修改、删除、新增时，会先检查这个文件是否在 module graph 里，不在当然就不用处理了，然后收集因为这个文件变更导致的影响。比如删了一个文件，那他的父文件就要标记为变更，需要重新编译父文件，然后把 require 语句替换为 `throw new Error('module xxx not found')`。接着重新做前面介绍的 Build 和 Generate 步骤，但注意得是增量的。这个增量就复杂了。。。

## 构建器基础

> 时间有限，先简述，感觉没部分都能展开成一个段落。

写 Rust 就是写数据结构，忘记这句话是谁说的了，因为 Rust 代码通常都是围绕 Struct 展开的。

```
TODO
Mako 的数据结构图
```

Rust 有 SWC 这个大杀器，包揽了 JS 和 CSS 从 Parse、Transform、Generate、Minify、SouceMap 的全过程。目前 Farm、Rspack、Turbopack 都是用的他。我们中间试过用 lightening css（Parcel 作者开发） 做 CSS 的部分，后面忘记遇到啥坑后放弃了。还有字节的同学最近有开发 oxc，可以作为 JS 的 Parser，还没有尝试。

JavaScript 和 TypeScript 的处理基本相同，TypeScript 需要多做一个 strip 的操作，就是删除其中的类型部分。同时 TypeScript 需要尽量和 TSC 的逻辑保持一致，所以和 JavaScript 的行为会有细节上的不同，比如 import x from ‘foo’ 而 x 没有被使用时，是否应该保留 import ‘foo’，JavaScript 会保留，而 TypeScript 会删除。

CSS 有几个复杂点的功能点。1）Less 的支持，略。2）CSS 的顺序，要注意 css import css，和 JavaScript 是倒着的，详见 [328 - 《CSS Import》](https://sorrycc.com/css-import) 。3）CSS Modules，实现时得虚拟一个 js module 拦在 css 之前，内容是 className Map 的导出。4）Auto Prefixer，注意和 targets 配置的联动。5）Inline or Extract，前者是产出一个 JS 模块动态插入 style 标签，后者是把 CSS 合并到一起以 chunk 维度做输出，Mako 选择了后者，因为可以 dev 和 build 一致且坑更少。

JS 和 CSS 在遇到语法错误时应该怎么办？直接抛错？不一定对！啥？为啥写错了还不应该抛错？原因是 Webpack 兼容了很多语法，比如 CSS 的错误他是不抛的，有些 JS 的错误他也是不抛的。这些错误可能不会导致运行时报错，但是会无效。比如 CSS 的错误，我们的依赖里有很多是有错的，参考 [358 - 《CSS 错误片段集锦》](https://sorrycc.com/css-common-errors)。而 Mako 对于这部分无法直接抛出来，因为对于依赖里的错误，开发者遇到了也无法解决。所以，目前的解法是，CSS 部分，node\_modules 下不抛，src 下抛。

Resolve 也是个大坑。1）我们基于 nodejs\_resolver 实现 resolver，其支持的功能和 webpack 的 enhanced\_resolved 基本一致，支持 alias、externals、package.json exports 等，帮我们省了很多时间。2）目前在观望 oxc\_resolver，因为他支持 mem fs，这是后面我们要支持 WASM 输出时的必备功能。3）resolve 分两层，除了前面库的选择，还有调用 resolve() 的策略，比如针对 CJS 和 ESM 需要做区分，针对 Browser 和 Node 也要做区分，目前我们为了兼容各种奇怪的依赖包里的写法，选择了和 Webpack 基本一致的策略。

Alias 和 Externals 属于基本功能。不过我们在此也做了两件事。1）很高级（复杂）的 externals 配置，我们内部有 auto externals 的功能，会自动把一些重型 npm 包替换为 umd 的方式引入，好处是打包提速和 qiankun 主子应用依赖复用，但是 auto externals 是用函数写的 externals 规则，而 mako 不支持函数式的配置，所以就改用规则的方式实现了原来需要函数来做的功能。2）Remote Externals，参考 [35 - 《按需 externals》](https://sorrycc.com/dynamic-externals)，比如 `externals: { foo: ['script //cdn/foo.js', 'Foo'] }`，当使用 Foo 时，无需在 html 里引入 //cdn/foo.js，他会在用 require 到时自动加载，优点是提速。

Runtime。复杂的事情。略。

Source Map。略。

JSON。除了可以被 load 为 JavaScript 模块，一个进阶的功能是要支持 JSON 文件的 Tree Shaking。

Assets 和 Base64。

Minify。

Rust 语言的错误处理。anyhow + thiserror。Result 往上传递错误。Code Frame 优化错误信息。RUST\_LOG 提供详细日志。

Binding。=

## 构建器进阶

时间原因，先略。

## 构建器高级

Hot Module Replacement 涉及的知识面很广，除了前面说的 Update 流程做增量更新，还设计 HMR 的 Runtime 层、Watch 模式的实现方式、CSS 和 CSS Modules 的热替换、Entry 的特殊处理、React FastRefresh、判断 React 组件的方法和判断后的策略（当 export 的不全是组件时应该刷新还是热更）、hmrGuardian（当 export 了匿名函数自动给个名字）等。Watch 模式我们目前也是放在 Rust 层实现，Farm 和 Rspack 都是放在 Node 层，有好有坏，Rust 的 watch crate（模块）用的人少，有坑。HMR 的 Edge Case 很多，我们梳理了近 20 个用例，比如删除一个文件后加回来，比如 git checkout 一下子增加多个文件，比如以每秒保存 3 次的手速修改文件等等。

Tree Shaking 见 [340 - 《Tree Shaking 原理》](https://sorrycc.com/tree-shaking-principle)。想听的可以约「辟殊」或「禾登」的分享。

Code Splitting。想听的可以约「辟起」的分享。1）Code Splitting 是个权衡，产物又小加载又快是不存在的，你得找到一个中间值，见 [202 - 《Umi 最佳实践：拆包策略》](https://sorrycc.com/umi-best-practise-code-splitting)。2）支持不拆包，好处是部署简单和总产物最小，坏处是加载慢合热更慢，为啥热更慢？因为每次改文件都要生成的东西更多了，根据构建工具的实现多的可能多也可能少。3）多 Entry（MPA）和 SPA 的拆包策略是不同的，拆完之后加载的策略也不同。4）Code Splitting 在 Mako 层不会提供和 Webpack 一样的详细配置，Mako 会提供一些可供选择的策略，并希望默认策略尽可能是一个好的权衡，但是没有银蛋，不一定适用各种应用场景。

Scope Hoisting 略，目前没做。做完之后产物尺寸和运行效率应该都会有提升。

Constant folding 即常量折叠。比如如下的这段代码，在 production 时就不应该引入 ./cjs/react.development.js 的，反之也一样。这功能不复杂，需要支持执行简单的表达式，然后删除 falsy 的分支。但带来的尺寸减少量还是很客观的。

```ts
if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = require('./cjs/react.development.js');
}
```

基于 Rust 的构建性能。

缓存。

面向用户的插件设计。大概率不会提供 JavaScript 的扩展方式，只会提供 WASM 方式的扩展。有个真实例子，「比如之前有人和我说某 Rust 构建工具比 Webpack 还慢，我问为啥，他说在 Rust 构建工具的基础上又增加了 Babel 满足业务需求，哈哈。」只要开了口子，用户的使用角度绝对会超出你的想象。Mako 我想把这个口子收的足够小，当然，这肯定会以牺牲功能和兼容性为代价。

## 构建器的工程化

日志。

火焰图、puffin。

Benchnmark。

Less。

## 生产级的构建器

区分一个工具是 Toy 还是可以作为生产使用的一个维度是，他是否被生产项目大范围采用。做 Mako 我们肯定是为了上生产，为了确保这个步骤顺利，我们也做了不少事情。

用 E2E 测试确保稳定性。除了单测（不多），我们加了不少 e2e 用例。分几个维度，1）build 后验结果，2）build 后验跑浏览器验输出内容，3）dev + hmr 后修改文件验 HMR，4）build / dev 时故意出错。有些用例想不出来，就从 esbuild 里迁，比如 Tree Shaking 的部分。

CodeMod。一键修改代码，并升级。先会做校验，确保项目可升级，比如 Bigfish 3 不能升，Bigfish 组件库和 Chair 项目暂不能升，使用了 Monaco Editor 暂不支持等。然后会修改文件，我们加了不少兼容确保用户只需修改配置文件即可完成升级。

Edge Case 收集。1900 个项目的 build 验证（发现了很多 edge case）。xxxx 个 npm 包的 build + browser 验证（发现了很多 edge case）。近百个项目的手动验证 tree shaking 结果。所以，蚂蚁统一工具层其实是 Mako 的一个优势，因为我们可以在工具发布之前就收集到所有已有的 Edge Case。

监控。

参考：  
[Building a JavaScript Bundler | Christoph Nakazawa](https://cpojer.net/posts/building-a-javascript-bundler)  
[https://github.com/evanw/esbuild/blob/main/docs/architecture.md](https://github.com/evanw/esbuild/blob/main/docs/architecture.md)  
[280 - 《构建工具应该包含哪些能力》](https://sorrycc.com/build-tool-features)  
[284 - 《手写 Toy Bundler》](https://sorrycc.com/toy-bundler)  
[GitHub - sorrycc/toy-bundler: toy-bundler](https://github.com/sorrycc/toy-bundler)  
[334 - 《Mako 开发日志（1）》](https://sorrycc.com/mako-devlog-01)  
[335 - 《Mako 开发日志（2） - Benchmark 的秘密》](https://sorrycc.com/mako-devlog-02)  
[341 - 《Mako 开发日志（3） - 架构图》](https://sorrycc.com/mako-devlog-03)  
[352 - 《Mako 开发日志（4）：Less》](https://sorrycc.com/mako-devlog-04)  
[365 - 《Mako 开发日志（5） - Why Mako》](https://sorrycc.com/mako-devlog-05)  
[328 - 《CSS Import》](https://sorrycc.com/css-import)  
[358 - 《CSS 错误片段集锦》](https://sorrycc.com/css-common-errors)  
[35 - 《按需 externals》](https://sorrycc.com/dynamic-externals)  
[340 - 《Tree Shaking 原理》](https://sorrycc.com/tree-shaking-principle)  
[202 - 《Umi 最佳实践：拆包策略》](https://sorrycc.com/umi-best-practise-code-splitting)
