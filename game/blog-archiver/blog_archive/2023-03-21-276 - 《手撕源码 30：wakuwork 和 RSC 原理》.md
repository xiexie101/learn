---
title: "276 - 《手撕源码 30：wakuwork 和 RSC 原理》"
date: 2023-03-21
url: https://sorrycc.com/source-30-waku
---

发布于 2023年3月21日

# 276 - 《手撕源码 30：wakuwork 和 RSC 原理》

手撕 wakuwork 之前，我们先理解下 React Server Components，下面简称为 RSC 。

我们以一个具体例子来看 RSC 的实现。比如有两个文件，app.tsx 和 foo.tsx，其中 foo.tsx 加了 `"use client"` 的标记，所以 app.tsx 应该在 server 端渲染，foo.tsx 应该在 client 端渲染。

```ts
import { Foo } from './foo';
export function App() {
  return <><h1>App</h1><Foo /></>
}
```

```tsx
"use client";
export function Foo() {
  return <div>Foo</div>;
}
```

1、当用户访问应用时，需要通知 server 渲染 App 组件，拿到 App 组件的流式数据后拼成 React 组件需要的数据格式，最终渲染到页面里。

```tsx
import ReactDOM from 'react-dom/client';
import { createFromFetch } from 'react-server-dom-webpack/client';
// 从 server 拿 App 组件的数据
// rsc 表示 react server components
const response = fetch('/?rsc_id=App&props=...');
const options = {};
// 基于 response 创建 React 组件
const data = await createFromFetch(response, options);
// 渲染组件到页面
ReactDOM.createRoot(document.getElementById('root')).render(data);
```

2、server 在处理 `/?rsc_id=App&props=…` 时做了什么？又返回了什么数据？

node-register 的实现见 [react/ReactFlightWebpackNodeRegister.js](https://github.com/facebook/react/blob/2b003a5/packages/react-server-dom-webpack/src/ReactFlightWebpackNodeRegister.js#L265-L310)，针对 `"use client"` 和 `"use server"` 分别处理，返回额外的 id、typeof、bound 等元信息。

```tsx
// 注册 node register，处理 "use client" 和 "use server"
const RSDWRegister = require('react-server-dom-webpack/node-register');
RSDWRegister();

const bundleConfig = new Proxy({}, {
  get(target, id) {
    const [filePath, name] = id.split("#");
    return {
      id, chunks: [], name, true,
    };
  }
});
// 把 React 组件转成流式数据
const { renderToPipeableStream } = require('react-server-dom-webpack/server.node');
const stream = renderToPipeableStream(<App />, bundleConfig);
stream.pipe(res);
```

其返回的数据格式如下。

```ts
1:I{"id":"foooooooo","chunks":[],"name":"Foo","async":true}
0:["$","div",null,{"children":[["$","h1",null,{"children":"Hello World"}],["$","$L1",null,{}]]}]
```

怎么理解这个数据格式？源码位置在 [react/ReactFlightClient.js](https://github.com/facebook/react/blob/ef8bdbe/packages/react-client/src/ReactFlightClient.js#L504-L598) 。比如上一段数据格式，这里用到了 `$` 和 `$L1`，其中 `$` 代表 React Element，`$L` 代表 Lazy Node，会将其用 React.lazy 包起来返回，`$L1` 的 `1` 表示 chunk id。

到此为止，RSC 的基本流程就串完了。可以理解为在 server 渲染组件然后只返回结果的流式数据，再到客户端解析这些流式数据并渲染。其中要支持 `"user client"` 和 `"use server"` 的标记，把 `"use client"` 的代码打成单独的 chunk 包，通过 React.lazy 包成一个异步加载的组件。

再来看 [wakuwork](https://github.com/dai-shi/wakuwork)。

1、wakuwork 是数据流大佬 [dai-shi](https://github.com/dai-shi) 的作品，极简，基于 Vite，个人理解应该是玩具性质，为了验证想法用的。通过以下命令尝鲜（create-wakuwork 应该是昨晚 2023.03.20 刚加的）。

```bash
$ pnpm create wakuwork
$ cd wakuwork-example
$ pnpm i
$ pnpm run dev
```

你会看到如下图的效果。外部组件来自 server 渲染，内部组件来自 client 渲染。

![](https://img.alicdn.com/imgextra/i4/O1CN01cEau941EiNJ5muOzi_!!6000000000385-2-tps-2072-700.png)

2、wakuwork 分了三个命令，dev、build 和 start。我只看了 build 和 start，dev 应该就是这两个的结合体。

3、build 做了几件事，1）用 vite 打包，没加啥有意义的插件，但是会找所有包含 `"use client"` 标记的文件作为 entry，2）基于 swc 把源从 src 编译到 dist，给 node 端的 server 渲染用，3）给 entriesFile 添加 `exports.clientEntries` 数据，让 server 知道 `"use client"` 的组件对应的 client chunk 是哪个。

4、start 是给生产用的，基于 build 的产物启一个 server，加了 5 个中间件，staticFile、rewriteRsc、rscPrd、indexFallback 和 notFound。rscPrd 是最主要的，会处理 rsc（组件） 和 rsf（函数），他会结合用户代码中的 `entries.ts` 里定义的 `getEntry` 和 build 时添加的 `clientEntries` 拿到组件代码，然后通过前面原理部分说的 `renderToPipeableStream` 转成流式数据返回。

5、此外，通过 examples 目录可以看出，wakuwork 还支持 async、promise、callserver、mutation 和 nesting 等功能。除了 mutation，其他应该都是 RSC 内置支持的，通过在服务端的流式数据里用 `props` 返回特殊的标记实现。

参考：  
[GitHub - reactjs/server-components-demo: Demo app of React Server Components.](https://github.com/reactjs/server-components-demo)  
[RFC: React Server Components by josephsavona · Pull Request #188 · reactjs/rfcs · GitHub](https://github.com/reactjs/rfcs/pull/188)  
[react/packages/react-server-dom-webpack/src at main · facebook/react · GitHub](https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack/src)  
[GitHub - dai-shi/wakuwork: Minimalistic React Framework](https://github.com/dai-shi/wakuwork)
