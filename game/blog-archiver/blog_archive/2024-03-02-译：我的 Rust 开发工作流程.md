---
title: "译：我的 Rust 开发工作流程"
date: 2024-03-02
url: https://sorrycc.com/rust-development-workflow
---

发布于 2024年3月2日

# 译：我的 Rust 开发工作流程

> 原文：[https://kerkour.com/rust-development-workflow](https://kerkour.com/rust-development-workflow)  
> 作者：Sylvain Kerkour  
> 译者：ChatGPT 4 Turbo

Rust 编译需要很长时间，即使是增量编译也是如此。一个小改动导致 2 到 3 分钟的编译时间以测试这个改动，并不罕见，这让很多新手 Rust 程序员感到沮丧。这是语言设计者有意为之的选择，是为了优先考虑运行时速度而不是编译速度（这就是我们喜欢 Rust 的原因：原始速度），并且没有魔法咒语或者作弊码可以减少这个编译时间。

我花了一些时间找到一个好的工作流程，这个流程不会打断我的[流状态](https://en.wikipedia.org/wiki/Flow_\(psychology\))（当我全神贯注时），所以我认为如果它能帮你节省时间，亲爱的读者，分享出来是值得的。

但首先，我有个问题：是逆流而游让你更快乐，还是顺应潮流，完成事情让你更快乐？

如果你来自于像 TypeScript 或 Go 这样编译极快的编程语言，你应该习惯了快速的 `code -> manually test -> fix -> repeat` 周期。一旦项目变得足够严肃（大）时，在 Rust 中这简直是不可能的。但这绝对不是放弃 Rust 为我们软件开发者和工程师带来的所有优秀特性的理由。

这是我在过去几年的专业 Rust 开发中形成的工作流，在我意识到逆流而动只会带来无尽的挫折后。

实际上，有一些像 [sccache](https://github.com/mozilla/sccache) 这样的“魔法”解决方案可以加速 CI，但我认为它们太复杂了，我非常重视简单性，所以谢谢，但不用了。

## 使用 `rust-analyzer`

首先，使用 [`rust-analyzer`](https://rust-analyzer.github.io/) 。

当我开始用 Rust 进行软件开发时，`rust-analyzer` 不是一个选项，而且 Rust 编程简直是折磨。

今天，我认为 `rust-analyzer` 是 Rust 被采用和用户基数增长的最关键因素之一。它不仅提供代码补全，还提供内联警告和错误提示，以及在编程过程中非常方便的许多其他功能。

不使用 `rust-analyzer` 会让你浪费很多时间，我认为这纯粹是自虐。

请记住，有时 `rust-analyzer` 不会给出最有帮助的错误信息，所以如果你无法仅通过阅读 `rust-analyzer` 信息来解决错误，切换到 `cargo check` 将会提供更好的信息。

## 相信你的直觉

下一个不打断你的留的最重要的事情就是要相信你的直觉。

因为即使 `rust-analyzer` 和 `cargo check` 有时也会很慢（长达十几秒），每写一行代码就等它们完成，简直让我抓狂。

现在，我在查看错误和警告之前会写很多代码。相信我的直觉也意味着我不会每隔几分钟就手动测试我的程序。我的经验是，在 Rust 中快速的 `code -> manually test -> fix -> repeat` 周期是不可能的。相反，我相信我的代码大多是正确的，并且不会因为一些不重要的事情而打断我的流程。

一旦我的完整功能或特性实现了，我就开始修复警告和错误。

## 编写测试

你的代码通过了 `cargo check` ？太好了！但我们是人类：我们都会犯错。

所以下一步是编写测试。Rust 编译器提供了很多保证，并迫使我们处理所有边界情况，但对逻辑错误无能为力。

有些人喜欢在编写实际代码之前就编写测试（[TDD](https://en.wikipedia.org/wiki/Test-driven_development)），我个人更倾向于之后，无论如何，你都必须编写测试来检测逻辑错误。

## 拥抱持续集成

运行测试需要编译它们，所以正如你所猜测的，这是缓慢的。

所以要在 Rust 中提高生产力的最后（但同样重要的）一件事，就是拥抱[持续集成](https://en.wikipedia.org/wiki/Continuous_integration)。

![](https://img.alicdn.com/imgextra/i2/O1CN01CjJVua20R408M9ppE_!!6000000006845-2-tps-1158-574.png)

目标是**永远不在你自己的电脑上运行测试**，而是让你的 CI 机器人帮你运行测试（毕竟它们是机器，机器就是为我们服务的），然后，在一天结束时，检查是否有些测试失败了并修复它们。

对于一个大型的 Go 或 Node.js 项目，CI 流水线应该在 5 到 10 分钟之间完成。而对于 Rust 来说，运行一个 CI 流水线则需要 **15 到 45 分钟**，这取决于你的项目和 CI 服务器的性能。

所以最明智的做法是**每天只修复一次你的失败测试**。

它被称为**捆绑**：现在我的 `code -> manually test -> fix -> repeat` 周期持续整整一天，而不是将我的一天（以及我的注意力和你的专注）分割成更小的周期。

就像每小时检查一次电子邮件会消磨你的生产力一样，每小时等待测试运行也会消磨你的效率。

作为最后一点，对我来说，在一天结束时修复测试非常关键，因为这是一项非创造性任务。我所有的创造性能量，都在一天开始时用来实现新事物，而不是修复测试。

对于 GitHub，你有 [GitHub Actions](https://docs.github.com/en/actions)；对于 GitLab，你有 [GitLab CI/CD](https://docs.gitlab.com/ee/ci)。

这是我一个 Rust 项目的 CI 流水线示例：[phaser/.github/workflows/ci.yml](https://github.com/skerkour/phaser/blob/main/.github/workflows/ci.yml) 。

## 项目维护

感谢 `cargo` 和社区，rust 中的项目维护变得简单。你需要安装 [`cargo-outdated`](https://github.com/kbknapp/cargo-outdated) 和 [`cargo-audit`](https://github.com/rustsec/rustsec) ：

```bash
$ cargo install -f cargo-audit
$ cargo install -f cargo-outdated
```

然后，每周一次：

```bash
$ cargo update
$ cargo outdated
# manually update the outdated dependencies
$ cargo audit
```

好了，就这些。愉快地使用 Rust 吧 :)
