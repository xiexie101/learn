---
title: "178 - 《手撕源码 24：bunchee 2》"
date: 2022-08-30
url: https://sorrycc.com/source-24-bunchee-2
---

发布于 2022年8月30日

# 178 - 《手撕源码 24：bunchee 2》

[bunchee](https://github.com/huozhi/bunchee) 是 npm 库打包工具，看到他发布 2.0 有提到 swc 和 package exports 就翻来看一遍。没多少代码，10-20 分钟就能看完。作者是 huozhi，vercel 员工，同时也是 devjar 的作者。

bunchee 是 npm 库打包工具里 bundle 系的，输入是一个文件，输出是包含其依赖在内的打包后的产物。对比之下，father 4 是 bundless 系的，或者叫 transform 系，输入是一个文件，输出是这个文件的另一种格式。

这次翻源码从问题出发。

1、bunchee 如何做打包？

基于 rollup + 一堆插件，支持 watch 和 build 模式。

2、bunchee 如何使用 swc？

基于 rollup-plugin-swc3。swc 好是好，就是太大，单独安装下就需要 70M+，为此 umi 4 使用 swc 作为编译器时是需要自行安装 @swc/core 的。相比之下，esbuild 仅 17M+。

3、bunchee 如何支持 package exports？

bunchee 会识别 package exports，支持 multiple exports，也支持 exports sugar（exports: ‘./index.js’）。如果有多个 exports，会把每个 exports 都打包一遍。

但也仅限与此，bunchee 并没有很好地支持「pure esm」。比如 pure esm 要求 require 相对文件时写全称，bunchee 并没有相关处理。

4、bunchee 如何解重复 bundle 的问题？

在多 exports 的场景下，分别 bundle 一个项目下的多个文件，势必会造成重复，比如多 exports 都依赖了相同的文件。bunchee 其实并没有特殊处理，那为啥 bunchee 这个库的 cli.js 和 lib.js 之间又没有重复？因为 cli 引用 lib 用了 require() 语法，这个语法在 rollup 里不会被处理，原样保留，也不会做 bundle。

感觉有点不正式。个人觉得更好地方式是一次 bundle，多个 entry，此时 bundle 会通过 code splitting 自动解重复的问题。

5、bunchee 是如何实现自己打自己的？

```bash
tsx ./cli.ts ./cli.ts --runtime node -f cjs
```

以上是 package.json 中的 build:main 的 script 命令，第一眼看到还没反应过来。啥意思？tsx 是 TypeScript runner，这里就用 tsx 执行 ./cli.ts，再让 cli.ts 打包 ./cli.ts，以 node 为 runtime，产出 cjs 格式。

6、bunchee 的 runtime 会影响啥？

runtime 可以配置为 node、browser 等，这也是 bunchee 2.0 新改的名。个人感觉比 esbuild 的 platform 取名更好。

从源码看，只会影响 nodeResolve 插件的 preferBuiltins 配置，runtime 为 node 时为 true。个人感觉做少了，swc 编译时应该也要基于 runtime 做区分处理，比如处理补丁和语法等。

参考：  
[https://github.com/huozhi/bunchee/releases/tag/v2.0.0](https://github.com/huozhi/bunchee/releases/tag/v2.0.0)
