---
title: "430 - 《RSC》"
date: 2024-04-15
url: https://sorrycc.com/rsc
---

发布于 2024年4月15日

# 430 - 《RSC》

> 近期要做 RSC 的支持，再看了一遍相关文档，整理如下。

1、生成 RSC 协议字符串。

比如我们有个组件树，App -> Foo。调 RSDWS（react-server-dom-webpack/server） 渲染 App 即可得到 RSC 协议的字符串。

```ts
import rsdws from "react-server-dom-webpack/server";
const { renderToPipeableStream } = rsdws;
import { App } from "./app/App.js";
renderToPipeableStream(<App />).pipe(process.stdout);

// 输出
// J0:["$","div",null,{"children":[["$","h1",null,{"children":"App"}],["$","p",null,{"children":"Foo"}]]}]
```

现在来加一个 Client 组件 Bar，注意 Client 组件在 RSC render 时不会引真实文件，而是被替换成 `{ $$typeof, filepath, name }` 的格式。这一步通常由框架或构建工具来做。然后 renderToPipeableStream 时加上 bundle 相关配置，webpack 的场景下需要 id、name 和 chunks 字段。

```ts
const Bar = {
  $$typeof: Symbol.for("react.module.reference"),
  filepath: "Bar.tsx",
  name: "Bar",
};
renderToPipeableStream(<App />, { 'Bar.tsx': { Bar: { id: 'Bar.tsx', name: 'xxx', chunks: [] } } }).pipe(process.stdout);

// 输出
// M1:{"id":"Bar.tsx","name":"xxx", "chunks":[]}
// J0:["$","div",null,{"children":[["$","h1",null,{"children":"App"}],["$","p",null,{"children":"Foo"}],["$","@1",null,{}]]}]
```

其中 `Mx` 表示模块，而 `["$","@1",null,{}]` 表示使用 M1 模块。

2、react-server condition。

基于 [0227-server-module-conventions](https://github.com/reactjs/rfcs/pull/227)，前面的代码要跑起来，是需要加 `--conditions react-server` 的，比如 `node --conditions react-server /path/to/file.js`。原因是 [react-server-dom-webpack 的 package.json 中 server 有 react-server 的 condition](https://github.com/facebook/react/blob/56efb2e/packages/react-server-dom-webpack/package.json#L51-L60)。

一个好处是，如果错误地在 RSC 中使用 useState、useEffect 等不支持的 hooks，由于根本没这个 export，会直接报错。

```ts
file:///private/tmp//Foo.js:2
import { useEffect, useState } from "react";
         ^^^^^^^^^
SyntaxError: Named export 'useEffect' not found. The requested module 'react' is a CommonJS module, which may not support all module.exports as named exports.
CommonJS modules can always be imported via the default export, for example using:

import pkg from 'react';
const { useEffect, useState } = pkg;
```

3、消费 RSC 协议字符串。

消费是通过 RSDWC（react-server-dom-webpack/client）。RSDWC 有 browser、node、edge 等实现，提供 createFromFetch、createFromReadableStream 等不同的消费方法。createFromXXX 方法会产出一个处理 RSC 协议字符串的 Promise，最终通过 `use()` 使用，产生 JSX。

比如 Browser 侧消费的例子。

```ts
import React, { use } from "react";
import { createFromFetch } from "react-server-dom-webpack/client";
import ReactDOM from "react-dom/client";

const chunk = createFromFetch(fetch('/path/to/.'));
function Container() {
  return use(chunk);
}
ReactDOM.createRoot(root).render(<Container />);
```

由于使用的是 react-server-dom-webpack，意味着加载方式遵循 webpack 的规范。如果你的实现不基于 webpack，需要对 `__webpack_require__` 和 `__webpack_chunk_load__` 打补丁。

```ts
globalThis.__webpack_chunk_load__ = async (chunkId: string) => {};
globalThis.__webpack_require__ = (moduleId: string) => {};
```

4、RSC 和 Stream SSR。

通常 RSC 会和 Stream SSR 结合使用，代码层通过 Suspense 拆。参考下图。

![](https://img.alicdn.com/imgextra/i3/O1CN01fveAjy1kXu0hEvCQ2_!!6000000004694-2-tps-1432-850.png)

怎么实现？这里需要一些流处理的知识。当用户请求时，先基于 url 生成 RSC 协议字符串流，然后把这个流一分为二。一个用于 createFromReadableStream 创建 chunk，然后给 ReactDOM.renderToPipeableStream 创建 react 渲染流；另一个逐行读取，解析为 globalThis.rscData 的 push() 或 end()（客户端用这两个方法模拟流）。最后再把这两个流合起来返回。这样就可以实现服务端流式 SSR + 客户端增量注水的功能。

![](https://img.alicdn.com/imgextra/i1/O1CN01hz896a1jSZrOzUZav_!!6000000004547-1-tps-787-426.gif)

5、蚂蚁容器的 RSC 实践。

不确定是否合适写到外面，先略。

6、Waku 的构建层。

Waku 的 Build 是做四次打包。

1）第一次，analyzeEntries，分析依赖，拿到 server 和 client 组件信息，含 node\_modules 下的  
2）第二次，buildServerBundle，给 RSC 用，输出到 dist 目录  
3）第三次，buildSsrBundle，为 client entry 产出 ssr 产物，输出到 dist/assets 目录  
4）第四次，buildClientBundle，为 client entry 产出 csr 产物

7、Mako 如何支持 RSC。

最全场景应该是 4 次打包：RSC Server、RSC Client SSR、RSC Client CSR，Client Fallback。Client Fallback 用于 RSC 失败时的 Fallback 渲染。

整体流程先做 RSC Server 打包，分析 client 组件边界，无需等 generate 阶段完成，在 build 阶段完成后即可做 RSC Client 的打包；RSC Client 的打包有两个选择，「多 Entry」和「虚拟 Entry + 动态 import(client component)」的形式，选择后者，原因包括 Client 的 HMR 的实现复杂度等；RSC Client SSR 和 RSC Client CSR 启两个实例来做；最后做 Client Fallback，dev 不做，仅在 build 阶段做。

其他还要考虑的因素比如，1）RSC Client 和 Server 的 CSS 重复和顺序问题，2）assets 的 base64 合理性、路径和重复问题，3）client 遇显式的 `use server` 需报错（TODO：为啥会有显式的 `use server`？不应该用 server-only 这个 npm 包吗？）。

参考：  
[342 - 《RSC 笔记》](https://sorrycc.com/rsc-note)  
[339 - 《RSC 调研》](https://sorrycc.com/rsc-research)  
[308 - 《RSC 初印象》](https://sorrycc.com/rsc-first-impression)  
[276 - 《手撕源码 30：wakuwork 和 RSC 原理》](https://sorrycc.com/source-30-waku)  
[316 - 《Full Stack React 笔记（1）》](https://sorrycc.com/full-stack-react-note-01)  
\[\[译：React RFC：0227-server-module-conventions\]\]  
\[\[译：React RFC：0188-server-components\]\]  
[Making Sense of React Server Components](https://www.joshwcomeau.com/react/server-components/)  
[Streaming Server-Side Rendering](https://www.patterns.dev/react/streaming-ssr)  
[Introducing Zero-Bundle-Size React Server Components – React](https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components)  
[‘use client’ directive – React](https://react.dev/reference/react/use-client#use-client)
