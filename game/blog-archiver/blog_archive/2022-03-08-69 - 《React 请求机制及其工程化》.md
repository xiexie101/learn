---
title: "69 - 《React 请求机制及其工程化》"
date: 2022-03-08
url: https://sorrycc.com/react-request-solution-and-engineering
---

发布于 2022年3月8日

# 69 - 《React 请求机制及其工程化》

说到数据加载机制可能要回到好多年前，那会前端比较关注性能，比如我参与过的淘宝首页和宝贝详情页，都会做垂直的定制优化，让请求再页面最早加载，甚至在前一个页面就预加载。最近几年做中后台，这部分关注少了，直到最近 Remix 和 React 18 Suspense 的出现，这个主题又被社区讨论起，并且越来越清晰了。

总的来说是 3 种加载策略，见图 1。举个例子，比如有 3 个组件，C1、C2、C3，每个组件一个请求，F1、F2、F3。

1、渲染时请求。

这应该是最常见的，就是在组件的 useEffect hooks 里发起请求，比如 swr、react-query、use-request 都属于此类。

```tsx
useEffect(() => fetch(url).then(() => { … }));
```

但有个问题是请求和渲染的瀑布问题。前述例子的加载方式是「渲染 C1 ▶ 请求 F1 ▶ 渲染 C2 ▶ 请求 F2 ▶ 渲染 C3 ▶ 请求 F3」。这就很慢了，也不是不能用，看场景，比如中后台场景，大概率不在意这点慢的问题，但前台应用会比较在意。

2、请求后渲染。

基于 1 的优化，把 F1、F2、F3 三个请求前置，用 Promise.all 统一请求，拿到数据后统一渲染 C1、C2 和 C3。

```tsx
useEffect(() => Promse.all([F1,F2,F3]))
```

这解了 1 的瀑布流问题，但也引入了新的问题，请求完成之前页面是空白的。

3、边请求边渲染

基于 2 的优化，使用 Suspense 把请求和渲染并行化，数据好了后以最快速度完成渲染。

```tsx
fetchSuspense()
<Suspense><C1><C2><C3 /></C2></C1></Suspense>
```

以上是理论，大家可以在 Demo 项目中试试。

而要用到项目或框架中被很多人使用，还要考虑不少工程化的问题。比如 C1、C2、C3 的请求写在哪，是拆分单独的问题还是和组件写一起，推荐肯定是写一起，但写一起就要考虑拆分，因为不拆分就会和组件的 JS 放一起，那得等到组件加载完成之后才能发起请求，就又慢了。所以要做地好，会涉及文件拆分、code splitting 策略等工程化的思路。

其中文件拆分可参考 [63 - 《ESBuild 和 Webpack 的 Tree Shaking 差异及其用途》](https://sorrycc.com/esbuild-webpack-tree-shaking) 介绍的思路，利用 esbuild 把请求部分拆出来；code splitting 是指拆出来的请求应该和主 JS 放一起，这样就能在匹配完路由之后就发起所有匹配路由的请求，从而让页面更快完成渲染。

![](https://img.alicdn.com/imgextra/i2/O1CN015ayxsS1LTRo29f8aO_!!6000000001300-0-tps-1501-1080.jpg)

参考  
[A Fundamental Guide To React Suspense | A technical blog by Chak Shun Yu](https://www.chakshunyu.com/blog/a-fundamental-guide-to-react-suspense/)  
[React Server Components and Remix | Remix](https://remix.run/blog/react-server-components)  
[https://www.yuque.com/mdh/weekly/bfkldi#aa6d7963](https://www.yuque.com/mdh/weekly/bfkldi#aa6d7963)
