---
title: "505 - 《前端，本应更快》"
date: 2024-12-30
url: https://sorrycc.com/f2e-should-be-faster
---

发布于 2024年12月30日

# 505 - 《前端，本应更快》

> 上个月末在内网写的一篇长文，脱敏后贴下到这里，方便我在后面的文章里 ref 。

1、现状。

之前偶尔翻到「内部蚂蚁体验」的网站，体验并不好。超长的 loading 时间，很明显的加载瀑布流。如果打开控制台，会发现他需要加载 90 多个 js 资源，光 react-dom.production.min.js 就被加载了 6 份，就这居然还没有冲突。

图：蚂蚁体验的加载效果图。（脱敏后删除）

![](https://tcc.sorrycc.com/p/1d700935-a439-4417-9536-9c5dce448b22.png)

加载瀑布流这个问题应该是随着组件化而来的，就算制作精良的雨燕也不能幸免。只要你用 useEffect 加载数据，就会有；就算不用，也可能有，比如下层组件依赖上层组件的数据。

图：雨燕的加载效果图。（脱敏后删除）

同时，我们上的一些技术方案也多多少少加剧了这类性能问题，都是权衡。比如一些庞大的三方库、全站微前端、auto externals、esbuild as minifier、mako 等等，方案肯定都是为解问题而生，但他们也多少以牺牲部分 UX 为代价。

此外，我们在请求缓存、stale-while-revalidate、基于路由的 load 和 preload 策略上都实践甚少。而这些是提升页面 load 之后的请求交互和路由切换速度感体验的关键。一些标杆产品比如雨燕和语雀，其首页模块都实现了 stale-while-revalidate（或者只是缓存），见下图，但如果加上 preload，会让首次切换也有秒开的体验，UX 会更好。

图：两张内部网站的交互图（脱敏后删除）

Ant Design Pro 默认的脚手架和我们通过工具产出的页面和组件也无这些方案。

![](https://tcc.sorrycc.com/p/d9a511d8-207b-4f55-99dc-6fe0f7c458b5.gif)

2、基于路由的 load、preload、缓存 和 stale-while-revalidate。

每个方案都有接入成本，这也是为啥虽然这些方案体验好，但覆盖率都挺低，比如语雀大部分的切换都是无缓存刷新的。而覆盖率就决定了整体的 UX 体验。之前也写过[《最佳实践 2022-8：请求方案最佳实践》](https://yuque.antfin.com/yunqian/write/mg2t2wpiypa80agx) 和[《Bigfish 4 特性 03：默认最快的请求》](https://yuque.antfin.com/yunqian/write/znhux4)，但出于推广、研发习惯、接入和培训成本等因素，这些方案目前都比较少人使用。

![](https://tcc.sorrycc.com/p/53c64bcf-eb53-4716-a59e-3132522b9113.gif)

从接入成本来看，缓存和 stale-while-revalidate 其实还好，只要借助 [swr](https://github.com/vercel/swr) 或 [@tanstack/query](https://tanstack.com/query/v5/docs/framework/react/overview) 库就可以。但 (pre)load 就要复杂一些，得借助编译时，通常需要框架配合。同时 (pre)load 需要 load 的除了 loader 方法（请求），还有 js、css、assets 等，这就需要借助构建工具和框架，让 url、请求和静态资源文件之间有个映射关系。

所以，如果这些方案我们全都要，同时还想要较少的接入成本，只用 swc 或 @tanstack/query 是不够的。需要基于路由定义 loader 方法，然后让框架内置 mini 版的 swr 或 @tanstack/query，处理请求的缓存和 stale-while-revalidate，以及对路由对应的 component 所需的 js 和 css 做代码拆分和按需加载。同时，这一切都要保证最大可能并发。

然后用户只需要这么定义 loader。当然，实际情况还会更复杂一些，比如，1）如何拆分 loader 和 component，loader 应该随主包，因为比较小而且需要尽早发起以避免请求瀑布流，2）子路由依赖父路由的数据怎么办？方法比较多，通过 context 或者显式依赖另一个路由的数据等。

```ts
// src/pages/users.tsx
export async function loader() {
  return await fetch('/api/users');
}
```

以下是基于这些做的 [hackernews 方案](https://github.com/umijs/tnf/tree/master/examples/hackernews)，可以看到，只要别点那么快…，就可以实现切换秒开。同时具备 stale-while-revalidate，在已有数据时会先用缓存再更新。

![](https://tcc.sorrycc.com/p/fb0ca5cd-1907-490a-ada5-41d8e913cef2.gif)

3、[@tanstack/router](https://tanstack.com/router/latest) 和 [tnf](https://github.com/umijs/tnf)。

![](https://tcc.sorrycc.com/p/e671bfea-39fc-432f-ac21-dca4717ce7c5.png)

之前 Umi 有做过 load 和 preload，参考 《Bigfish 4 特性 03：默认最快的请求》，也有推荐过 @tanstack/query 作为请求最佳实践，参考《最佳实践 2022-8：请求方案最佳实践》。但始终觉得还差点意思，直到看到 [@tanstack/router](https://tanstack.com/router/latest) 把这两件事合到一起。

就性能这一点而言，@tanstack/router 基于路由定义 loader 和 component，考虑 component 的代码拆分和动态加载，考虑 loader 的 (pre)load，同时内置了一个 mini 版的 @tanstack/query 来处理请求的缓存和 stale-while-invalidate 。

我觉得这就是我期望的样子，所以基于此做了 [tnf](https://github.com/umijs/tnf)（名字待定）。先只说性能这一点，我希望就 CSR 而言，tnf 会是默认性能最好的框架。除了前面提的，要做到默认性能好，有太多需要关注的点，而这些点，一线新手开发不太可能面面俱到，内置到框架里可以应用到所有业务。

好性能应是默认配置。

4、如何快。

就 CSR 而言，我觉得快的产品应是这样。（注：有些点对 SSR、RSC 也合适）

1）产物尺寸小  
2）下载尺寸少  
3）请求策略妥  
4）渲染性能佳

产物尺寸小是个复杂的工程。

现在有些方案会损坏这一点，需要斟酌着用。比如 external 虽然能提速和利用 cdn 缓存，但因为不能参与 tree shaking，整体尺寸肯定是增加的，参考《炮轰 externals：迟到两年的大字报》；比如 module federation 虽然能做 export 级的按需加载，但无法做到 tree shaking 级别，所以整体尺寸相比 external 有缓解但也会增加，而且请求数会增加；比如之前做的 esbuild as minifier，会让压缩提速从而让构建提速，但缺点是产物尺寸增加 10%；比如很多内部包是不 tree shaking 友好的，有些 main 入口是 cjs 格式的 index.min.js，有些只提供 cjs 产物而没有 esm 产物，之前在《消费圈产物结构分析》里有看到一些；比如用 Mako 虽然快，但在 tree shaking 和 code splitting 效果上看场景可能会比 webpack 差一些。

其他还会有影响产物尺寸的，比如像 monaco-editor 和 g2 之类的大依赖没有做动态加载，比如相似依赖重复使用像 lodash 和 lodash-es，比如加载不必要的补丁像是不需要支持 ie 的网站也用了全量的补丁和不必要的转义语言时需要的 helper 方法，比如非首屏所需的组件没有做按需加载，比如依赖了实际并不需要的依赖，等等。

下载尺寸少主要是 Code Splitting，目的是让你访问某个路由时所需下载的 js 和 css 更少，还需综合考虑缓存更新等因素。我在《最佳实践 2022-4：拆包策略》里有详细介绍。此外，辟起之前做的《RFC-22 子路由资源预加载提速》也算是下载类。

请求策略妥在前面有介绍。值得一提的是，请求方案是指没有银弹，不同的场景所需的请求策略是不同的。比如实时性要求高、安全敏感数据、一致性要求高、低频更新的静态内容等，就可能不适用 stale-while-invalidate 方案。所以框架层应提供整体默认配置，并允许在链接层编程覆盖。比如 preload 也有会多种策略以应对不同的场景，intent、viewport 和 render。intent 是基于意图，当用户 mouseenter 或 movestart 时 preload，viewport 是进入视图 preload，render 是渲染即 preload。

渲染性能佳是尽量少不必要的 re-render。框架层应确保框架 runtime 和路由层没有不必要的 re-render。同时（考虑）整合 React Compiler、[millon.dev](https://million.dev/)、[React Scan](https://react-scan.million.dev/)，尽量减少用户层代码的 re-render 问题。

注：一切都是权衡。

参考：  
[477 - 《TNF 开发笔记 01：工程化、路由、build、create》](https://sorrycc.com/tnf-01)  
[478 - 《TNF 开发笔记 02：Why TNF》](https://sorrycc.com/tnf-02)  
[479 - 《TNF 开发笔记 03：import order、dev、fishkit、pathe、father doctor》](https://sorrycc.com/tnf-03)  
[481 - 《TNF 开发笔记 04：CI、E2E、Config、Hackernews》](https://sorrycc.com/tnf-04)  
[483 - 《TNF 开发笔记 05：0.1.0、changesets、preview、generate、preload》](https://sorrycc.com/tnf-05)  
[485 - 《TNF 开发笔记 06：工程化、create-tnf、sync、good first issue》](https://sorrycc.com/tnf-06)  
[487 - 《TNF 开发笔记 07：重构、defineConfig、多构建器》](https://sorrycc.com/tnf-07)  
[490 – 《TNF 开发笔记 08：Pro、内部路线、卖点、插件、SSR》](https://sorrycc.com/tnf-08)
