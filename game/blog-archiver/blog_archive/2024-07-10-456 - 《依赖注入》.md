---
title: "456 - 《依赖注入》"
date: 2024-07-10
url: https://sorrycc.com/dependency-injection
---

发布于 2024年7月10日

# 456 - 《依赖注入》

> 新手笔记，欢迎指正。之前没接触过这种模式，由于要参与维护一个内部框架，他用了 inversify + reflect-metadata 做依赖注入来组织代码，所以就学习下。

1、说下概念。

在聊依赖注入（Dependency Injection，简称 DI）之前，需要先聊下 IoC。IoC 全程 Inversion of Control（控制反转），是一种设计原则，用于实现松耦合的系统，通过将对象的创建和依赖关系的管理交给外部容器或框架，让代码更加模块化和可测试。

IoC 有多种实现方法，比如 DI、事件驱动和模版方法等，其中 DI 应该是最常见的方式。DI 有 3 个核心概念，1）Dependency，2）Injection，将 Dependency 传给类，3）Container，用于管理依赖性的生命周期。

借助 TypeScript，通常可以用 reflect-metadata + inversify 实现依赖注入。

熟悉 Angular 的同学应该对此会比较熟悉，我没用过，所以对 DI 没啥概念。

2、快速上手。

```bash
$ pnpm i inversify reflect-metadata typescript father -D
```

编辑 tsconfig.json。

```json
{
  "compilerOptions": {
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "lib": [
      "esnext",
      "dom"
    ]
  }
}
```

编辑 src/index.ts 。

```ts
import 'reflect-metadata';
import { Container, injectable, inject } from "inversify";

let TYPES = {
  Foo: Symbol.for("Foo"),
  Bar: Symbol.for("Bar"),
};

@injectable()
class Foo {
  doSomething() {
    console.log(`Foo is doing something...`);
  }
}

@injectable()
class Bar {
  private foo: Foo;
  constructor(@inject(TYPES.Foo) foo: Foo) {
    this.foo = foo;
  }
  doSomething() {
    this.foo.doSomething();
    console.log(`Bar is doing something...`);
  }
}

let container = new Container();
container.bind<Foo>(TYPES.Foo).to(Foo);
container.bind<Bar>(TYPES.Bar).to(Bar);

let bar = container.get<Bar>(TYPES.Bar);
bar.doSomething();
```

编辑 .fatherrc.ts 。

```ts
export default {
  cjs: {
    output: 'dist'
  }
}
```

编译并运行，会得到如下输出。

```bash
$ npx father build
$ node dist/index.js
Foo is doing something...
Bar is doing something...
```

3、进阶用法。

1）[ContainerModule](https://github.com/inversify/InversifyJS/blob/master/wiki/container_modules.md)，用于简化 bind 的复杂性。

```ts
import { Container, ContainerModule } from "inversify";

let foo = new ContainerModule((bind) => { bind("A").to(A); bind("B").to(B); });
let bar = new ContainerModule((bind) => { bind("C").to(C); bind("D").to(D); });

let container = new Container();
container.load(foo, bar);
container.unload(foo);
```

2）[Scope](https://github.com/inversify/InversifyJS/blob/master/wiki/scope.md) 和 [Factory](https://github.com/inversify/InversifyJS/blob/master/wiki/factory_injection.md)。

Factory 用于处理带参的场景，Factory 默认是单例（Singleton）。

```ts
bind("A").toFactory((context) => {
  return (a, b, c) => {};
});
```

Scope 有 Singleton、Transient 和 Request 三种，看名字应该就能理解意思，同时不同的 to 方法调用时默认值还不同。比如 `.to()` 时默认是 Transient，如果不想每次 get 时都初始化一遍，需要改成 Singleton；而 `.toConstantValue()` 默认是 Singleton。

```ts
bind("A").to(A).inSingletonScope();
```

4、依赖注入原理。

TODO（toy-inversify），有空再研究。

参考：  
[https://github.com/inversify/InversifyJS](https://github.com/inversify/InversifyJS)  
[https://github.com/rbuckton/reflect-metadata](https://github.com/rbuckton/reflect-metadata)
