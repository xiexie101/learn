---
title: "80 - 《近期 Umi 想做的事》"
date: 2022-03-23
url: https://sorrycc.com/umi-tasks-2022-01
---

发布于 2022年3月23日

# 80 - 《近期 Umi 想做的事》

早上写了下最近 Umi 相关的想法，把脑子清空了下，下面是对外的部分，希望能给大家带来一些灵感。如果对 Umi 开发感兴趣，可以考虑参与下，门槛很低的，一个质量 ok 的 PR 即可加入 Umi Contributor 群，参与讨论和每周的 Umi 周会。

1️⃣ 支持 https（已认领）

证书基于 mkcert，没有配置 key 和 cert 时自动绑用户生成一个。

思路

1、支持配置 https: { key, cert, hosts } 开启，并可通过 key 和 cert 指定公私钥，可通过 hosts 指定绑定到本地进行调试的 host 地址  
2、hosts 默认是 localhost + 127.0.0.1  
3、如果没有配 key 或 cert，提醒用户，并通过 `mkcert -cert-file umi.pem -key-file umi.key.pem hosts.join(' ')` 自动生成到 `__dirname` 文件夹  
4、如果没有 mkcert，提示用户安装，如果是 Mac，推荐用 `brew install mkcert + brew install nss + mkcert -install` 三行命令，如果是 Windows，引导到 [https://github.com/FiloSottile/mkcert#windows，如果是](https://github.com/FiloSottile/mkcert#windows%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF) Linux，引导到 [https://github.com/FiloSottile/mkcert#linux](https://github.com/FiloSottile/mkcert#linux)  
5、主要实现代码在 bundler-webpack/src/server/server.ts 。

时间点：3.31

2️⃣ Monorepo 最佳实践（已认领）

解什么问题？

Monorepo 之前的大问题是慢，因为放在一个仓库后代码量变大了，但是有 turborepo 之后，这个问题已可大大缓解，今年值得尝试。稍重型项目会有自己的组件、文档等，通常还会有要拆子包的需求；蚂蚁中台大量微前端的应用，有在一个仓库维护主应用+多个子应用的需求。利用 Turborepo 还可实现 test、lint 等命令提速，拆地越细，由于有缓存，提速越多。

思路

1、基于 turborepo  
2、拆分 web、docs、ui、config、tsconfig 等？

ACTION

1、一个脚手架，umijs 下独立仓库  
2、一篇文档，Umi + Monorepo 最佳实践  
3、整合到 create-umi，创建项目时让用户选择是 monorepo 还是 singlerepo  
4、提供命令，一键切换普通项目为 Monorepo  
5、内部：思考如何与 devopts 流程平台结合  
6、内部：提供内部的 monorepo 脚手架（甚至默认就是 monorepo）

3️⃣ Umi UI 开发版

解什么问题？

日常排查问题时，很多 Umi 内部状态是看不到的，比如插件启用情况、appData 元数据、修改过的最终配置、修改过的最终路由、MFSU 的 module graph 信息等。如果有这些信息，对于问题排查会更有帮助，如果能可视化就更好的了，比如两次 module graph 的 diff。

思路

提供 `__umi` 路由，提供部分功能的数据展示，比如：

1、插件耗时  
2、配置信息  
3、查看路由数据  
4、实时修改产物信息  
5、appData  
6、MFSU module graph 信息  
7、…

注意：client 代码提前打包好，不参与用户代码编译，不影响开发性能。

ACTION

1、搭建 `__umi` 的架子（包含中间件、ui 的 client），让整体先 run 起来  
2、逐一添加功能

4️⃣ 添加 e2e 测试（已认领）

解什么问题？

目前 umi 仓库的单测覆盖率低，会有个逐渐补齐的过程。在此之前，想要低成本又确保功能 OK，e2e 应该是一个解。

思路

添加一个 fixture example，覆盖路由、preset-umi 里的 feature、plugins 里的功能，做 e2e 测试用。测试时先不压缩 build 再 test，用 hash 路由，不走 dev server 的方式，原因是 build 相比 dev 处理起来更简单，不需要启 dev、处理 port 冲突、监听 dev 完成等额外操作。

ACTION

1、搭建 e2e 架子，新增 test 目录，里面包含 fixtures/normal 和 normal.e2e.ts  
2、逐渐往里面补用例

5️⃣ 使用 Pino 做日志

解什么问题？

Umi 的日志都是临时性的，遇到问题时只能根据堆栈截图进行排查，这也是为啥现在会要求给复现步骤的原因。而如果能拿到结构化的完整日志，加上我们完善更多的日志信息，理论上可以达到「不需要给复现步骤就能解大部分问题」的程度。

思路

社区其实有不少解。

ACTION

1、调研 pino（[https://getpino.io/）](https://getpino.io/%EF%BC%89) 和 winston，确定用哪一个，或者有其他更好的选择（我个人倾向于用 pino）  
2、把 utils.logger 底层换成 pino  
3、dev 和 build 退出时保存日志为物理文件，存入 node\_modules/.cache/umi/logger，以 2022-03-23\_10-00-00.txt 的文件格式保存  
4、dev 和 build 出错时打印日志路径等信息，引导开发者提 issue 或问题时附上日志文件  
5、一篇文档：如何利用日志进行问题排查  
6、内部：build 介绍后上传日志到 oss，并打印出链接，引导开发者遇到问题时给链接

6️⃣ @umijs/plugin-terminal

参考 [https://github.com/patak-dev/vite-plugin-terminal，允许开发者在源码中往](https://github.com/patak-dev/vite-plugin-terminal%EF%BC%8C%E5%85%81%E8%AE%B8%E5%BC%80%E5%8F%91%E8%80%85%E5%9C%A8%E6%BA%90%E7%A0%81%E4%B8%AD%E5%BE%80) terminal 中输出信息。

解什么问题？

部分开发者会更希望在命令行里看到日志；命令行日志不会随着刷新失效；命令行日志可以做物理存储，方便其他人排查问题，参考上一条。

思路

node 侧利用中间件实现，绑定 `__terminal`，接收消息后通过 console 的方法在控制台输出；browser 侧提供临时文件 terminal.ts，发请求到 `__terminal`；开发者通过 `import terminal from '@@/terminal' + terminal.warn('Foo')` 的方式使用。

ACTION

1、在 plugins 下新增 terminal 插件  
2、一篇文档，关于如何使用

7️⃣ 调研 Rail 7 的 ESM Bundless 实现

参考：[https://github.com/rails/importmap-rails。学习](https://github.com/rails/importmap-rails%E3%80%82%E5%AD%A6%E4%B9%A0) rails 7 在 importmaps 的使用，给 esmi 方案带来更多输入。

#日更
