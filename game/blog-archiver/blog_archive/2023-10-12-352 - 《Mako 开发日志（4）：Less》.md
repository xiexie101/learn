---
title: "352 - 《Mako 开发日志（4）：Less》"
date: 2023-10-12
url: https://sorrycc.com/mako-devlog-04
---

发布于 2023年10月12日

# 352 - 《Mako 开发日志（4）：Less》

1、Mako 过程中有个分歧的点是 Less 怎么办？由于历史原因，我们有大量的 Less 项目，找一个没有 Less 的项目都很难。然后 Mako 支持 Less 有几种策略，1）不支持，遇到了通过 codemod 脚本修改 less 为 css，2）用 Rust 写一个 Lite Less，见 \[\[RFC：Less Lite\]\]，3）用官方 less 包编译 less。前两个都尝试过，但最终向现实低头，为了能更快地推进项目落地，先选择了 3，缺点是会降低速度。

2、我们先是实现了一个 less2css。为了减少 diff，我们做了一些场景区分。1）大部分开发者 less 只是用了 css nesting 语法，而 css nesting 我们是内置支持的，这种场景只要把 .less 改成 .css 就好。2）探测到不支持的语法时，会用 lessc 编译一次用户的 less 文件生成 css 文件，并修改 import 他的地方。然后我们遇到一个跳不过的场景，就是 less 可能是间接依赖，比如用户先依赖 foo/index.js，然后 foo/index.js 依赖了 foo/index.less。

3、然后又设计了基于 Rust 的 Lite Less。一开始觉得大家用 Less 不会用太深，把 Less 的功能梳理了一遍，想着用 Rust + SWC 实现一遍也不太麻烦。RFC 都写完了，然后也是遇到一个跳不过的场景。我们发现业务代码虽然不会很深地用 less，但 antd 会，他用了 Less 里的各种 Function，这个用 JS 实现还好，用 Rust 实现复杂度就太高了。RIO 太低，同时时间不允许，放弃。

4、最后回到用 less 编译 less 的方案，这是最不愿意看到的，因为一旦用上 less，项目的编译速度就会被拉满。这个方案也是踩了一些坑才走到最终方案的。

5、怎么用 less 编译 less？npm i less，然后 `npx lessc /path/to/xxx.less` 不就好了？其实远远不够。比如需要支持 alias，支持 node\_modules 下依赖的 import，支持 `~` prefix 的依赖 import，等等。换句话说，是要在 webpack 之外使用 less，但同时要达到和在 webpack 里用 less 一样的效果。less 本身的 resolve 功能是比较弱的，比如 `@import "foo/foo.less"`，这个 `foo/foo.less` 从哪里找会有很多考虑，less 虽然支持通过 include\_path 支持找依赖的路径配置，但和传统的 node 的 resolve 机制还是相差不少。

6、我们先是 fork 了一份 less-plugin-aliases 做支持，但发现怎么改都有 bug。然后目前的「最终」方案是参考 less-loader，在查找依赖时，直接用 enhanced-resolve 直接代替了 less 本身的 resolve 机制，这样就和之前用 webpack 时处理 less 保持完全一致了。

参考：  
[https://github.com/sorrycc/less-plugin-aliases-fork](https://github.com/sorrycc/less-plugin-aliases-fork)  
[https://github.com/webpack-contrib/less-loader](https://github.com/webpack-contrib/less-loader)
