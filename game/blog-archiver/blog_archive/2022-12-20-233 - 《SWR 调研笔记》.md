---
title: "233 - 《SWR 调研笔记》"
date: 2022-12-20
url: https://sorrycc.com/swr-notes
---

发布于 2022年12月20日

# 233 - 《SWR 调研笔记》

SWR 是请求方案调研的第二站，以下是阅读文档和 Demo 后的笔记。SWR 虽然库下载量比 React Query 还大（大部分归功于 Next.js），但从功能上看，感觉和 React Query 不是一个体量的，最近（2022.12.9）发布的 SWR 2 的大部分功能个人感觉也是在追赶 React Query。SWR 的优点我理解是，1）用法简单，封装度更高但是把双刃剑，2）有中文文档。

1、关于错误处理。1）useSWR 会返回 error 对象，2）用 fetch 库的记得手动处理非 2xx 状态码，3）请求错误时会默认用指数退避算法重发请求，可通过 onErrorRetry 覆盖该行为，4）通过 SWRConfig 可全局定制 onError 方法，用于显示 toast、报告到 Sentry 等。

2、SWR 提供了多种方法做数据突变。1）全局的 mutate 方法，可以从 swr import，也可以通过 useSWRConfig 获取（推荐），2）useSWR 会返回一个绑定了 key 的 mutate 方法，3）基于 useSWRMutation 独立状态的命令式突变（V2 加的，推荐）。mutate 方法承载了多个功能，1）不传 data 即为 revalidation，通过传入 fn 格式的 key 可支持批量，2）传 data 为直接变更数据，3）data 为 async function 时做远程数据突变，4）通过 optimisticData 选项提供乐观更新的数据，然后通过 rollbackOnError 决定是否在出错时回滚，5）useSWRMutation 返回的 isMutating 可用于防止重复提交。

3、分页有几种典型场景，1）普通分页，2）无限加载。1 + 简单场景的 2 直接用 useSWR 来解即可，一旦遇到进阶场景的 2 时，比如基于游标分页、父元素需要知道子元素的数据，就需要切换到 useSWRInfinite。useSWRInfinite 的区别是其 getKey fn 会接受 pageIndex 和 previousPageData（上一页数据），同时会返回 size 和 setSize，加载下一页可以 setSize(size+1)。

4、预请求数据用多种办法，1）顶级请求推荐 link rel=“preload”，2）swr 有提供 preload 方法，可以手动做预请求，命令式的，放在 module 顶级或者事件里均可。一些注意点，1）Suspense 模式下记得做 preload 以避免请求瀑布流问题，2）useSWR 的 fallbackData 配置项可用于预填充数据，还没请求到数据时作为 fallback 使用。

5、与 Next.js 搭配做 SSG 或 SSR 时，可以把服务端获取的数据设置到 SWRConfig 的 fallback 属性里，以 key 为 key，然后里面用 useSWR 获取时，就会识别这个全局的 fallback 配置。注意，复杂 key 要用 unstable\_serialize 包一下。

6、SWR 支持 Suspense 模式但不推荐用。1）加 suspense: true 即可开启，2）需搭配 preload 一起用，否则会有请求瀑布流问题，3）使用条件请求或依赖请求时，data 仍有可能是 undefined。

7、关于缓存。1）SWR 可通过配置 provider 来定制缓存，缓存要求 Map 类型，比如 provider: () => new Map()，2）通过 const { cache } = useSWRConfig() 可访问当前缓存，但不要手动更新缓存，更新请用 mutate 方法，3）一个常用场景是测试时用于切个不用用例之间的缓存数据。

参考：  
[https://swr.vercel.app/zh-CN](https://swr.vercel.app/zh-CN)  
[https://swr.vercel.app/zh-CN/blog/swr-v2](https://swr.vercel.app/zh-CN/blog/swr-v2)
