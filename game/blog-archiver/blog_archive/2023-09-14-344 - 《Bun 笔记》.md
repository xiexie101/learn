---
title: "344 - 《Bun 笔记》"
date: 2023-09-14
url: https://sorrycc.com/bun
---

发布于 2023年9月14日

# 344 - 《Bun 笔记》

趁着 Bun 正式版发布之际，翻了下 Bun 的文档，做下笔记。

1、我其实已经有 1 年 Bun 的使用经验，从 Bun 内测时就开始用。但是基本上只用 bun run 命令来跑 package.json script，我为此还设了个 br 的 alias，alias br=“bun run”。相比 npm run 明显感觉会更快，6ms vs. 170ms 这个对比量级，虽然每次都只快个毫秒级，但对于每天跑几十次的命令来说，加起来也应该是有省了一些时间的。另外，速度可以带来 DX（开发体验的提升）。

2、Bun 包含多个功能或角色，比如 Runtime、Package manager、Test runner、Bundler 和 Package runner。

* * *

Runtime

3、作为 Runtime Bun 可以做两件事，1）执行文件，2）执行 package.json script。命令都是 `bun run`，前者比如 `bun run foo.ts`，后者比如 `bun run dev`。执行文件有不少附加功能。比如支持加前置 --watch flag 启用监听模式，`bun --watch run foo.ts` 文件变更时会自动 reload；比如支持 ts、tsx 甚至 wasm；比如内置 Bun API，可以做 serve、build、io、child process、tcp、sqlite、ffi 等；比如支持非 BOM 的 Web API；比如兼容 node，但还有大量工作未完成。

4、Bun 支持插件。插件可以扩展 Runtime 或 Bundler。扩展 Bundler 的接口看着和 esbuild 有点像，最常见的需求应该是用来加 loader 支持某个 Bun 内置不支持的文件类型。

```ts
import { plugin } from "bun";
plugin({ name: 'foo', async setup(build){
  build.onLoad();
  build.onResolve();
  build.config.minify = true;
} });
```

* * *

Package Manger

5、作为 Package Manger，官方数据是 bun install 在有缓存的场景下比 npm install 快 25 倍。我早上试过用 bun install 安装 umi 项目的依赖，然后在用 node runtime 跑 umi，可以正常跑。除了 install，相关的命令还有 add、remove、link。有个特别的功能是，bun install 出于安全考虑默认不会执行依赖的 lifetime script，但除非把依赖到到 trustedDependencies 里，这是新搞的概念，和现有生态不兼容，感觉不一定是件好事。

6、install 有全局缓存，默认在 ~/.bun/install/cache 里。Bun 会优先用 Cache 中匹配的依赖，所以会快。注意，是用匹配的，而不是最优的，比如依赖写了 ^1，如果缓存里有 1.1，而最新版是 1.2，那 Bun 会安装到 1.1 而不是 1.2。Bun 从缓存到 node\_modules 是有多种策略的，Linux 下默认是 hardlink，Mac 下默认是 clonefile，这两个从速度上都是最快的，但 Mac 下的 clonefile 会复制文件，所以从尺寸上并不是最优的。

7、install 支持 workspace，和 npm 的声明方式一致，在 package.json 中通过 workspaces 声明，比如 `"workspaces": ["packages/*"]`。

8、install 会生成 lock 文件 bun.lockb。和其他竞品用 json、yaml 格式不同，bun 的 lock 文件是可执行文件，原因是为了「性能」。注，1）加 --no-save 可以不生成 lock 文件，2）加 --yarn 可以额外生成 yarn 格式的 lockfile 方便查看依赖结构。

* * *

Bundler

9、从 [Benchmark](https://github.com/oven-sh/bun/tree/main/bench/bundle) 看，Bun 的构建比 esbuild 还快，相差 1.76 倍。构建可以命令行调，`bun build ./index.ts --outdir ./build`，也可通过 API 的方式调，`await Bun.build({ entrypoints, outdir });` 。支持加 `--watch` 进入 watch mode。

10、Bun 的 Bundle 整体和 esbuild 非常像，包括参数、API、Plugin 写法、产物格式等。当时看作者的 Twitter，应该是从 esbuild 复刻过来的，包括测试用例。区别是，1）target 里有个 bun，产物可以在 Bun Runtime 里运行，2）format 目前仅支持 esm，3）产物尺寸/TREE Shaking 效果（TODO）。

11、bun build 加 `--compile` 参数可以产出可执行文件。缺点是产物会包含 Bun 的 runtime，所以非常大，Mac 下试了一个 Hello World 有 48 M。看到这个，我想到的是想用他给 Less 源码打个包，看看能不能提速。

12、Bun 有个有趣的特性是支持宏（macros）。即在构建时执行源码，源码不会被包含在产物里，而是把源码的执行结果包含在产物里。如果执行失败，构建也将失败。比如有个 `export function random() { return Math.random() }` 的文件，我们通过 `import {random} from '这个文件' with { type: 'macro' }; console.log(random());` 的方式引用他，产物里会直接是 `console.log(0.1234567)` 。Webpack 阶段也有对应方式，当时是通过 babel-plugin-macros 来实现的。注意：宏的结果必须是可序列化的，因为需要将其转成 ast 塞回源码里去。

* * *

Test Runner

13、命令是 bun test，然后通过 bun:test 虚拟模块提供了 expect、test、describe、mock、spyOn、beforeEach、beforeAll、afterEach、afterAll、setSystemTime 等方法。主打一个快，bun test 跑测试比 jest --version 输出版本号都快。常用的测试功能一应俱全，支持 UI 和 DOM 测试、JSX 和 TypeScript、Snapshot、watch 模式等。jest 被诟病依旧的不支持 esm 应该也没问题吧，（TODO：待验证）。

14、bun test 有几个有用的参数。1）–watch，2）–preload，3）–coverage。

* * *

Package Runner

15、Package Runner 的功能是自动安装并执行一个 npm 包，和 npx 或 yarn dlx 的功能类似，比如 `bunx cowsay "hello world"`。据说速度比 npx 快 100 倍。通常，npm 包的 bin 里会声明 `#!/usr/bin/env node`，要求用 node 来跑，Bun 会尊重这个。如果想要用 Bun Runtime 来跑怎么办？加 --bun，注释得加在 bunx 后面而不是 npm 包后面，加后面的参数是给 npm 包用的，比如 bunx --bun my-cli --foo --bar。

参考：  
[147 - 《bun》](https://sorrycc.com/what-is-bun)  
[https://bun.sh/](https://bun.sh/)

* * *
