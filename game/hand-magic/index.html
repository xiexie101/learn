<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>Ethereal Touch: Ultimate Edition</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* æ‘„åƒå¤´ï¼šåº•å±‚ï¼Œé•œåƒï¼Œä½é€æ˜åº¦ */
        #input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.15;
            z-index: 1;
            filter: grayscale(100%) contrast(1.2);
        }

        /* ç”»å¸ƒï¼šé¡¶å±‚ï¼Œé•œåƒï¼ŒGPUåŠ é€Ÿ */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            transform: scaleX(-1);
            pointer-events: none;
            will-change: transform;
        }

        /* UI */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #00ffcc;
            background: rgba(0, 20, 20, 0.7);
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #00ffcc;
            pointer-events: none;
        }

        .row {
            margin-bottom: 5px;
            font-size: 13px;
            text-shadow: 0 0 5px rgba(0, 255, 200, 0.5);
        }

        .highlight {
            color: #ffaa00;
            font-weight: bold;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>

<body>

    <div id="container">
        <video id="input_video" playsinline></video>
        <div id="ui">
            <div class="row" id="status">SYSTEM: INITIALIZING...</div>
            <div class="row" id="shape">SHAPE: SPHERE</div>
            <div class="row" id="gesture">GESTURE: SEARCHING</div>
            <div class="row" id="snap">SNAP: READY</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. åˆå§‹åŒ–åœºæ™¯ (Scene Setup)
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03); // å¢åŠ æ·±é‚ƒæ„Ÿ

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // ==========================================
        // 2. å½¢çŠ¶ç”Ÿæˆå™¨ (Shape Generators)
        // ==========================================
        function getSpherePoint() {
            const r = 3.5 * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            return new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }

        function getRingPoint() {
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI * 2;
            const R = 4.0; // å¤§åŠå¾„
            const r = 1.0 * Math.random(); // ç®¡å¾„éšæœºï¼Œåˆ¶é€ å¼¥æ•£æ„Ÿ
            return new THREE.Vector3(
                (R + r * Math.cos(v)) * Math.cos(u),
                (R + r * Math.cos(v)) * Math.sin(u),
                r * Math.sin(v) * 0.5 // å‹æ‰ä¸€ç‚¹
            );
        }

        function getHeartPoint() {
            // 3D Heart Formula
            const t = Math.random() * Math.PI * 2;
            const s = 0.25;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            const z = (Math.random() - 0.5) * 6;
            return new THREE.Vector3(x * s, y * s, z);
        }

        // â­ æ˜Ÿå½¢ - äº”è§’æ˜Ÿç«‹ä½“åŒ–
        function getStarPoint() {
            const points = 5;
            const outerR = 4.0;
            const innerR = 1.8;
            const t = Math.random() * Math.PI * 2;
            const isOuter = Math.floor(t / (Math.PI / points)) % 2 === 0;
            const r = (isOuter ? outerR : innerR) * (0.8 + Math.random() * 0.4);
            const x = r * Math.cos(t);
            const y = r * Math.sin(t);
            const z = (Math.random() - 0.5) * 3;
            return new THREE.Vector3(x, y, z);
        }

        // ğŸŒ€ èºæ—‹ - ä¸Šå‡èºæ—‹çº¿
        function getSpiralPoint() {
            const t = Math.random() * Math.PI * 6; // 3åœˆ
            const r = 2.0 + t * 0.3; // é€æ¸æ‰©å¤§
            const x = r * Math.cos(t);
            const z = r * Math.sin(t);
            const y = (t - Math.PI * 3) * 0.8; // å‚ç›´åˆ†å¸ƒ
            // åŠ ç‚¹éšæœºæŠ–åŠ¨
            return new THREE.Vector3(
                x + (Math.random() - 0.5) * 0.5,
                y + (Math.random() - 0.5) * 0.5,
                z + (Math.random() - 0.5) * 0.5
            );
        }

        // ğŸ§¬ DNAåŒèºæ—‹
        function getDNAPoint() {
            const t = Math.random() * Math.PI * 8; // 4åœˆ
            const strand = Math.random() > 0.5 ? 0 : Math.PI; // åŒé“¾åç§»
            const r = 2.5;
            const x = r * Math.cos(t + strand);
            const z = r * Math.sin(t + strand);
            const y = (t - Math.PI * 4) * 0.6;
            // è¿æ¥æ¡¥ï¼ˆæ¨ªæ ï¼‰
            if (Math.random() < 0.15) {
                const bridgeT = Math.floor(t / 0.5) * 0.5;
                const bx = (Math.random() - 0.5) * r * 2;
                return new THREE.Vector3(bx, (bridgeT - Math.PI * 4) * 0.6, 0);
            }
            return new THREE.Vector3(x, y, z);
        }

        // ğŸ“¦ ç«‹æ–¹ä½“ - ç²’å­åˆ†å¸ƒåœ¨è¡¨é¢
        function getCubePoint() {
            const size = 3.5;
            const face = Math.floor(Math.random() * 6);
            let x, y, z;
            const u = (Math.random() - 0.5) * 2 * size;
            const v = (Math.random() - 0.5) * 2 * size;
            switch (face) {
                case 0: x = size; y = u; z = v; break;  // +X
                case 1: x = -size; y = u; z = v; break; // -X
                case 2: y = size; x = u; z = v; break;  // +Y
                case 3: y = -size; x = u; z = v; break; // -Y
                case 4: z = size; x = u; y = v; break;  // +Z
                case 5: z = -size; x = u; y = v; break; // -Z
            }
            return new THREE.Vector3(x, y, z);
        }

        // ==========================================
        // 3. ä¸»ç²’å­ç³»ç»Ÿ (Main System)
        // ==========================================
        class MainParticleSystem {
            constructor(scene) {
                this.count = 3000;
                this.shapes = ['SPHERE', 'RING', 'HEART', 'STAR', 'SPIRAL', 'DNA', 'CUBE'];
                this.currentShapeIdx = 0;
                this.isPalmUpLocked = false; // ç”¨äºå»æŠ–åŠ¨

                // æ•°æ®æ•°ç»„
                const geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.count * 3);
                this.targetPositions = new Float32Array(this.count * 3); // å½“å‰ç›®æ ‡å½¢çŠ¶
                const colors = new Float32Array(this.count * 3);
                const sizes = new Float32Array(this.count);

                const colorBase = new THREE.Color(0x00ffff);

                for (let i = 0; i < this.count; i++) {
                    // åˆå§‹å½¢æ€
                    const p = getSpherePoint();
                    this.positions[i * 3] = p.x;
                    this.positions[i * 3 + 1] = p.y;
                    this.positions[i * 3 + 2] = p.z;

                    // å­˜å…¥ç›®æ ‡
                    this.targetPositions[i * 3] = p.x;
                    this.targetPositions[i * 3 + 1] = p.y;
                    this.targetPositions[i * 3 + 2] = p.z;

                    colors[i * 3] = colorBase.r;
                    colors[i * 3 + 1] = colorBase.g;
                    colors[i * 3 + 2] = colorBase.b;
                    sizes[i] = Math.random() * 0.2;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                this.material = new THREE.PointsMaterial({
                    size: 0.2, vertexColors: true, blending: THREE.AdditiveBlending,
                    depthWrite: false, transparent: true, opacity: 0.8
                });

                this.mesh = new THREE.Points(geometry, this.material);
                scene.add(this.mesh);
                this.geometry = geometry;
            }

            // å½¢çŠ¶ç”Ÿæˆå™¨æ˜ å°„è¡¨
            getShapePoint(shapeName) {
                switch (shapeName) {
                    case 'SPHERE': return getSpherePoint();
                    case 'RING': return getRingPoint();
                    case 'HEART': return getHeartPoint();
                    case 'STAR': return getStarPoint();
                    case 'SPIRAL': return getSpiralPoint();
                    case 'DNA': return getDNAPoint();
                    case 'CUBE': return getCubePoint();
                    default: return getSpherePoint();
                }
            }

            // åˆ‡æ¢å½¢çŠ¶é€»è¾‘
            cycleShape() {
                this.currentShapeIdx = (this.currentShapeIdx + 1) % this.shapes.length;
                const shapeName = this.shapes[this.currentShapeIdx];
                document.getElementById('shape').innerText = `SHAPE: ${shapeName}`;

                // é‡æ–°è®¡ç®—ç›®æ ‡ä½ç½®
                for (let i = 0; i < this.count; i++) {
                    const p = this.getShapePoint(shapeName);
                    this.targetPositions[i * 3] = p.x;
                    this.targetPositions[i * 3 + 1] = p.y;
                    this.targetPositions[i * 3 + 2] = p.z;
                }
            }

            update(handData, time) {
                const positions = this.geometry.attributes.position.array;
                const targetPos = this.targetPositions;

                // 1. å¤„ç†æ‰‹åŠ¿çŠ¶æ€æœº
                // å¦‚æœæ‰‹æŒå¹³æ‘Š (SideFactor < 0.4) ä¸”ä¹‹å‰æ²¡é” -> åˆ‡æ¢å½¢çŠ¶
                if (handData.verticalFactor < 0.4) {
                    if (!this.isPalmUpLocked) {
                        this.cycleShape(); // è§¦å‘åˆ‡æ¢
                        this.isPalmUpLocked = true;
                    }
                } else if (handData.verticalFactor > 0.6) {
                    // å¦‚æœæ˜æ˜¾ä¾§ç«‹ï¼Œè§£é”ï¼Œå…è®¸ä¸‹æ¬¡å˜å›å¹³æ‘Šæ—¶å†æ¬¡åˆ‡æ¢
                    this.isPalmUpLocked = false;
                }

                // 2. ç²’å­è¿åŠ¨å¾ªç¯
                // SideFactor è¶Šå¤§ï¼Œæ‰©æ•£è¶Šå‰å®³
                const spread = 1.0 + (handData.verticalFactor * 4.0);

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;

                    // å–å‡ºå½¢çŠ¶ç›®æ ‡
                    const tx = targetPos[i3];
                    const ty = targetPos[i3 + 1];
                    const tz = targetPos[i3 + 2];

                    // å™ªç‚¹ (ä¾§ç«‹æ—¶æŠ–åŠ¨å¤§)
                    const noiseAmp = handData.verticalFactor * 0.5 + 0.05;
                    const nx = Math.sin(time * 3 + i) * noiseAmp;
                    const ny = Math.cos(time * 2 + i) * noiseAmp;
                    const nz = Math.sin(time * 5 + i) * noiseAmp;

                    // æœ€ç»ˆä½ç½® = æ‰‹éƒ¨æ‚¬æµ®ä½ + (å½¢çŠ¶ä½ * æ‰©æ•£) + å™ªç‚¹
                    // ä½¿ç”¨ Lerp å¹³æ»‘è¿‡æ¸¡
                    positions[i3] += ((tx * spread + handData.hoverPos.x + nx) - positions[i3]) * 0.1;
                    positions[i3 + 1] += ((ty * spread + handData.hoverPos.y + ny) - positions[i3 + 1]) * 0.1;
                    positions[i3 + 2] += ((tz * spread + handData.hoverPos.z + nz) - positions[i3 + 2]) * 0.1;
                }
                this.geometry.attributes.position.needsUpdate = true;
                this.mesh.rotation.y = time * 0.2; // è‡ªè½¬
            }
        }

        // ==========================================
        // 4. å“æŒ‡ç‰¹æ•ˆç³»ç»Ÿ (Snap System)
        // ==========================================
        class SnapSystem {
            constructor(scene) {
                this.count = 60;
                this.mode = 'IDLE'; // IDLE, CHARGING, EXPLODING
                this.timer = 0;

                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.count * 3);
                const sizes = new Float32Array(this.count);
                // åˆå§‹éšè—
                for (let i = 0; i < this.count * 3; i++) positions[i] = 0;

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                this.material = new THREE.PointsMaterial({
                    color: 0xffaa00, // é‡‘è‰²
                    size: 0.15, transparent: true, opacity: 0,
                    blending: THREE.AdditiveBlending, depthTest: false
                });

                this.mesh = new THREE.Points(geometry, this.material);
                scene.add(this.mesh);
                this.geometry = geometry;
            }

            update(fingersCenter, isTouching, time) {
                // ç›®æ ‡ä½ç½®ï¼šæŒ‡å°–ä¸Šæ–¹ 5cm (World Y + 3.0)
                // å¤ç”¨å‘é‡é¿å…æ¯å¸§clone
                this._target = this._target || new THREE.Vector3();
                const target = this._target.copy(fingersCenter);
                target.y += 3.0;

                if (isTouching) {
                    // --- æ‘©æ“¦/è“„åŠ›é˜¶æ®µ ---
                    this.mode = 'CHARGING';
                    this.material.opacity = 1.0;
                    this.material.color.setHex(0xaaffff); // é’ç™½äº®å…‰
                    this.material.size = 0.1;

                    const pos = this.geometry.attributes.position.array;
                    for (let i = 0; i < this.count; i++) {
                        // æåº¦ç´§ç¼©çš„é«˜é¢‘æŠ–åŠ¨ç‚¹
                        pos[i * 3] = target.x + (Math.random() - 0.5) * 0.2;
                        pos[i * 3 + 1] = target.y + (Math.random() - 0.5) * 0.2;
                        pos[i * 3 + 2] = target.z + (Math.random() - 0.5) * 0.2;
                    }
                    this.geometry.attributes.position.needsUpdate = true;
                    document.getElementById('snap').innerText = "SNAP: CHARGING...";
                    document.getElementById('snap').style.color = "#00ffff";

                } else {
                    // --- é‡Šæ”¾/çˆ†å‘é˜¶æ®µ ---
                    if (this.mode === 'CHARGING') {
                        // åˆšæ¾æ‰‹ï¼Œè§¦å‘çˆ†ç‚¸
                        this.mode = 'EXPLODING';
                        this.timer = 1.0; // åŠ¨ç”»å€’è®¡æ—¶
                        // ç”Ÿæˆè¿·ä½ çƒå½¢çŠ¶ä½œä¸ºåˆé€Ÿåº¦æ–¹å‘
                        // è¿™é‡Œç®€åŒ–ï¼Œç›´æ¥åœ¨ Update é‡Œç®—æ‰©æ•£
                    }

                    if (this.mode === 'EXPLODING') {
                        this.timer -= 0.04;
                        if (this.timer <= 0) {
                            this.mode = 'IDLE';
                            this.material.opacity = 0;
                        } else {
                            // çˆ†ç‚¸åŠ¨ç”»
                            this.material.opacity = this.timer;
                            this.material.color.setHex(0xffaa00); // é‡‘é»„
                            this.material.size = 0.2;

                            // å½¢æˆä¸€ä¸ªæŒ‡å¤´å¤§å°çš„çƒ (åŠå¾„ 0.8) å¹¶å¾®å¾®æ‰©æ•£
                            const pos = this.geometry.attributes.position.array;
                            const radius = 0.8 + (1.0 - this.timer) * 2.0; // éšæ—¶é—´å˜å¤§

                            for (let i = 0; i < this.count; i++) {
                                // ç®€å•çš„ä¼ªéšæœºçƒåˆ†å¸ƒ
                                const idx = i * 137.5; // é»„é‡‘è§’åˆ†å¸ƒ
                                const theta = idx;
                                const phi = Math.acos(2 * (i / this.count) - 1);

                                // åŠ ä¸Šæ—‹è½¬
                                const rot = time * 10;

                                pos[i * 3] = target.x + radius * Math.sin(phi) * Math.cos(theta + rot);
                                pos[i * 3 + 1] = target.y + radius * Math.sin(phi) * Math.sin(theta + rot);
                                pos[i * 3 + 2] = target.z + radius * Math.cos(phi);
                            }
                            this.geometry.attributes.position.needsUpdate = true;
                            document.getElementById('snap').innerText = "SNAP: BANG!";
                            document.getElementById('snap').style.color = "#ffaa00";
                        }
                    } else {
                        document.getElementById('snap').innerText = "SNAP: READY";
                        document.getElementById('snap').style.color = "#555";
                        this.material.opacity = 0;
                    }
                }
            }
        }

        // ==========================================
        // 5. æ ¸å¿ƒé€»è¾‘æ•´åˆ
        // ==========================================
        const mainSystem = new MainParticleSystem(scene);
        const snapSystem = new SnapSystem(scene);

        // å…¨å±€æ‰‹åŠ¿æ•°æ®
        const handState = {
            detected: false,
            hoverPos: new THREE.Vector3(0, 0, 0),
            verticalFactor: 0, // 0=Flat, 1=Side
            smoothVertical: 0,
            snapTouching: false, // æ‹‡æŒ‡ä¸­æŒ‡æ˜¯å¦æåˆ
            fingersCenter: new THREE.Vector3(0, 0, 0) // æ‹‡æŒ‡ä¸­æŒ‡ä¸­å¿ƒ
        };

        // è¾…åŠ©å‘é‡ - é¢„åˆ†é…å¤ç”¨
        const _v1 = new THREE.Vector3(), _v2 = new THREE.Vector3(), _normal = new THREE.Vector3();
        const _palmCenter = new THREE.Vector3(), _normalScaled = new THREE.Vector3();
        const _zeroVec = new THREE.Vector3(0, 0, 0); // å¤ç”¨é›¶å‘é‡
        const _tempVec = new THREE.Vector3(); // é€šç”¨ä¸´æ—¶å‘é‡

        // é¢„åˆ†é…çš„æ‰‹åŠ¿æ•°æ®å¯¹è±¡ - é¿å…æ¯å¸§åˆ›å»º
        const smoothHandData = { hoverPos: null, verticalFactor: 0 };

        const map = (lm) => _tempVec.set((lm.x - 0.5) * 30, -(lm.y - 0.5) * 20, -lm.z * 30).clone();

        function processHand(landmarks) {
            // 1. è·å–å…³é”®ç‚¹
            const wrist = map(landmarks[0]);
            const indexMCP = map(landmarks[5]);
            const pinkyMCP = map(landmarks[17]);
            const thumbTip = map(landmarks[4]);
            const middleTip = map(landmarks[12]);

            // 2. è®¡ç®—æ³•å‘é‡ (ç”¨äºä¸»ç²’å­æ‚¬æµ®)
            _v1.subVectors(indexMCP, wrist);
            _v2.subVectors(pinkyMCP, wrist);
            _normal.crossVectors(_v1, _v2).normalize();

            // *æ–¹å‘ä¿®æ­£*: ç¡®ä¿æ³•å‘æŒ‡å‘æ‰‹å¿ƒå¤– (æ ¹æ®å·¦æ‰‹/å³æ‰‹å¯èƒ½éœ€è¦ negate)
            // ç®€å• Hack: å¦‚æœæ³•å‘ Y < 0 (æŒ‡å‘ä¸‹), ç¿»è½¬å®ƒï¼Œç¡®ä¿ç²’å­æ€»æ˜¯åœ¨ä¸Šæ–¹
            // if (_normal.y < 0) _normal.negate(); 

            // 3. è®¡ç®—ä¾§ç«‹ç³»æ•°
            // æ³•å‘ X åˆ†é‡å¤§ = ä¾§ç«‹
            const vRaw = Math.abs(_normal.x);
            handState.verticalFactor = THREE.MathUtils.smoothstep(vRaw, 0.3, 0.8);

            // 4. è®¡ç®—ä¸»ç²’å­æ‚¬æµ®åæ ‡
            // ä¸­å¿ƒç‚¹ + æ³•å‘ * è·ç¦» (åŸºç¡€ 4.0 + ä¾§ç«‹é¢å¤–è·ç¦»)
            // ä½¿ç”¨é¢„åˆ†é…å‘é‡é¿å…clone
            _palmCenter.copy(wrist).add(indexMCP).add(pinkyMCP).divideScalar(3);
            const hoverDist = 4.0 + (handState.smoothVertical * 3.0);
            _normalScaled.copy(_normal).multiplyScalar(hoverDist);
            handState.hoverPos.copy(_palmCenter).add(_normalScaled);

            // 5. è®¡ç®—å“æŒ‡æ•°æ®
            const dist = thumbTip.distanceTo(middleTip);
            handState.snapTouching = dist < 2.5; // é˜ˆå€¼
            handState.fingersCenter.addVectors(thumbTip, middleTip).multiplyScalar(0.5);

            // UI Debug - å­˜å‚¨ç”¨äºèŠ‚æµæ›´æ–°
            handState._gestureText = `VERT: ${handState.verticalFactor.toFixed(2)} | SNAP_DIST: ${dist.toFixed(1)}`;
        }

        // MediaPipe Setup
        const videoEl = document.getElementById('input_video');
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        hands.onResults(results => {
            if (results.multiHandLandmarks.length > 0) {
                handState.detected = true;
                processHand(results.multiHandLandmarks[0]);
                document.getElementById('status').innerText = "SYSTEM: LOCKED";
                document.getElementById('status').style.color = "#00ffcc";
            } else {
                handState.detected = false;
                handState.snapTouching = false;
                document.getElementById('status').innerText = "SYSTEM: SEARCHING...";
                document.getElementById('status').style.color = "#ff0055";
            }
        });

        const cameraUtils = new Camera(videoEl, {
            onFrame: async () => await hands.send({ image: videoEl }),
            width: 1280, height: 720
        });
        cameraUtils.start();

        // ==========================================
        // 6. æ¸²æŸ“å¾ªç¯
        // ==========================================
        const clock = new THREE.Clock();
        let frameCount = 0; // å¸§è®¡æ•°å™¨ç”¨äºèŠ‚æµ

        // ç¼“å­˜ DOM å¼•ç”¨
        const gestureEl = document.getElementById('gesture');
        const snapEl = document.getElementById('snap');

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            frameCount++;

            // å¹³æ»‘æ•°æ® - ä½¿ç”¨é¢„åˆ†é…é›¶å‘é‡
            if (!handState.detected) {
                handState.hoverPos.lerp(_zeroVec, 0.05);
                handState.verticalFactor = 0;
            }
            handState.smoothVertical = THREE.MathUtils.lerp(handState.smoothVertical, handState.verticalFactor, 0.1);

            // å¤ç”¨é¢„åˆ†é…å¯¹è±¡
            smoothHandData.hoverPos = handState.hoverPos;
            smoothHandData.verticalFactor = handState.smoothVertical;

            mainSystem.update(smoothHandData, time);
            snapSystem.update(handState.fingersCenter, handState.snapTouching, time);

            // DOM æ›´æ–°èŠ‚æµï¼šæ¯ 5 å¸§æ›´æ–°ä¸€æ¬¡ UI
            if (frameCount % 5 === 0) {
                if (handState._gestureText) {
                    gestureEl.textContent = handState._gestureText;
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // resize é˜²æŠ–ä¼˜åŒ–
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }, 150);
        });
    </script>
</body>

</html>